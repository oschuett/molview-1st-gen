//generated by bundle_molpad.sh

define(function(require) {

var jQuery = require('jquery');
var $ = jQuery;

Array.prototype.each = function(iterator, context)
{
	for(var i = 0, length = this.length >>> 0; i < length; i++)
	{
		if(i in this)
		{
			if(iterator.call(context, this[i], i, this) === false)
				return;
		}
	}
}

Array.prototype.clone = function()
{
	return Array.prototype.slice.call(this, 0);
}

Array.prototype.find = function()
{
	var result;
    this.each(function(value, index)
    {
		if(iterator.call(context, value, index, this))
		{
			result = value;
			return false;
		}
		return true;
    }, this);
    return result;
}

Array.prototype.findAll = function()
{
	var results = [];
	this.each(function(value, index)
	{
		if(iterator.call(context, value, index, this))
		results.push(value);
	}, this);
	return results;
}

Number.prototype.toPaddedString = function(n)
{
	var str = this + '';
	return str.length >= n ? str : new Array(n - str.length + 1).join('0') + str;
}
/****************************************************************************
 * Copyright (C) 2009-2010 GGA Software Services LLC
 *
 * This file may be distributed and/or modified under the terms of the
 * GNU Affero General Public License version 3 as published by the Free
 * Software Foundation and appearing in the file LICENSE.GPL included in
 * the packaging of this file.
 *
 * This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
 * WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ***************************************************************************/

if(!window.util)
	util = {};

var EventMap = {
	mousemove: 'mousemove',
	mousedown: 'mousedown',
	mouseup: 'mouseup'
};

Array.prototype.swap = function (i1, i2)
{
	var tmp = this[i1];
	this[i1] = this[i2];
	this[i2] = tmp;
};

// "each" function for an array
util.each = function (array, func, context)
{
	util.assert(!util.isNullOrUndefined(array), "array must be defined");
	for(var i = 0; i < array.length; ++i)
		func.call(context, array[i], i);
};

util.map_each = function (map, func, context)
{
	util.assert(!util.isNullOrUndefined(map), "map must be defined");
	for(var key in map)
		func.call(context, key, map[key]);
};

util.find = function (array, func, context)
{
	for(var i = 0; i < array.length; ++i)
		if(func.call(context, array[i], i))
			return i;
	return -1;
};

util.findAll = function (array, func, context)
{
	var ret = [];
	for(var i = 0; i < array.length; ++i)
		if(func.call(context, array[i], i))
			ret.push(array[i]);
	return ret;
};

util.array = function (arrayLike)
{
	var a = [],
		i = arrayLike.length;
	while(--i >= 0)
		a[i] = arrayLike[i];
	return a;
};

util.isEmpty = function (obj)
{
	for(var v in obj)
		return false;
	return true;
};

util.stopEventPropagation = function (event)
{
	if('stopPropagation' in event) // Mozilla, Opera, Safari
		event.stopPropagation();
	else if('cancelBubble' in event) // IE
		event.cancelBubble = true;
	else
		throw Error("Browser unrecognized");
};

util.preventDefault = function (event)
{
	if('preventDefault' in event)
		event.preventDefault();
	if(Prototype.Browser.IE)
	{
		event.returnValue = false;
		event.keyCode = 0;
	}
	return false;
};

util.setElementTextContent = function (element, text)
{
	if('textContent' in element) // Mozilla, Opera, Safari
		element.textContent = text;
	else if('innerText' in element) // IE and others (except Mozilla)
		element.innerText = text;
	else
		throw Error("Browser unrecognized");
};

util.getElementTextContent = function (element)
{
	if('textContent' in element) // Mozilla, Opera, Safari
		return element.textContent;
	else if('innerText' in element) // IE and others (except Mozilla)
		return element.innerText;
	else
		throw Error("Browser unrecognized");
};

util.stringPadded = function (string, width, leftAligned)
{
	string += '';
	var space = '';
	while(string.length + space.length < width)
		space += ' ';
	if(leftAligned)
		return string + space;
	else
		return space + string;
};

util.idList = function (object)
{
	var list = [];
	for(var aid in object)
	{
		list.push(aid);
	}
	return list;
};

util.mapArray = function (src, map)
{
	var dst = [];
	for(var i = 0; i < src.length; ++i)
	{
		dst.push(map[src[i]]);
	}
	return dst;
};

util.arrayMax = function (array)
{
	return Math.max.apply(Math, array);
};

util.arrayMin = function (array)
{
	return Math.min.apply(Math, array);
};

util.map = function (src, func, context)
{
	var dst = [];
	for(var i = 0; i < src.length; ++i)
	{
		dst.push(func.call(context, src[i]));
	}
	return dst;
};

util.apply = function (array, func)
{
	for(var i = 0; i < array.length; ++i)
		array[i] = func(array[i]);
};

util.isUndefined = function (obj)
{
	return typeof (obj) === 'undefined';
}

util.ifDef = function (dst, src, prop, def)
{
	dst[prop] = !util.isUndefined(src[prop]) ? src[prop] : def;
};

util.ifDefList = function (dst, src, prop, def)
{
	dst[prop] = !util.isUndefined(src[prop]) && src[prop] !== null ? util.array(src[prop]) : def;
};

util.identityMap = function (array)
{
	var map = {};
	for(var i = 0; i < array.length; ++i)
		map[array[i]] = array[i];
	return map;
};

util.strip = function (src)
{
	return src.replace(/\s*$/, '').replace(/^\s*/, '');
};

util.stripRight = function (src)
{
	return src.replace(/\s*$/, '');
};

util.stripQuotes = function (str)
{
	if(str[0] === '"' && str[str.length - 1] === '"')
		return str.substr(1, str.length - 2);
	return str;
};

util.paddedFloat = function (number, width, precision)
{
	var numStr = number.toFixed(precision).replace(',', '.');
	if(numStr.length > width)
		throw new Error("number does not fit");
	return util.stringPadded(numStr, width);
};

util.paddedInt = function (number, width)
{
	var numStr = number.toFixed(0);
	if(numStr.length > width)
	{
		throw new Error("number does not fit");
	}
	return util.stringPadded(numStr, width);
};

util.arrayAddIfMissing = function (array, item)
{
	for(var i = 0; i < array.length; ++i)
		if(array[i] === item)
			return false;
	array.push(item);
	return true;
};

util.assert = function (condition, comment)
{
	if(!condition)
		throw new Error(comment ? ("Assertion failed: " + comment) : "Assertion failed");
};

util.isNull = function (variable)
{
	return variable === null;
};

util.isNullOrUndefined = function (v)
{
	return util.isUndefined(v) || util.isNull(v);
};

util.arrayRemoveByValue = function (array, item)
{
	util.assert(!util.isUndefined(array) && !util.isNull(array), "array must be defined");
	var idx = array.indexOf(item);
	var cnt = 0;
	while(idx >= 0)
	{
		array.splice(idx, 1);
		cnt += 1;
		idx = array.indexOf(item);
	}
	return cnt;
};

util.listNextRotate = function (list, value)
{
	return list[(list.indexOf(value) + 1) % list.length];
}

util.isArray = function (obj)
{
	return Object.prototype.toString.call(obj) === '[object Array]';
}
/****************************************************************************
 * Copyright (C) 2009-2010 GGA Software Services LLC
 *
 * This file may be distributed and/or modified under the terms of the
 * GNU Affero General Public License version 3 as published by the Free
 * Software Foundation and appearing in the file LICENSE.GPL included in
 * the packaging of this file.
 *
 * This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
 * WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ***************************************************************************/

// 2d-vector constructor and utilities
if(!window.util)
	util = {};

util.assertDefined = function (v)
{
	util.assert(!util.isNullOrUndefined(v));
};

util.Vec2 = function (x, y)
{
	if(arguments.length == 0)
	{
		this.x = 0;
		this.y = 0;
	}
	else if(arguments.length == 1)
	{
		this.x = parseFloat(x.x);
		this.y = parseFloat(x.y);
	}
	else if(arguments.length == 2)
	{
		this.x = parseFloat(x);
		this.y = parseFloat(y);
	}
	else
	{
		throw new Error("util.Vec2(): invalid arguments");
	}
};

util.Vec2.ZERO = new util.Vec2(0, 0);
util.Vec2.UNIT = new util.Vec2(1, 1);

util.Vec2.segmentIntersection = function (a, b, c, d)
{
	var dc = (a.x - c.x) * (b.y - c.y) - (a.y - c.y) * (b.x - c.x);
	var dd = (a.x - d.x) * (b.y - d.y) - (a.y - d.y) * (b.x - d.x);
	var da = (c.x - a.x) * (d.y - a.y) - (c.y - a.y) * (d.x - a.x);
	var db = (c.x - b.x) * (d.y - b.y) - (c.y - b.y) * (d.x - b.x);
	return dc * dd <= 0 && da * db <= 0;
}

util.Vec2.prototype.length = function ()
{
	return Math.sqrt(this.x * this.x + this.y * this.y);
};

util.Vec2.prototype.equals = function (v)
{
	util.assertDefined(v);
	return this.x == v.x && this.y == v.y;
};

util.Vec2.prototype.add = function (v)
{
	util.assertDefined(v);
	return new util.Vec2(this.x + v.x, this.y + v.y);
};

util.Vec2.prototype.add_ = function (v)
{
	util.assertDefined(v);
	this.x += v.x;
	this.y += v.y;
};

util.Vec2.prototype.sub = function (v)
{
	util.assertDefined(v);
	return new util.Vec2(this.x - v.x, this.y - v.y);
};

util.Vec2.prototype.scaled = function (s)
{
	util.assertDefined(s);
	return new util.Vec2(this.x * s, this.y * s);
};

util.Vec2.prototype.negated = function ()
{
	return new util.Vec2(-this.x, -this.y);
};

util.Vec2.prototype.yComplement = function (y1)
{
	y1 = y1 || 0;
	return new util.Vec2(this.x, y1 - this.y);
};

util.Vec2.prototype.addScaled = function (v, f)
{
	util.assertDefined(v);
	util.assertDefined(f);
	return new util.Vec2(this.x + v.x * f, this.y + v.y * f);
};

util.Vec2.prototype.normalized = function ()
{
	return this.scaled(1 / this.length());
};

util.Vec2.prototype.normalize = function ()
{
	var l = this.length();

	if(l < 0.000001)
		return false;

	this.x /= l;
	this.y /= l;

	return true;
};

util.Vec2.prototype.turnLeft = function ()
{
	return new util.Vec2(-this.y, this.x);
};

util.Vec2.prototype.coordStr = function ()
{
	return this.x.toString() + " , " + this.y.toString();
};

util.Vec2.prototype.toString = function ()
{
	return "(" + this.x.toFixed(2) + "," + this.y.toFixed(2) + ")";
};

util.Vec2.dist = function (a, b)
{
	util.assertDefined(a);
	util.assertDefined(b);
	return util.Vec2.diff(a, b).length();
};

util.Vec2.max = function (v1, v2)
{
	util.assertDefined(v1);
	util.assertDefined(v2);
	return new util.Vec2(Math.max(v1.x, v2.x), Math.max(v1.y, v2.y));
};

util.Vec2.min = function (v1, v2)
{
	util.assertDefined(v1);
	util.assertDefined(v2);
	return new util.Vec2(Math.min(v1.x, v2.x), Math.min(v1.y, v2.y));
};

util.Vec2.prototype.max = function (v)
{
	util.assertDefined(v);
	return new util.Vec2.max(this, v);
};

util.Vec2.prototype.min = function (v)
{
	util.assertDefined(v);
	return new util.Vec2.min(this, v);
};

util.Vec2.prototype.ceil = function ()
{
	return new util.Vec2(Math.ceil(this.x), Math.ceil(this.y));
};

util.Vec2.prototype.floor = function ()
{
	return new util.Vec2(Math.floor(this.x), Math.floor(this.y));
};

util.Vec2.sum = function (v1, v2)
{
	util.assertDefined(v1);
	util.assertDefined(v2);
	return new util.Vec2(v1.x + v2.x, v1.y + v2.y);
};

util.Vec2.dot = function (v1, v2)
{
	util.assertDefined(v1);
	util.assertDefined(v2);
	return v1.x * v2.x + v1.y * v2.y;
};

util.Vec2.cross = function (v1, v2)
{
	util.assertDefined(v1);
	util.assertDefined(v2);
	return v1.x * v2.y - v1.y * v2.x;
};

util.Vec2.prototype.rotate = function (angle)
{
	util.assertDefined(angle);
	var si = Math.sin(angle);
	var co = Math.cos(angle);

	return this.rotateSC(si, co);
};

util.Vec2.prototype.rotateSC = function (si, co)
{
	util.assertDefined(si);
	util.assertDefined(co);
	return new util.Vec2(this.x * co - this.y * si, this.x * si + this.y * co);
};

util.Vec2.angle = function (v1, v2)
{
	util.assertDefined(v1);
	util.assertDefined(v2);
	return Math.atan2(util.Vec2.cross(v1, v2), util.Vec2.dot(v1, v2));
};

util.Vec2.prototype.oxAngle = function ()
{
	return Math.atan2(this.y, this.x);
};

util.Vec2.diff = function (v1, v2)
{
	util.assertDefined(v1);
	util.assertDefined(v2);
	return new util.Vec2(v1.x - v2.x, v1.y - v2.y);
};

// assume arguments v1, f1, v2, f2, v3, f3, etc.
// where v[i] are vectors and f[i] are corresponding coefficients
util.Vec2.lc = function ()
{
	var v = new util.Vec2();
	for(var i = 0; i < arguments.length / 2; ++i)
		v = v.addScaled(arguments[2 * i], arguments[2 * i + 1]);
	return v;
};

util.Vec2.lc2 = function (v1, f1, v2, f2)
{
	util.assertDefined(v1);
	util.assertDefined(v2);
	util.assertDefined(f1);
	util.assertDefined(f2);
	return new util.Vec2(v1.x * f1 + v2.x * f2, v1.y * f1 + v2.y * f2);
};

util.Vec2.centre = function (v1, v2)
{
	return new util.Vec2.lc2(v1, 0.5, v2, 0.5);
}

util.Box2Abs = function ()
{
	if(arguments.length == 1 && 'min' in arguments[0] && 'max' in arguments[0])
	{
		this.p0 = arguments[0].min;
		this.p1 = arguments[0].max;
	}
	if(arguments.length == 2 && arguments[0] instanceof util.Vec2 && arguments[1] instanceof util.Vec2)
	{
		this.p0 = arguments[0];
		this.p1 = arguments[1];
	}
	else if(arguments.length == 4)
	{
		this.p0 = new util.Vec2(arguments[0], arguments[1]);
		this.p1 = new util.Vec2(arguments[2], arguments[3]);
	}
	else if(arguments.length == 0)
	{
		this.p0 = new util.Vec2();
		this.p1 = new util.Vec2();
	}
	else
		new Error("util.Box2Abs constructor only accepts 4 numbers or 2 vectors or no arguments!");
};

util.Box2Abs.prototype.toString = function ()
{
	return this.p0.toString() + " " + this.p1.toString();

}
util.Box2Abs.fromRelBox = function (relBox)
{
	util.assertDefined(relBox);
	return new util.Box2Abs(relBox.x, relBox.y,
		relBox.x + relBox.width, relBox.y + relBox.height);
};

util.Box2Abs.prototype.clone = function ()
{
	return new util.Box2Abs(this.p0, this.p1);
};

util.Box2Abs.union = function ( /*util.Box2Abs*/ b1, /*util.Box2Abs*/ b2)
{
	util.assertDefined(b1);
	util.assertDefined(b2);
	return new util.Box2Abs(util.Vec2.min(b1.p0, b2.p0), util.Vec2.max(b1.p1, b2.p1));
};

util.Box2Abs.prototype.extend = function ( /*util.Vec2*/ lp, /*util.Vec2*/ rb)
{
	util.assertDefined(lp);
	rb = rb || lp;
	return new util.Box2Abs(this.p0.sub(lp), this.p1.add(rb));
};

util.Box2Abs.prototype.include = function ( /*util.Vec2*/ p)
{
	util.assertDefined(p);
	return new util.Box2Abs(this.p0.min(p), this.p1.max(p));
};

util.Box2Abs.prototype.contains = function ( /*util.Vec2*/ p, /*float*/ ext)
{
	ext = (ext || 0) - 0;
	util.assertDefined(p);
	return p.x >= this.p0.x - ext && p.x <= this.p1.x + ext && p.y >= this.p0.y - ext && p.y <= this.p1.y + ext;
};

util.Box2Abs.prototype.translate = function ( /*util.Vec2*/ d)
{
	util.assertDefined(d);
	return new util.Box2Abs(this.p0.add(d), this.p1.add(d));
};

util.Box2Abs.prototype.transform = function ( /*function(Vec2):Vec2*/ f, context)
{
	util.assert(!util.isNullOrUndefined(f));
	return new util.Box2Abs(f.call(context, this.p0), f.call(context, this.p1));
};

util.Box2Abs.prototype.sz = function ()
{
	return this.p1.sub(this.p0);
};

util.Box2Abs.prototype.centre = function ()
{
	return util.Vec2.centre(this.p0, this.p1);
};

util.Box2Abs.prototype.pos = function ()
{
	return this.p0;
};

// find intersection of a ray and a box and
//  return the shift magnitude to avoid it
util.Vec2.shiftRayBox =
	function ( /*util.Vec2*/ p, /*util.Vec2*/ d, /*util.Box2Abs*/ bb)
	{
		util.assertDefined(p);
		util.assertDefined(d);
		util.assertDefined(bb);
		// four corner points of the box
		var b = [bb.p0, new util.Vec2(bb.p1.x, bb.p0.y),
            bb.p1, new util.Vec2(bb.p0.x, bb.p1.y)];
		var r = b.map(function (v)
		{
			return v.sub(p)
		}); // b relative to p
		d = d.normalized();
		var rc = r.map(function (v)
		{
			return util.Vec2.cross(v, d)
		}); // cross prods
		var rd = r.map(function (v)
		{
			return util.Vec2.dot(v, d)
		}); // dot prods

		// find foremost points on the right and on the left of the ray
		var pid = -1,
			nid = -1;
		for(var i = 0; i < 4; ++i)
			if(rc[i] > 0)
			{
				if(pid < 0 || rd[pid] < rd[i]) pid = i;
			}
			else
			{
				if(nid < 0 || rd[nid] < rd[i]) nid = i;
			}

		if(nid < 0 || pid < 0) // no intersection, no shift
			return 0;

		// check the order
		var id0, id1;
		if(rd[pid] > rd[nid])
			id0 = nid, id1 = pid;
		else
			id0 = pid, id1 = nid;

		// simple proportion to calculate the shift
		return rd[id0] + Math.abs(rc[id0]) * (rd[id1] - rd[id0]) / (Math.abs(rc[id0]) + Math.abs(rc[id1]));
	};
/****************************************************************************
 * Copyright (C) 2009-2010 GGA Software Services LLC
 *
 * This file may be distributed and/or modified under the terms of the
 * GNU Affero General Public License version 3 as published by the Free
 * Software Foundation and appearing in the file LICENSE.GPL included in
 * the packaging of this file.
 *
 * This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
 * WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ***************************************************************************/

if(!window.util)
	util = {};

util.Set = {
	empty: function ()
	{
		return {};
	},

	single: function (item)
	{
		var set = {};
		util.Set.add(set, item);
		return set;
	},

	size: function (set)
	{
		var cnt = 0;
		for(var id in set)
		{
			if(set [id] !== Object.prototype[id])
			{
				cnt++;
			}
		}
		return cnt;
	},

	contains: function (set, v)
	{
		return typeof (set [v]) != "undefined" && set [v] !== Object.prototype[v];
	},

	subset: function (subset, superset)
	{
		for(var id in subset)
		{
			if(subset[id] !== Object.prototype[id])
			{
				if(superset[id] !== subset[id])
				{
					return false;
				}
			}
		}
		return true;
	},

	intersection: function (set1, set2)
	{
		var set = {};
		for(var id in set1)
		{
			if(set1[id] !== Object.prototype[id])
			{
				if(set2[id] === set1[id])
				{
					util.Set.add(set, id);
				}
			}
		}
		return set;
	},

	disjoint: function (set1, set2)
	{
		for(var id in set1)
		{
			if(set1[id] !== Object.prototype[id])
			{
				if(set2[id] === set1[id])
				{
					return false;
				}
			}
		}
		return true;
	},

	eq: function (set1, set2)
	{
		return util.Set.subset(set1, set2) && util.Set.subset(set2, set1);
	},

	each: function (set, func, context)
	{
		for(var v in set)
		{
			if(set [v] !== Object.prototype[v])
			{
				func.call(context, set [v]);
			}
		}
	},

	filter: function (set, func, context)
	{
		var subset = {};
		for(var v in set)
		{
			if(set [v] !== Object.prototype[v])
			{
				if(func.call(context, set [v]))
				{
					subset[set [v]] = set [v];
				}
			}
		}
		return subset;
	},

	pick: function (set)
	{
		for(var v in set)
		{
			if(set [v] !== Object.prototype[v])
			{
				return set [v];
			}
		}
		return null;
	},

	list: function (set)
	{
		var list = [];
		for(var v in set)
		{
			if(set [v] !== Object.prototype[v])
			{
				list.push(set [v]);
			}
		}
		return list;
	},

	add: function (set, item)
	{
		set [item] = item;
	},

	mergeIn: function (set, other)
	{
		util.Set.each(other, function (item)
		{
			util.Set.add(set, item);
		});
	},

	remove: function (set, item)
	{
		var v = set [item];
		delete set [item];
		return v;
	},

	clone: function (other)
	{
		var set = {};
		util.Set.mergeIn(set, other);
		return set;
	},

	fromList: function (list)
	{
		var set = {};
		if(list)
		{
			for(var i = 0; i < list.length; ++i)
			{
				set [list[i] - 0] = list[i] - 0;
			}
		}
		return set;
	},

	keySetInt: function (map)
	{
		var set = {};
		map.each(function (id)
		{
			set [id - 0] = id - 0;
		});
		return set;
	},

	find: function (set, func, context)
	{
		for(var v in set)
		{
			if(set [v] !== Object.prototype[v])
			{
				if(func.call(context, set [v]))
				{
					return v;
				}
			}
		}
		return null;
	}
};
/****************************************************************************
 * Copyright (C) 2009-2010 GGA Software Services LLC
 *
 * This file may be distributed and/or modified under the terms of the
 * GNU Affero General Public License version 3 as published by the Free
 * Software Foundation and appearing in the file LICENSE.GPL included in
 * the packaging of this file.
 *
 * This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
 * WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ***************************************************************************/

if(!window.util)
	util = {};

util.Map = function (obj)
{
	if(typeof (obj) !== 'undefined' && obj.constructor !== Object)
		throw Error("Passed object is not an instance of 'Object'!");
	this._obj = obj ||
	{};
	this._count = 0;
};

util.Map.prototype.each = function (func, context)
{
	for(var v in this._obj)
	{
		var v_int = parseInt(v);
		var value = this._obj[v];

		if(!isNaN(v_int))
			v = v_int;
		func.call(context, v, value)
	}
};

util.Map.prototype.map = function (func, context)
{
	var ret = new util.Map();
	this.each(function (v, value)
	{
		ret.set(v, func.call(context, v, value));
	}, this);
	return ret;
};

util.Map.prototype.find = function (func, context)
{
	for(var v in this._obj)
	{
		var v_int = parseInt(v);
		var value = this._obj[v];

		if(!isNaN(v_int))
			v = v_int;
		if(func.call(context, v, value))
			return v;
	}
};

util.Map.prototype.findAll = function (func, context)
{
	var vv = [];
	for(var v in this._obj)
	{
		var v_int = parseInt(v);
		var value = this._obj[v];
		if(!isNaN(v_int))
			v = v_int;
		if(func.call(context, v, value))
			vv.push(v);
	}
	return vv;
};

util.Map.prototype.keys = function ()
{
	var keys = [];
	for(var v in this._obj)
	{
		keys.push(v);
	}
	return keys;
};

util.Map.prototype.ikeys = function ()
{
	var keys = [];
	for(var v in this._obj)
	{
		keys.push(v - 0);
	}
	return keys;
};

util.Map.prototype.set = function (key, value)
{
	this._count += (typeof (value) !== 'undefined' ? 1 : 0) - (typeof (this._obj[key]) !== 'undefined' ? 1 : 0);
	if(typeof (value) === 'undefined')
	{
		var val = this._obj[key];
		delete this._obj[key];
		return val;
	}
	else
	{
		return this._obj[key] = value;
	}
};

util.Map.prototype.get = function (key)
{
	if(this._obj[key] !== Object.prototype[key])
		return this._obj[key];
	return undefined;
};

util.Map.prototype.has = function (key)
{
	return(this._obj[key] !== Object.prototype[key]);
};

util.Map.prototype.unset = function (key)
{
	return this.set(key, undefined);
};

util.Map.prototype.update = function (object)
{
	for(var v in object)
		this.set(v, object[v]);
};

util.Map.prototype.clear = function ()
{
	this._obj = {};
	this._count = 0;
};

util.Map.prototype.count = function ()
{
	return this._count;
};

util.Map.prototype.idList = function ()
{
	return util.idList(this._obj);
};

util.Map.prototype.keyOf = function (value)
{
	for(var key in this._obj)
		if(this._obj[key] === value) return key;
};
/****************************************************************************
 * Copyright (C) 2009-2010 GGA Software Services LLC
 *
 * This file may be distributed and/or modified under the terms of the
 * GNU Affero General Public License version 3 as published by the Free
 * Software Foundation and appearing in the file LICENSE.GPL included in
 * the packaging of this file.
 *
 * This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
 * WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ***************************************************************************/

if(!window.util || !util.Map)
	throw new Error("Map should be defined first");

util.Pool = function ()
{
	this._map = new util.Map();
	this._nextId = 0;
};

util.Pool.prototype.newId = function ()
{
	return this._nextId++;
};

util.Pool.prototype.add = function (obj)
{
	var id = this._nextId++;
	this._map.set(id, obj);
	return id;
};

util.Pool.prototype.set = function (id, obj)
{
	this._map.set(id, obj);
};

util.Pool.prototype.get = function (id)
{
	return this._map.get(id);
};

util.Pool.prototype.has = function (id)
{
	return this._map.has(id);
};

util.Pool.prototype.remove = function (id)
{
	return this._map.unset(id);
};

util.Pool.prototype.clear = function ()
{
	this._map.clear();
};

util.Pool.prototype.keys = function ()
{
	return this._map.keys();
};

util.Pool.prototype.ikeys = function ()
{
	return this._map.ikeys();
};

util.Pool.prototype.each = function (func, context)
{
	this._map.each(func, context);
};

util.Pool.prototype.map = function (func, context)
{
	return this._map.map(func, context);
};

util.Pool.prototype.find = function (func, context)
{
	return this._map.find(func, context);
};

util.Pool.prototype.count = function ()
{
	return this._map.count();
};

util.Pool.prototype.keyOf = function (value)
{
	return this._map.keyOf(value);
};
/****************************************************************************
 * Copyright (C) 2009-2010 GGA Software Services LLC
 *
 * This file may be distributed and/or modified under the terms of the
 * GNU Affero General Public License version 3 as published by the Free
 * Software Foundation and appearing in the file LICENSE.GPL included in
 * the packaging of this file.
 *
 * This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
 * WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ***************************************************************************/

if(!window.util || !util.Vec2)
	throw new Error("Vec2 should be defined first");

if(!window.chem)
	chem = {};

function hexToRGB(hex)
{
	return {
		'r': parseInt(hex.substring(1, 3), 16),
		'g': parseInt(hex.substring(3, 5), 16),
		'b': parseInt(hex.substring(5, 7), 16)
	};
}

function rgbCompToHex(c)
{
	c = c.toFixed();
	c = Math.max(Math.min(c, 255), 0);
	var hex = c.toString(16);
	if(hex.length < 2)
		hex = '0' + hex;
	return hex;
}

function rgbToHex(rgb)
{
	return '#' +
		rgbCompToHex(rgb.r) +
		rgbCompToHex(rgb.g) +
		rgbCompToHex(rgb.b);
}

function rgbRescale(rgb, maxNorm)
{
	var norm = 0.21 * rgb.r + 0.72 * rgb.g + 0.07 * rgb.b;
	if(norm <= maxNorm)
		return rgb;
	return {
		'r': (rgb.r * maxNorm / norm).toFixed() - 0,
		'g': (rgb.g * maxNorm / norm).toFixed() - 0,
		'b': (rgb.b * maxNorm / norm).toFixed() - 0
	}
}

// element table and utilities
chem.Element = function (label, period, group, putHydrogenOnTheLeft, color, ypos, xpos)
{
	this.label = label;
	this.period = period;
	this.group = group;
	this.putHydrogenOnTheLeft = putHydrogenOnTheLeft;
	this.color = color || '#000000';
	this.labelColor = rgbToHex(rgbRescale(hexToRGB(this.color), 150));
	this.xpos = xpos || group;
	this.ypos = ypos || period;

	var r = (("0x" + this.color.substring(1, 3)) - 0) / 255;
	var g = (("0x" + this.color.substring(3, 5)) - 0) / 255;
	var b = (("0x" + this.color.substring(5, 7)) - 0) / 255;
	var luminance = 0.299 * r + 0.587 * g + 0.114 * b;
	if(luminance > 0.6)
	{
		r *= 0.6 / luminance;
		g *= 0.6 / luminance;
		b *= 0.6 / luminance;
	}
	r = Math.ceil(Math.min(r * 255, 255)).toString(16);
	g = Math.ceil(Math.min(g * 255, 255)).toString(16);
	b = Math.ceil(Math.min(b * 255, 255)).toString(16);
	r = r.length == 1 ? "0" + r : r;
	g = g.length == 1 ? "0" + g : g;
	b = b.length == 1 ? "0" + b : b;
	this.color = "#" + r + g + b;

};

chem.Element.elements = new util.Map(
{
	//common elements
	1: new chem.Element('H', 1, 1, false, '#000000', 1, 1),
	2: new chem.Element('He', 1, 8, false, '#d9ffff', 1, 18),
	3: new chem.Element('Li', 2, 1, false, '#cc80ff', 2, 1),
	4: new chem.Element('Be', 2, 2, false, '#c2ff00', 2, 2),
	5: new chem.Element('B', 2, 3, false, '#ffb5b5', 2, 13),
	6: new chem.Element('C', 2, 4, false, '#000000', 2, 14),
	7: new chem.Element('N', 2, 5, false, '#304ff7', 2, 15),
	8: new chem.Element('O', 2, 6, true, '#ff0d0d', 2, 16),
	9: new chem.Element('F', 2, 7, true, '#8fe04f', 2, 17),
	10: new chem.Element('Ne', 2, 8, false, '#b3e3f5', 2, 18),
	11: new chem.Element('Na', 3, 1, false, '#ab5cf2', 3, 1),
	12: new chem.Element('Mg', 3, 2, false, '#8aff00', 3, 2),
	13: new chem.Element('Al', 3, 3, false, '#bfa6a6', 3, 13),
	14: new chem.Element('Si', 3, 4, false, '#f0c7a1', 3, 14),
	15: new chem.Element('P', 3, 5, false, '#ff8000', 3, 15),
	16: new chem.Element('S', 3, 6, true, '#d9a61a', 3, 16),
	17: new chem.Element('Cl', 3, 7, true, '#1fd01f', 3, 17),
	18: new chem.Element('Ar', 3, 8, false, '#80d1e3', 3, 18),
	19: new chem.Element('K', 4, 1, false, '#8f40d4', 4, 1),
	20: new chem.Element('Ca', 4, 2, false, '#3dff00', 4, 2),
	21: new chem.Element('Sc', 4, 3, false, '#e6e6e6', 4, 3),
	22: new chem.Element('Ti', 4, 4, false, '#bfc2c7', 4, 4),
	23: new chem.Element('V', 4, 5, false, '#a6a6ab', 4, 5),
	24: new chem.Element('Cr', 4, 6, false, '#8a99c7', 4, 6),
	25: new chem.Element('Mn', 4, 7, false, '#9c7ac7', 4, 7),
	26: new chem.Element('Fe', 4, 8, false, '#e06633', 4, 8),
	27: new chem.Element('Co', 4, 8, false, '#f08fa1', 4, 9),
	28: new chem.Element('Ni', 4, 8, false, '#4fd14f', 4, 10),
	29: new chem.Element('Cu', 4, 1, false, '#c78033', 4, 11),
	30: new chem.Element('Zn', 4, 2, false, '#7d80b0', 4, 12),
	31: new chem.Element('Ga', 4, 3, false, '#c28f8f', 4, 13),
	32: new chem.Element('Ge', 4, 4, false, '#668f8f', 4, 14),
	33: new chem.Element('As', 4, 5, false, '#bd80e3', 4, 15),
	34: new chem.Element('Se', 4, 6, true, '#ffa100', 4, 16),
	35: new chem.Element('Br', 4, 7, true, '#a62929', 4, 17),
	36: new chem.Element('Kr', 4, 8, false, '#5cb8d1', 4, 18),
	37: new chem.Element('Rb', 5, 1, false, '#702eb0', 5, 1),
	38: new chem.Element('Sr', 5, 2, false, '#00ff00', 5, 2),
	39: new chem.Element('Y', 5, 3, false, '#94ffff', 5, 3),
	40: new chem.Element('Zr', 5, 4, false, '#94e0e0', 5, 4),
	41: new chem.Element('Nb', 5, 5, false, '#73c2c9', 5, 5),
	42: new chem.Element('Mo', 5, 6, false, '#54b5b5', 5, 6),
	43: new chem.Element('Tc', 5, 7, false, '#3b9e9e', 5, 7),
	44: new chem.Element('Ru', 5, 8, false, '#248f8f', 5, 8),
	45: new chem.Element('Rh', 5, 8, false, '#0a7d8c', 5, 9),
	46: new chem.Element('Pd', 5, 8, false, '#006985', 5, 10),
	47: new chem.Element('Ag', 5, 1, false, '#bfbfbf', 5, 11),
	48: new chem.Element('Cd', 5, 2, false, '#ffd98f', 5, 12),
	49: new chem.Element('In', 5, 3, false, '#a67573', 5, 13),
	50: new chem.Element('Sn', 5, 4, false, '#668080', 5, 14),
	51: new chem.Element('Sb', 5, 5, false, '#9e63b5', 5, 15),
	52: new chem.Element('Te', 5, 6, false, '#d47a00', 5, 16),
	53: new chem.Element('I', 5, 7, true, '#940094', 5, 17),
	54: new chem.Element('Xe', 5, 8, false, '#429eb0', 5, 18),
	55: new chem.Element('Cs', 6, 1, false, '#57178f', 6, 1),
	56: new chem.Element('Ba', 6, 2, false, '#00c900', 6, 2),
	57: new chem.Element('La', 6, 3, false, '#70d4ff', 6, 3),
	58: new chem.Element('Ce', 6, 3, false, '#ffffc7', 8, 4),
	59: new chem.Element('Pr', 6, 3, false, '#d9ffc7', 8, 5),
	60: new chem.Element('Nd', 6, 3, false, '#c7ffc7', 8, 6),
	61: new chem.Element('Pm', 6, 3, false, '#a3ffc7', 8, 7),
	62: new chem.Element('Sm', 6, 3, false, '#8fffc7', 8, 8),
	63: new chem.Element('Eu', 6, 3, false, '#61ffc7', 8, 9),
	64: new chem.Element('Gd', 6, 3, false, '#45ffc7', 8, 10),
	65: new chem.Element('Tb', 6, 3, false, '#30ffc7', 8, 11),
	66: new chem.Element('Dy', 6, 3, false, '#1fffc7', 8, 12),
	67: new chem.Element('Ho', 6, 3, false, '#00ff9c', 8, 13),
	68: new chem.Element('Er', 6, 3, false, '#00e675', 8, 14),
	69: new chem.Element('Tm', 6, 3, false, '#00d452', 8, 15),
	70: new chem.Element('Yb', 6, 3, false, '#00bf38', 8, 16),
	71: new chem.Element('Lu', 6, 3, false, '#00ab24', 8, 17),
	72: new chem.Element('Hf', 6, 4, false, '#4dc2ff', 6, 4),
	73: new chem.Element('Ta', 6, 5, false, '#4da6ff', 6, 5),
	74: new chem.Element('W', 6, 6, false, '#2194d6', 6, 6),
	75: new chem.Element('Re', 6, 7, false, '#267dab', 6, 7),
	76: new chem.Element('Os', 6, 8, false, '#266696', 6, 8),
	77: new chem.Element('Ir', 6, 8, false, '#175487', 6, 9),
	78: new chem.Element('Pt', 6, 8, false, '#d1d1e0', 6, 10),
	79: new chem.Element('Au', 6, 1, false, '#ffd124', 6, 11),
	80: new chem.Element('Hg', 6, 2, false, '#b8b8d1', 6, 12),
	81: new chem.Element('Tl', 6, 3, false, '#a6544d', 6, 13),
	82: new chem.Element('Pb', 6, 4, false, '#575961', 6, 14),
	83: new chem.Element('Bi', 6, 5, false, '#9e4fb5', 6, 15),
	84: new chem.Element('Po', 6, 6, false, '#ab5c00', 6, 16),
	85: new chem.Element('At', 6, 7, false, '#754f45', 6, 17),
	86: new chem.Element('Rn', 6, 8, false, '#428296', 6, 18),
	87: new chem.Element('Fr', 7, 1, false, '#420066', 7, 1),
	88: new chem.Element('Ra', 7, 2, false, '#007d00', 7, 2),
	89: new chem.Element('Ac', 7, 3, false, '#70abfa', 7, 3),
	90: new chem.Element('Th', 7, 3, false, '#00baff', 9, 4),
	91: new chem.Element('Pa', 7, 3, false, '#00a1ff', 9, 5),
	92: new chem.Element('U', 7, 3, false, '#008fff', 9, 6),
	93: new chem.Element('Np', 7, 3, false, '#0080ff', 9, 7),
	94: new chem.Element('Pu', 7, 3, false, '#006bff', 9, 8),
	95: new chem.Element('Am', 7, 3, false, '#545cf2', 9, 9),
	96: new chem.Element('Cm', 7, 3, false, '#785ce3', 9, 10),
	97: new chem.Element('Bk', 7, 3, false, '#8a4fe3', 9, 11),
	98: new chem.Element('Cf', 7, 3, false, '#a136d4', 9, 12),
	99: new chem.Element('Es', 7, 3, false, '#b31fd4', 9, 13),
	100: new chem.Element('Fm', 7, 3, false, '#B31FBA', 9, 14),
	101: new chem.Element('Md', 7, 3, false, '#B30DA6', 9, 15),
	102: new chem.Element('No', 7, 3, false, '#BD0D87', 9, 16),
	103: new chem.Element('Lr', 7, 3, false, '#C70066', 9, 17),
	104: new chem.Element('Rf', 7, 4, false, '#CC0059', 7, 4),
	105: new chem.Element('Db', 7, 5, false, '#D1004F', 7, 5),
	106: new chem.Element('Sg', 7, 6, false, '#D90045', 7, 6),
	107: new chem.Element('Bh', 7, 7, false, '#E00038', 7, 7),
	108: new chem.Element('Hs', 7, 8, false, '#E6002E', 7, 8),
	109: new chem.Element('Mt', 7, 8, false, '#EB0026', 7, 9),
	110: new chem.Element('Ds', 7, 8, false, '#9595a0', 7, 10),
	111: new chem.Element('Rg', 7, 1, false, '#b9981a', 7, 11),
	112: new chem.Element('Cn', 7, 2, false, '#9595a9', 7, 12),
});

chem.Element.labelMap = null;

chem.Element.getElementByLabel = function (label)
{
	if(!this.labelMap)
	{
		this.labelMap = {};
		this.elements.each(function (key, value)
		{
			this.labelMap[value.label] = key - 0;
		}, this);
	}
	if(!this.labelMap.hasOwnProperty(label))
		return null;
	return this.labelMap[label];
};
/****************************************************************************
 * Copyright (C) 2009-2010 GGA Software Services LLC
 *
 * This file may be distributed and/or modified under the terms of the
 * GNU Affero General Public License version 3 as published by the Free
 * Software Foundation and appearing in the file LICENSE.GPL included in
 * the packaging of this file.
 *
 * This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
 * WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ***************************************************************************/

// chem.Struct constructor and utilities are defined here
if(!window.chem || !util.Vec2 || !util.Pool)
	throw new Error("Vec2, Pool should be defined first");

chem.Struct = function ()
{
	this.atoms = new util.Pool();
	this.bonds = new util.Pool();
	this.sgroups = new util.Pool();
	this.halfBonds = new util.Map();
	this.loops = new util.Pool();
	this.isChiral = false;
	this.isReaction = false;
	this.rxnArrows = new util.Pool();
	this.rxnPluses = new util.Pool();
	this.frags = new util.Pool();
	this.rgroups = new util.Map();
	this.name = '';
	this.sGroupForest = new chem.SGroupForest(this);
};

chem.Struct.prototype.hasRxnProps = function ()
{
	return this.atoms.find(function (aid, atom)
	{
		return atom.hasRxnProps();
	}, this) >= 0 || this.bonds.find(function (bid, bond)
	{
		return bond.hasRxnProps();
	}, this) >= 0;
}

chem.Struct.prototype.hasRxnArrow = function ()
{
	return this.rxnArrows.count() > 0;
}

chem.Struct.prototype.addRxnArrowIfNecessary = function ()
{
	var implicitReaction = !this.hasRxnArrow() && this.hasRxnProps();
	if(implicitReaction)
		this.rxnArrows.add(new chem.Struct.RxnArrow());
	return implicitReaction;
}

// returns a list of id's of s-groups, which contain only atoms in the given list
chem.Struct.prototype.getSGroupsInAtomSet = function (atoms /*Array*/ )
{
	var sgroup_counts = new Hash();

	util.each(atoms, function (aid)
	{
		var sg = util.Set.list(this.atoms.get(aid).sgs);

		sg.each(function (sid)
		{
			var n = sgroup_counts.get(sid);
			if(util.isUndefined(n))
				n = 1;
			else
				n++;
			sgroup_counts.set(sid, n);
		}, this);
	}, this);

	var sgroup_list = [];
	sgroup_counts.each(function (sg)
	{
		var sid = parseInt(sg.key);
		var sgroup = this.sgroups.get(sid);
		var sgAtoms = chem.SGroup.getAtoms(this, sgroup);
		if(sg.value == sgAtoms.length)
			sgroup_list.push(sid);
	}, this);
	return sgroup_list;
}

chem.Struct.prototype.isBlank = function ()
{
	return this.atoms.count() == 0 &&
		this.rxnArrows.count() == 0 &&
		this.rxnPluses.count() == 0 &&
		!this.isChiral;
};

chem.Struct.prototype.toLists = function ()
{
	var aidMap = {};
	var atomList = [];
	this.atoms.each(function (aid, atom)
	{
		aidMap[aid] = atomList.length;
		atomList.push(atom);
	});

	var bondList = [];
	this.bonds.each(function (bid, bond)
	{
		var b = new chem.Struct.Bond(bond);
		b.begin = aidMap[bond.begin];
		b.end = aidMap[bond.end];
		bondList.push(b);
	});

	return {
		'atoms': atomList,
		'bonds': bondList
	};
};

chem.Struct.prototype.clone = function (atomSet, bondSet, dropRxnSymbols, aidMap)
{
	var cp = new chem.Struct();
	return this.mergeInto(cp, atomSet, bondSet, dropRxnSymbols, false, aidMap);
};

chem.Struct.prototype.getScaffold = function ()
{
	var atomSet = util.Set.empty();
	this.atoms.each(function (aid)
	{
		util.Set.add(atomSet, aid);
	}, this);
	this.rgroups.each(function (rgid, rg)
	{
		rg.frags.each(function (fnum, fid)
		{
			this.atoms.each(function (aid, atom)
			{
				if(atom.fragment == fid)
				{
					util.Set.remove(atomSet, aid);
				}
			}, this);
		}, this);
	}, this);
	return this.clone(atomSet);
};

chem.Struct.prototype.getFragmentIds = function (fid)
{
	var atomSet = util.Set.empty();
	this.atoms.each(function (aid, atom)
	{
		if(atom.fragment == fid)
		{
			util.Set.add(atomSet, aid);
		}
	}, this);
	return atomSet;
};

chem.Struct.prototype.getFragment = function (fid)
{
	return this.clone(this.getFragmentIds(fid));
};

chem.Struct.prototype.mergeInto = function (cp, atomSet, bondSet, dropRxnSymbols, keepAllRGroups, aidMap)
{
	atomSet = atomSet || util.Set.keySetInt(this.atoms);
	bondSet = bondSet || util.Set.keySetInt(this.bonds);
	bondSet = util.Set.filter(bondSet, function (bid)
	{
		var bond = this.bonds.get(bid);
		return util.Set.contains(atomSet, bond.begin) && util.Set.contains(atomSet, bond.end);
	}, this);

	var fidMask = {};
	this.atoms.each(function (aid, atom)
	{
		if(util.Set.contains(atomSet, aid))
			fidMask[atom.fragment] = 1;
	});
	var fidMap = {};
	this.frags.each(function (fid, frag)
	{
		if(fidMask[fid])
			fidMap[fid] = cp.frags.add(frag.clone());
	});

	this.rgroups.each(function (rgid, rgroup)
	{
		var keepGroup = keepAllRGroups;
		if(!keepGroup)
		{
			rgroup.frags.each(function (fnum, fid)
			{
				if(fidMask[fid])
					keepGroup = true;
			});
			if(!keepGroup)
				return;
		}
		var rg = cp.rgroups.get(rgid);
		if(rg)
		{
			rgroup.frags.each(function (fnum, fid)
			{
				if(fidMask[fid])
					rg.frags.add(fidMap[fid]);
			});
		}
		else
		{
			cp.rgroups.set(rgid, rgroup.clone(fidMap));
		}
	});

	if(typeof aidMap === 'undefined' || aidMap === null)
		aidMap = {};
	this.atoms.each(function (aid, atom)
	{
		if(util.Set.contains(atomSet, aid))
			aidMap[aid] = cp.atoms.add(atom.clone(fidMap));
	});

	var bidMap = {};
	this.bonds.each(function (bid, bond)
	{
		if(util.Set.contains(bondSet, bid))
			bidMap[bid] = cp.bonds.add(bond.clone(aidMap));
	});

	this.sgroups.each(function (sid, sg)
	{
		var i;
		for(i = 0; i < sg.atoms.length; ++i)
			if(!util.Set.contains(atomSet, sg.atoms[i]))
				return;
		sg = chem.SGroup.clone(sg, aidMap, bidMap);
		var id = cp.sgroups.add(sg);
		sg.id = id;
		for(i = 0; i < sg.atoms.length; ++i)
		{
			util.Set.add(cp.atoms.get(sg.atoms[i]).sgs, id);
		}
		cp.sGroupForest.insert(sg.id);
	});
	cp.isChiral = this.isChiral;
	if(!dropRxnSymbols)
	{
		cp.isReaction = this.isReaction;
		this.rxnArrows.each(function (id, item)
		{
			cp.rxnArrows.add(item.clone());
		});
		this.rxnPluses.each(function (id, item)
		{
			cp.rxnPluses.add(item.clone());
		});
	}
	return cp;
};

chem.Struct.prototype.findBondId = function (begin, end)
{
	var id = -1;

	this.bonds.find(function (bid, bond)
	{
		if((bond.begin == begin && bond.end == end) ||
			(bond.begin == end && bond.end == begin))
		{
			id = bid;
			return true;
		}
		return false;
	}, this);

	return id;
};

chem.Struct.ATOM = {
	RADICAL:
	{
		NONE: 0,
		SINGLET: 1,
		DOUPLET: 2,
		TRIPLET: 3
	}
};

chem.Struct.radicalElectrons = function (radical)
{
	radical = radical - 0;
	if(radical == chem.Struct.ATOM.RADICAL.NONE)
		return 0;
	else if(radical == chem.Struct.ATOM.RADICAL.DOUPLET)
		return 1;
	else if(radical == chem.Struct.ATOM.RADICAL.SINGLET ||
		radical == chem.Struct.ATOM.RADICAL.TRIPLET)
		return 2;
	throw new Error("Unknown radical value");
};

chem.Struct.BOND = {
	TYPE:
	{
		SINGLE: 1,
		DOUBLE: 2,
		TRIPLE: 3,
		AROMATIC: 4,
		SINGLE_OR_DOUBLE: 5,
		SINGLE_OR_AROMATIC: 6,
		DOUBLE_OR_AROMATIC: 7,
		ANY: 8
	},

	STEREO:
	{
		NONE: 0,
		UP: 1,
		EITHER: 4,
		DOWN: 6,
		CIS_TRANS: 3
	},

	TOPOLOGY:
	{
		EITHER: 0,
		RING: 1,
		CHAIN: 2
	},

	REACTING_CENTER:
	{
		NOT_CENTER: -1,
		UNMARKED: 0,
		CENTER: 1,
		UNCHANGED: 2,
		MADE_OR_BROKEN: 4,
		ORDER_CHANGED: 8,
		MADE_OR_BROKEN_AND_CHANGED: 12
	}
};

chem.Struct.FRAGMENT = {
	NONE: 0,
	REACTANT: 1,
	PRODUCT: 2,
	AGENT: 3
};

chem.Struct.Atom = function (params)
{
	var def = chem.Struct.Atom.attrGetDefault;
	if(!params || !('label' in params))
		throw new Error("Label must be specified!");

	this.label = params.label;
	this.fragment = !util.isUndefined(params.fragment) ? params.fragment : -1;

	util.ifDef(this, params, 'isotope', def('isotope'));
	util.ifDef(this, params, 'radical', def('radical'));
	util.ifDef(this, params, 'charge', def('charge'));
	util.ifDef(this, params, 'rglabel', def('rglabel')); // r-group index mask, i-th bit stands for i-th r-site
	util.ifDef(this, params, 'attpnt', def('attpnt')); // attachment point
	util.ifDef(this, params, 'explicitValence', def('explicitValence'));

	this.valence = 0;
	this.implicitH = 0; // implicitH is not an attribute
	if(!util.isUndefined(params.pp))
		this.pp = new util.Vec2(params.pp);
	else
		this.pp = new util.Vec2();

	// sgs should only be set when an atom is added to an s-group by an appropriate method,
	//   or else a copied atom might think it belongs to a group, but the group be unaware of the atom
	// TODO: make a consistency check on atom/s-group assignments
	this.sgs = {};

	// query
	util.ifDef(this, params, 'ringBondCount', def('ringBondCount'));
	util.ifDef(this, params, 'substitutionCount', def('substitutionCount'));
	util.ifDef(this, params, 'unsaturatedAtom', def('unsaturatedAtom'));
	util.ifDef(this, params, 'hCount', def('hCount'));

	// reaction
	util.ifDef(this, params, 'aam', def('aam'));
	util.ifDef(this, params, 'invRet', def('invRet'));
	util.ifDef(this, params, 'exactChangeFlag', def('exactChangeFlag'));
	util.ifDef(this, params, 'rxnFragmentType', -1); // this isn't really an attribute

	this.atomList = !util.isUndefined(params.atomList) && params.atomList != null ? new chem.Struct.AtomList(params.atomList) : null;
	this.neighbors = []; // set of half-bonds having this atom as their origin
	this.badConn = false;
};

chem.Struct.Atom.getAttrHash = function (atom)
{
	var attrs = new Hash();
	for(var attr in chem.Struct.Atom.attrlist)
	{
		if(typeof (atom[attr]) != 'undefined')
		{
			attrs.set(attr, atom[attr]);
		}
	}
	return attrs;
};

chem.Struct.Atom.attrGetDefault = function (attr)
{
	if(attr in chem.Struct.Atom.attrlist)
		return chem.Struct.Atom.attrlist[attr];
	throw new Error("Attribute unknown");
}

chem.Struct.Atom.attrlist = {
	'label': 'C',
	'isotope': 0,
	'radical': 0,
	'charge': 0,
	'explicitValence': -1,
	'ringBondCount': 0,
	'substitutionCount': 0,
	'unsaturatedAtom': 0,
	'hCount': 0,
	'atomList': null,
	'invRet': 0,
	'exactChangeFlag': 0,
	'rglabel': null,
	'attpnt': null,
	'aam': 0
};

chem.Struct.Atom.prototype.clone = function (fidMap)
{
	var ret = new chem.Struct.Atom(this);
	if(fidMap && this.fragment in fidMap)
	{
		ret.fragment = fidMap[this.fragment];
	}
	return ret;
};

chem.Struct.Atom.prototype.isQuery = function ()
{
	return this.atomList != null || this.label == 'A' || this.attpnt || this.hCount;
};

chem.Struct.Atom.prototype.pureHydrogen = function ()
{
	return this.label == 'H' && this.isotope == 0;
};

chem.Struct.Atom.prototype.isPlainCarbon = function ()
{
	return this.label == 'C' && this.isotope == 0 && this.radical == 0 && this.charge == 0 && this.explicitValence < 0 && this.ringBondCount == 0 && this.substitutionCount == 0 && this.unsaturatedAtom == 0 && this.hCount == 0 && !this.atomList;
};

chem.Struct.Atom.prototype.isPseudo = function ()
{
	// TODO: handle reaxys generics separately
	return !this.atomList && !this.rglabel && !chem.Element.getElementByLabel(this.label);
};

chem.Struct.Atom.prototype.hasRxnProps = function ()
{
	return !!(this.invRet || this.exactChangeFlag || !util.isNull(this.attpnt) || this.aam);
};

chem.Struct.AtomList = function (params)
{
	if(!params || !('notList' in params) || !('ids' in params))
		throw new Error("'notList' and 'ids' must be specified!");

	this.notList = params.notList; /*boolean*/
	this.ids = params.ids; /*Array of integers*/
};

chem.Struct.AtomList.prototype.labelList = function ()
{
	var labels = [];
	for(var i = 0; i < this.ids.length; ++i)
		labels.push(chem.Element.elements.get(this.ids[i]).label);
	return labels;
};

chem.Struct.AtomList.prototype.label = function ()
{
	var label = "[" + this.labelList().join(",") + "]";
	if(this.notList)
		label = "!" + label;
	return label;
};

chem.Struct.AtomList.prototype.equals = function (x)
{
	return this.notList == x.notList && (this.ids || []).sort().toString() == (x.ids || []).sort().toString();
};

chem.Struct.Bond = function (params)
{
	if(!params || !('begin' in params) || !('end' in params) || !('type' in params))
		throw new Error("'begin', 'end' and 'type' properties must be specified!");

	this.begin = params.begin;
	this.end = params.end;
	this.type = params.type;
	util.ifDef(this, params, 'stereo', chem.Struct.BOND.STEREO.NONE);
	util.ifDef(this, params, 'topology', chem.Struct.BOND.TOPOLOGY.EITHER);
	util.ifDef(this, params, 'reactingCenterStatus', 0);
	this.hb1 = null; // half-bonds
	this.hb2 = null;
	this.len = 0;
	this.center = new util.Vec2();
	this.sb = 0;
	this.sa = 0;
	this.angle = 0;
};

chem.Struct.Bond.attrlist = {
	'type': chem.Struct.BOND.TYPE.SINGLE,
	'stereo': chem.Struct.BOND.STEREO.NONE,
	'topology': chem.Struct.BOND.TOPOLOGY.EITHER,
	'reactingCenterStatus': 0
};

chem.Struct.Bond.getAttrHash = function (bond)
{
	var attrs = new Hash();
	for(var attr in chem.Struct.Bond.attrlist)
	{
		if(typeof (bond[attr]) !== 'undefined')
		{
			attrs.set(attr, bond[attr]);
		}
	}
	return attrs;
};

chem.Struct.Bond.attrGetDefault = function (attr)
{
	if(attr in chem.Struct.Bond.attrlist)
		return chem.Struct.Bond.attrlist[attr];
	throw new Error("Attribute unknown");
}

chem.Struct.Bond.prototype.hasRxnProps = function ()
{
	return !!this.reactingCenterStatus;
};

chem.Struct.Bond.prototype.getCenter = function (struct)
{
	var p1 = struct.atoms.get(this.begin).pp;
	var p2 = struct.atoms.get(this.end).pp;
	return util.Vec2.lc2(p1, 0.5, p2, 0.5);
}

chem.Struct.Bond.prototype.getDir = function (struct)
{
	var p1 = struct.atoms.get(this.begin).pp;
	var p2 = struct.atoms.get(this.end).pp;
	return p2.sub(p1).normalized();
}

chem.Struct.Bond.prototype.clone = function (aidMap)
{
	var cp = new chem.Struct.Bond(this);
	if(aidMap)
	{
		cp.begin = aidMap[cp.begin];
		cp.end = aidMap[cp.end];
	}
	return cp;
};

chem.Struct.Bond.prototype.findOtherEnd = function (i)
{
	if(i == this.begin)
		return this.end;
	if(i == this.end)
		return this.begin;
	throw new Error("Bond end not found");
};

chem.HalfBond = function ( /*num*/ begin, /*num*/ end, /*num*/ bid)
{
	if(arguments.length != 3)
		throw new Error("Invalid parameter number!");

	this.begin = begin - 0;
	this.end = end - 0;
	this.bid = bid - 0;

	// rendering properties
	this.dir = new util.Vec2(); // direction
	this.norm = new util.Vec2(); // left normal
	this.ang = 0; // angle to (1,0), used for sorting the bonds
	this.p = new util.Vec2(); // corrected origin position
	this.loop = -1; // left loop id if the half-bond is in a loop, otherwise -1
	this.contra = -1; // the half bond contrary to this one
	this.next = -1; // the half-bond next ot this one in CCW order
	this.leftSin = 0;
	this.leftCos = 0;
	this.leftNeighbor = 0;
	this.rightSin = 0;
	this.rightCos = 0;
	this.rightNeighbor = 0;
};

chem.Struct.prototype.initNeighbors = function ()
{
	this.atoms.each(function (aid, atom)
	{
		atom.neighbors = [];
	});
	this.bonds.each(function (bid, bond)
	{
		var a1 = this.atoms.get(bond.begin);
		var a2 = this.atoms.get(bond.end);
		a1.neighbors.push(bond.hb1);
		a2.neighbors.push(bond.hb2);
	}, this);
};

chem.Struct.prototype.bondInitHalfBonds = function (bid, /*opt*/ bond)
{
	bond = bond || this.bonds.get(bid);
	bond.hb1 = 2 * bid;
	bond.hb2 = 2 * bid + 1;
	this.halfBonds.set(bond.hb1, new chem.HalfBond(bond.begin, bond.end, bid));
	this.halfBonds.set(bond.hb2, new chem.HalfBond(bond.end, bond.begin, bid));
	var hb1 = this.halfBonds.get(bond.hb1);
	var hb2 = this.halfBonds.get(bond.hb2);
	hb1.contra = bond.hb2;
	hb2.contra = bond.hb1;
};

chem.Struct.prototype.halfBondUpdate = function (hbid)
{
	var hb = this.halfBonds.get(hbid);
	var p1 = this.atoms.get(hb.begin).pp;
	var p2 = this.atoms.get(hb.end).pp;
	var d = util.Vec2.diff(p2, p1).normalized();
	hb.dir = util.Vec2.dist(p2, p1) > 1e-4 ? d : new util.Vec2(1, 0);
	hb.norm = hb.dir.turnLeft();
	hb.ang = hb.dir.oxAngle();
	if(hb.loop < 0)
		hb.loop = -1;
};

chem.Struct.prototype.initHalfBonds = function ()
{
	this.halfBonds.clear();
	this.bonds.each(this.bondInitHalfBonds, this);
};

chem.Struct.prototype.setHbNext = function (hbid, next)
{
	this.halfBonds.get(this.halfBonds.get(hbid).contra).next = next;
};

chem.Struct.prototype.halfBondSetAngle = function (hbid, left)
{
	var hb = this.halfBonds.get(hbid);
	var hbl = this.halfBonds.get(left);
	hbl.rightCos = hb.leftCos = util.Vec2.dot(hbl.dir, hb.dir);
	hbl.rightSin = hb.leftSin = util.Vec2.cross(hbl.dir, hb.dir);
	hb.leftNeighbor = left;
	hbl.rightNeighbor = hbid;
};

chem.Struct.prototype.atomAddNeighbor = function (hbid)
{
	var hb = this.halfBonds.get(hbid);
	var atom = this.atoms.get(hb.begin);
	var i = 0;
	for(i = 0; i < atom.neighbors.length; ++i)
		if(this.halfBonds.get(atom.neighbors[i]).ang > hb.ang)
			break;
	atom.neighbors.splice(i, 0, hbid);
	var ir = atom.neighbors[(i + 1) % atom.neighbors.length];
	var il = atom.neighbors[(i + atom.neighbors.length - 1) % atom.neighbors.length];
	this.setHbNext(il, hbid);
	this.setHbNext(hbid, ir);
	this.halfBondSetAngle(hbid, il);
	this.halfBondSetAngle(ir, hbid);
};

chem.Struct.prototype.atomSortNeighbors = function (aid)
{
	var atom = this.atoms.get(aid);
	var self = this;
	atom.neighbors = atom.neighbors.sort(function (nei1, nei2)
	{
		return self.halfBonds.get(nei1).ang - self.halfBonds.get(nei2).ang;
	}, this);

	var i;
	for(i = 0; i < atom.neighbors.length; ++i)
		this.halfBonds.get(this.halfBonds.get(atom.neighbors[i]).contra).next =
		atom.neighbors[(i + 1) % atom.neighbors.length];
	for(i = 0; i < atom.neighbors.length; ++i)
		this.halfBondSetAngle(atom.neighbors[(i + 1) % atom.neighbors.length],
			atom.neighbors[i]);
};

chem.Struct.prototype.sortNeighbors = function (list)
{
	util.each(list, function (aid)
	{
		this.atomSortNeighbors(aid);
	}, this);
};

chem.Struct.prototype.atomUpdateHalfBonds = function (aid)
{
	var nei = this.atoms.get(aid).neighbors;
	for(var i = 0; i < nei.length; ++i)
	{
		var hbid = nei[i];
		this.halfBondUpdate(hbid);
		this.halfBondUpdate(this.halfBonds.get(hbid).contra);
	}
};

chem.Struct.prototype.updateHalfBonds = function (list)
{
	util.each(list, function (aid)
	{
		this.atomUpdateHalfBonds(aid);
	}, this);
};

chem.Struct.prototype.sGroupsRecalcCrossBonds = function ()
{
	this.sgroups.each(function (sgid, sg)
	{
		sg.xBonds = [];
		sg.neiAtoms = [];
	}, this);
	this.bonds.each(function (bid, bond)
	{
		var a1 = this.atoms.get(bond.begin);
		var a2 = this.atoms.get(bond.end);
		util.Set.each(a1.sgs, function (sgid)
		{
			if(!util.Set.contains(a2.sgs, sgid))
			{
				var sg = this.sgroups.get(sgid);
				sg.xBonds.push(bid);
				util.arrayAddIfMissing(sg.neiAtoms, bond.end);
			}
		}, this);
		util.Set.each(a2.sgs, function (sgid)
		{
			if(!util.Set.contains(a1.sgs, sgid))
			{
				var sg = this.sgroups.get(sgid);
				sg.xBonds.push(bid);
				util.arrayAddIfMissing(sg.neiAtoms, bond.begin);
			}
		}, this);
	}, this);
};

chem.Struct.prototype.sGroupDelete = function (sgid)
{
	var sg = this.sgroups.get(sgid);
	for(var i = 0; i < sg.atoms.length; ++i)
	{
		util.Set.remove(this.atoms.get(sg.atoms[i]).sgs, sgid);
	}
	this.sGroupForest.remove(sgid);
	this.sgroups.remove(sgid);
};

chem.Struct.itemSetPos = function (item, pp) // TODO: remove
	{
		item.pp = pp;
	};

chem.Struct.prototype._itemSetPos = function (map, id, pp, scaleFactor)
{
	chem.Struct.itemSetPos(this[map].get(id), pp, scaleFactor);
};

chem.Struct.prototype._atomSetPos = function (id, pp, scaleFactor)
{
	this._itemSetPos('atoms', id, pp, scaleFactor);
};

chem.Struct.prototype._rxnPlusSetPos = function (id, pp, scaleFactor)
{
	this._itemSetPos('rxnPluses', id, pp, scaleFactor);
};

chem.Struct.prototype._rxnArrowSetPos = function (id, pp, scaleFactor)
{
	this._itemSetPos('rxnArrows', id, pp, scaleFactor);
};

chem.Struct.prototype.getCoordBoundingBox = function (atomSet)
{
	var bb = null;
	var extend = function (pp)
	{
		if(!bb)
			bb = {
				min: pp,
				max: pp
			};
		else
		{
			bb.min = util.Vec2.min(bb.min, pp);
			bb.max = util.Vec2.max(bb.max, pp);
		}
	};

	var global = typeof (atomSet) == 'undefined';

	this.atoms.each(function (aid, atom)
	{
		if(global || util.Set.contains(atomSet, aid))
			extend(atom.pp);
	});
	if(global)
	{
		this.rxnPluses.each(function (id, item)
		{
			extend(item.pp);
		});
		this.rxnArrows.each(function (id, item)
		{
			extend(item.pp);
		});
	}
	if(!bb && global)
		bb = {
			min: new util.Vec2(0, 0),
			max: new util.Vec2(1, 1)
		};
	return bb;
};

chem.Struct.prototype.getCoordBoundingBoxObj = function ()
{
	var bb = null;
	var extend = function (pp)
	{
		if(!bb)
			bb = {
				min: new util.Vec2(pp),
				max: new util.Vec2(pp)
			};
		else
		{
			bb.min = util.Vec2.min(bb.min, pp);
			bb.max = util.Vec2.max(bb.max, pp);
		}
	};

	this.atoms.each(function (aid, atom)
	{
		extend(atom.pp);
	});
	return bb;
};

chem.Struct.prototype.getBondLengthData = function ()
{
	var totalLength = 0;
	var cnt = 0;
	this.bonds.each(function (bid, bond)
	{
		totalLength += util.Vec2.dist(
			this.atoms.get(bond.begin).pp,
			this.atoms.get(bond.end).pp);
		cnt++;
	}, this);
	return {
		cnt: cnt,
		totalLength: totalLength
	};
};

chem.Struct.prototype.getAvgBondLength = function ()
{
	var bld = this.getBondLengthData();
	return bld.cnt > 0 ? bld.totalLength / bld.cnt : -1;
};

chem.Struct.prototype.getAvgClosestAtomDistance = function ()
{
	var totalDist = 0,
		minDist, dist = 0;
	var keys = this.atoms.keys(),
		k, j;
	for(k = 0; k < keys.length; ++k)
	{
		minDist = -1;
		for(j = 0; j < keys.length; ++j)
		{
			if(j == k)
				continue;
			dist = util.Vec2.dist(this.atoms.get(keys[j]).pp, this.atoms.get(keys[k]).pp);
			if(minDist < 0 || minDist > dist)
				minDist = dist;
		}
		totalDist += minDist;
	}

	return keys.length > 0 ? totalDist / keys.length : -1;
};

chem.Struct.prototype.checkBondExists = function (begin, end)
{
	var bondExists = false;
	this.bonds.each(function (bid, bond)
	{
		if((bond.begin == begin && bond.end == end) ||
			(bond.end == begin && bond.begin == end))
			bondExists = true;
	}, this);
	return bondExists;
};

chem.Loop = function ( /*Array of num*/ hbs, /*Struct*/ struct, /*bool*/ convex)
{
	this.hbs = hbs; // set of half-bonds involved
	this.dblBonds = 0; // number of double bonds in the loop
	this.aromatic = true;
	this.convex = convex || false;

	util.each(hbs, function (hb)
	{
		var bond = struct.bonds.get(struct.halfBonds.get(hb).bid);
		if(bond.type != chem.Struct.BOND.TYPE.AROMATIC)
			this.aromatic = false;
		if(bond.type == chem.Struct.BOND.TYPE.DOUBLE)
			this.dblBonds++;
	}, this);
};

chem.Struct.RxnPlus = function (params)
{
	params = params ||
	{};
	this.pp = params.pp ? new util.Vec2(params.pp) : new util.Vec2();
};

chem.Struct.RxnPlus.prototype.clone = function ()
{
	return new chem.Struct.RxnPlus(this);
};

chem.Struct.RxnArrow = function (params)
{
	params = params ||
	{};
	this.pp = params.pp ? new util.Vec2(params.pp) : new util.Vec2();
};

chem.Struct.RxnArrow.prototype.clone = function ()
{
	return new chem.Struct.RxnArrow(this);
};

chem.Struct.prototype.findConnectedComponent = function (aid)
{
	var map = {};
	var list = [aid];
	var ids = util.Set.empty();
	while(list.length > 0)
	{
		(function ()
		{
			var aid = list.pop();
			map[aid] = 1;
			util.Set.add(ids, aid);
			var atom = this.atoms.get(aid);
			for(var i = 0; i < atom.neighbors.length; ++i)
			{
				var neiId = this.halfBonds.get(atom.neighbors[i]).end;
				if(!util.Set.contains(ids, neiId))
					list.push(neiId);
			}
		}).apply(this);
	}
	return ids;
};

chem.Struct.prototype.findConnectedComponents = function (discardExistingFragments)
{
	// NB: this is a hack
	// TODO: need to maintain half-bond and neighbor structure permanently
	if(!this.halfBonds.count())
	{
		this.initHalfBonds();
		this.initNeighbors();
		this.updateHalfBonds(this.atoms.keys());
		this.sortNeighbors(this.atoms.keys());
	}

	var map = {};
	this.atoms.each(function (aid, atom)
	{
		map[aid] = -1;
	}, this);
	var components = [];
	this.atoms.each(function (aid, atom)
	{
		if((discardExistingFragments || atom.fragment < 0) && map[aid] < 0)
		{
			var component = this.findConnectedComponent(aid);
			components.push(component);
			util.Set.each(component, function (aid)
			{
				map[aid] = 1;
			}, this);
		}
	}, this);
	return components;
};

chem.Struct.prototype.markFragment = function (ids)
{
	var fid = this.frags.add(new chem.Struct.Fragment());
	util.Set.each(ids, function (aid)
	{
		this.atoms.get(aid).fragment = fid;
	}, this);
};

chem.Struct.prototype.markFragmentByAtomId = function (aid)
{
	this.markFragment(this.findConnectedComponent(aid));
};

chem.Struct.prototype.markFragments = function ()
{
	var components = this.findConnectedComponents();
	for(var i = 0; i < components.length; ++i)
	{
		this.markFragment(components[i]);
	}
};

chem.Struct.Fragment = function () {};
chem.Struct.Fragment.prototype.clone = function ()
{
	return new chem.Struct.Fragment();
};

chem.Struct.Fragment.getAtoms = function (struct, frid)
{
	var atoms = [];
	struct.atoms.each(function (aid, atom)
	{
		if(atom.fragment == frid)
			atoms.push(aid);
	}, this);
	return atoms;
}

chem.Struct.RGroup = function (logic)
{
	logic = logic ||
	{};
	this.frags = new util.Pool();
	this.resth = logic.resth || false;
	this.range = logic.range || '';
	this.ifthen = logic.ifthen || 0;
};

chem.Struct.RGroup.prototype.getAttrs = function ()
{
	return {
		resth: this.resth,
		range: this.range,
		ifthen: this.ifthen
	};
};

chem.Struct.RGroup.findRGroupByFragment = function (rgroups, frid)
{
	var ret;
	rgroups.each(function (rgid, rgroup)
	{
		if(!util.isUndefined(rgroup.frags.keyOf(frid))) ret = rgid;
	});
	return ret;
};
chem.Struct.RGroup.prototype.clone = function (fidMap)
{
	var ret = new chem.Struct.RGroup(this);
	this.frags.each(function (fnum, fid)
	{
		ret.frags.add(fidMap ? fidMap[fid] : fid);
	});
	return ret;
};

chem.Struct.prototype.scale = function (scale)
{
	if(scale != 1)
	{
		this.atoms.each(function (aid, atom)
		{
			atom.pp = atom.pp.scaled(scale);
		}, this);
		this.rxnPluses.each(function (id, item)
		{
			item.pp = item.pp.scaled(scale);
		}, this);
		this.rxnArrows.each(function (id, item)
		{
			item.pp = item.pp.scaled(scale);
		}, this);
		this.sgroups.each(function (id, item)
		{
			item.pp = item.pp ? item.pp.scaled(scale) : null;
		}, this);
	}
};

chem.Struct.prototype.rescale = function ()
{
	var avg = this.getAvgBondLength();
	if(avg < 0 && !this.isReaction) // TODO [MK] this doesn't work well for reactions as the distances between
	// the atoms in different components are generally larger than those between atoms of a single component
	// (KETCHER-341)
		avg = this.getAvgClosestAtomDistance();
	if(avg < 1e-3)
		avg = 1;
	var scale = 1 / avg;
	this.scale(scale);
};

chem.Struct.prototype.loopHasSelfIntersections = function (hbs)
{
	for(var i = 0; i < hbs.length; ++i)
	{
		var hbi = this.halfBonds.get(hbs[i]);
		var ai = this.atoms.get(hbi.begin).pp;
		var bi = this.atoms.get(hbi.end).pp;
		var set = util.Set.fromList([hbi.begin, hbi.end]);
		for(var j = i + 2; j < hbs.length; ++j)
		{
			var hbj = this.halfBonds.get(hbs[j]);
			if(util.Set.contains(set, hbj.begin) || util.Set.contains(set, hbj.end))
				continue; // skip edges sharing an atom
			var aj = this.atoms.get(hbj.begin).pp;
			var bj = this.atoms.get(hbj.end).pp;
			if(util.Vec2.segmentIntersection(ai, bi, aj, bj))
			{
				return true;
			}
		}
	}
	return false;
}

// partition a cycle into simple cycles
// TODO: [MK] rewrite the detection algorithm to only find simple ones right away?
chem.Struct.prototype.partitionLoop = function (loop)
{
	var subloops = [];
	var continueFlag = true;
	search: while(continueFlag)
	{
		var atomToHalfBond = {}; // map from every atom in the loop to the index of the first half-bond starting from that atom in the uniqHb array
		for(var l = 0; l < loop.length; ++l)
		{
			var hbid = loop[l];
			var aid1 = this.halfBonds.get(hbid).begin;
			var aid2 = this.halfBonds.get(hbid).end;
			if(aid2 in atomToHalfBond)
			{ // subloop found
				var s = atomToHalfBond[aid2]; // where the subloop begins
				var subloop = loop.slice(s, l + 1);
				subloops.push(subloop);
				if(l < loop.length) // remove half-bonds corresponding to the subloop
					loop.splice(s, l - s + 1);
				continue search;
			}
			atomToHalfBond[aid1] = l;
		}
		continueFlag = false; // we're done, no more subloops found
		subloops.push(loop);
	}
	return subloops;
}

chem.Struct.prototype.halfBondAngle = function (hbid1, hbid2)
{
	var hba = this.halfBonds.get(hbid1);
	var hbb = this.halfBonds.get(hbid2);
	return Math.atan2(
		util.Vec2.cross(hba.dir, hbb.dir),
		util.Vec2.dot(hba.dir, hbb.dir));
}

chem.Struct.prototype.loopIsConvex = function (loop)
{
	for(var k = 0; k < loop.length; ++k)
	{
		var angle = this.halfBondAngle(loop[k], loop[(k + 1) % loop.length]);
		if(angle > 0)
			return false;
	}
	return true;
}

// check whether a loop is on the inner or outer side of the polygon
//  by measuring the total angle between bonds
chem.Struct.prototype.loopIsInner = function (loop)
{
	var totalAngle = 2 * Math.PI;
	for(var k = 0; k < loop.length; ++k)
	{
		var hbida = loop[k];
		var hbidb = loop[(k + 1) % loop.length];
		var hbb = this.halfBonds.get(hbidb);
		var angle = this.halfBondAngle(hbida, hbidb);
		if(hbb.contra == loop[k]) // back and forth along the same edge
			totalAngle += Math.PI;
		else
			totalAngle += angle;
	}
	return Math.abs(totalAngle) < Math.PI;
}

chem.Struct.prototype.findLoops = function ()
{
	var newLoops = [];
	var bondsToMark = util.Set.empty();

	// Starting from each half-bond not known to be in a loop yet,
	//  follow the 'next' links until the initial half-bond is reached or
	//  the length of the sequence exceeds the number of half-bonds available.
	// In a planar graph, as long as every bond is a part of some "loop" -
	//  either an outer or an inner one - every iteration either yields a loop
	//  or doesn't start at all. Thus this has linear complexity in the number
	//  of bonds for planar graphs.
	var j, k, c, loop, loopId;
	this.halfBonds.each(function (i, hb)
	{
		if(hb.loop == -1)
		{
			for(j = i, c = 0, loop = []; c <= this.halfBonds.count(); j = this.halfBonds.get(j).next, ++c)
			{
				if(c > 0 && j == i)
				{ // loop found
					var subloops = this.partitionLoop(loop);
					util.each(subloops, function (loop)
					{
						if(this.loopIsInner(loop) && !this.loopHasSelfIntersections(loop))
						{ // loop is internal
							// use lowest half-bond id in the loop as the loop id
							// this ensures that the loop gets the same id if it is discarded and then recreated,
							// which in turn is required to enable redrawing while dragging, as actions store item id's
							loopId = util.arrayMin(loop);
							this.loops.set(loopId, new chem.Loop(loop, this, this.loopIsConvex(loop)));
						}
						else
						{
							loopId = -2;
						}
						util.each(loop, function (hbid)
						{
							this.halfBonds.get(hbid).loop = loopId;
							util.Set.add(bondsToMark, this.halfBonds.get(hbid).bid);
						}, this);
						if(loopId >= 0)
						{
							newLoops.push(loopId);
						}
					}, this);
					break;
				}
				else
				{
					loop.push(j);
				}
			}
		}
	}, this);
	return {
		newLoops: newLoops,
		bondsToMark: util.Set.list(bondsToMark)
	};
};

// NB: this updates the structure without modifying the corresponding ReStruct.
//  To be applied to standalone structures only.
chem.Struct.prototype.prepareLoopStructure = function ()
{
	this.initHalfBonds();
	this.initNeighbors();
	this.updateHalfBonds(this.atoms.keys());
	this.sortNeighbors(this.atoms.keys());
	this.findLoops();
}

chem.Struct.prototype.atomAddToSGroup = function (sgid, aid)
{
	// TODO: [MK] make sure the addition does not break the hierarchy?
	chem.SGroup.addAtom(this.sgroups.get(sgid), aid);
	util.Set.add(this.atoms.get(aid).sgs, sgid);
}
/****************************************************************************
 * Copyright (C) 2009-2010 GGA Software Services LLC
 *
 * This file may be distributed and/or modified under the terms of the
 * GNU Affero General Public License version 3 as published by the Free
 * Software Foundation and appearing in the file LICENSE.GPL included in
 * the packaging of this file.
 *
 * This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
 * WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ***************************************************************************/

if(!window.chem || !util.Vec2 || !chem.Struct)
	throw new Error("Vec2 and Molecule should be defined first");

if(typeof (String.prototype.trim) === "undefined")
{
	String.prototype.trim = function ()
	{
		return String(this).replace(/^\s+|\s+$/g, '');
	};
}

isUndefined = function (obj)
{
	return util.isUndefined(obj);
}

chem.Molfile = function () {};

chem.Molfile.loadRGroupFragments = true; // TODO: set to load the fragments

chem.Molfile.parseDecimalInt = function (str)
{
	var val = parseInt(str, 10);

	return isNaN(val) ? 0 : val;
};

chem.Molfile.partitionLine = function ( /*string*/ str, /*array of int*/ parts, /*bool*/ withspace)
{
	var res = [];
	for(var i = 0, shift = 0; i < parts.length; ++i)
	{
		res.push(str.slice(shift, shift + parts[i]));
		if(withspace)
			shift++;
		shift += parts[i];
	}
	return res;
};

chem.Molfile.partitionLineFixed = function ( /*string*/ str, /*int*/ itemLength, /*bool*/ withspace)
{
	var res = [];
	for(var shift = 0; shift < str.length; shift += itemLength)
	{
		res.push(str.slice(shift, shift + itemLength));
		if(withspace)
			shift++;
	}
	return res;
};

chem.Molfile.parseCTFile = function (molfileLines)
{
	var ret = null;
	if(molfileLines[0].search("\\$RXN") == 0)
		ret = chem.Molfile.parseRxn(molfileLines);
	else
		ret = chem.Molfile.parseMol(molfileLines);
	ret.initHalfBonds();
	ret.initNeighbors();
	ret.markFragments();
	return ret;
};

chem.Molfile.fmtInfo = {
	bondTypeMap:
	{
		1: chem.Struct.BOND.TYPE.SINGLE,
		2: chem.Struct.BOND.TYPE.DOUBLE,
		3: chem.Struct.BOND.TYPE.TRIPLE,
		4: chem.Struct.BOND.TYPE.AROMATIC,
		5: chem.Struct.BOND.TYPE.SINGLE_OR_DOUBLE,
		6: chem.Struct.BOND.TYPE.SINGLE_OR_AROMATIC,
		7: chem.Struct.BOND.TYPE.DOUBLE_OR_AROMATIC,
		8: chem.Struct.BOND.TYPE.ANY
	},
	bondStereoMap:
	{
		0: chem.Struct.BOND.STEREO.NONE,
		1: chem.Struct.BOND.STEREO.UP,
		4: chem.Struct.BOND.STEREO.EITHER,
		6: chem.Struct.BOND.STEREO.DOWN,
		3: chem.Struct.BOND.STEREO.CIS_TRANS
	},
	v30bondStereoMap:
	{
		0: chem.Struct.BOND.STEREO.NONE,
		1: chem.Struct.BOND.STEREO.UP,
		2: chem.Struct.BOND.STEREO.EITHER,
		3: chem.Struct.BOND.STEREO.DOWN
	},
	bondTopologyMap:
	{
		0: chem.Struct.BOND.TOPOLOGY.EITHER,
		1: chem.Struct.BOND.TOPOLOGY.RING,
		2: chem.Struct.BOND.TOPOLOGY.CHAIN
	},
	countsLinePartition: [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6],
	atomLinePartition: [10, 10, 10, 1, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
	bondLinePartition: [3, 3, 3, 3, 3, 3, 3],
	atomListHeaderPartition: [3, 1, 1, 4, 1, 1],
	atomListHeaderLength: 11, // = atomListHeaderPartition.reduce(function(a,b) { return a + b; }, 0)
	atomListHeaderItemLength: 4,
	chargeMap: [0, +3, +2, +1, 0, -1, -2, -3],
	valenceMap: [undefined, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 0],
	implicitHydrogenMap: [undefined, 0, 1, 2, 3, 4],
	v30atomPropMap:
	{
		'CHG': 'charge',
		'RAD': 'radical',
		'MASS': 'isotope',
		'VAL': 'explicitValence',
		'HCOUNT': 'hCount',
		'INVRET': 'invRet',
		'SUBST': 'substitutionCount',
		'UNSAT': 'unsaturatedAtom',
		'RBCNT': 'ringBondCount'
	},
	rxnItemsPartition: [3, 3, 3]
};

chem.Molfile.parseAtomLine = function (atomLine)
{
	var mf = chem.Molfile;
	var atomSplit = mf.partitionLine(atomLine, mf.fmtInfo.atomLinePartition);
	var params = {
		// generic
		pp: new util.Vec2(parseFloat(atomSplit[0]), -parseFloat(atomSplit[1])),
		label: atomSplit[4].trim(),
		explicitValence: mf.fmtInfo.valenceMap[mf.parseDecimalInt(atomSplit[10])],

		// obsolete
		massDifference: mf.parseDecimalInt(atomSplit[5]),
		charge: mf.fmtInfo.chargeMap[mf.parseDecimalInt(atomSplit[6])],

		// query
		hCount: mf.parseDecimalInt(mf.parseDecimalInt(atomSplit[8])),
		stereoCare: mf.parseDecimalInt(atomSplit[9]) != 0,

		// reaction
		aam: mf.parseDecimalInt(atomSplit[14]),
		invRet: mf.parseDecimalInt(atomSplit[15]),

		// reaction query
		exactChangeFlag: mf.parseDecimalInt(atomSplit[16]) != 0
	};
	return new chem.Struct.Atom(params);
};

chem.Molfile.stripV30 = function (line)
{
	if(line.slice(0, 7) != 'M  V30 ')
		throw Error("Prefix invalid");
	return line.slice(7);
};

chem.Molfile.parseAtomLineV3000 = function (line)
{
	var mf = chem.Molfile;
	var split, subsplit, key, value, i;
	split = mf.spaceparsplit(line);
	var params = {
		pp: new util.Vec2(parseFloat(split[2]), -parseFloat(split[3])),
		aam: split[5].trim()
	};
	var label = split[1].trim();
	if(label.charAt(0) == "\"" && label.charAt(label.length - 1) == "\"")
	{
		label = label.substr(1, label.length - 2); // strip qutation marks
	}
	if(label.charAt(label.length - 1) == "]")
	{ // assume atom list
		label = label.substr(0, label.length - 1); // remove ']'
		var atomListParams = {};
		atomListParams.notList = false;
		if(label.substr(0, 5) == "NOT [")
		{
			atomListParams.notList = true;
			label = label.substr(5); // remove 'NOT ['
		}
		else if(label.charAt(0) != "[")
		{
			throw new Error("Error: atom list expected, found \'" + label + "\'");
		}
		else
		{
			label = label.substr(1); // remove '['
		}
		atomListParams.ids = mf.labelsListToIds(label.split(","));
		params['atomList'] = new chem.Struct.AtomList(atomListParams);
		params['label'] = 'L#';
	}
	else
	{
		params['label'] = label;
	}
	split.splice(0, 6);
	for(i = 0; i < split.length; ++i)
	{
		subsplit = mf.splitonce(split[i], '=');
		key = subsplit[0];
		value = subsplit[1];
		if(key in mf.fmtInfo.v30atomPropMap)
		{
			var ival = mf.parseDecimalInt(value);
			if(key == 'VAL')
			{
				if(ival == 0)
					continue;
				if(ival == -1)
					ival = 0;
			}
			params[mf.fmtInfo.v30atomPropMap[key]] = ival;
		}
		else if(key == 'RGROUPS')
		{
			value = value.trim().substr(1, value.length - 2);
			var rgrsplit = value.split(' ').slice(1);
			params.rglabel = 0;
			for(var j = 0; j < rgrsplit.length; ++j)
			{
				params.rglabel |= 1 << (rgrsplit[j] - 1);
			}
		}
		else if(key == 'ATTCHPT')
		{
			params.attpnt = value.trim() - 0;
		}
	}
	return new chem.Struct.Atom(params);
};

chem.Molfile.parseBondLineV3000 = function (line)
{
	var mf = chem.Molfile;
	var split, subsplit, key, value, i;
	split = mf.spaceparsplit(line);
	var params = {
		begin: mf.parseDecimalInt(split[2]) - 1,
		end: mf.parseDecimalInt(split[3]) - 1,
		type: mf.fmtInfo.bondTypeMap[mf.parseDecimalInt(split[1])]
	};
	split.splice(0, 4);
	for(i = 0; i < split.length; ++i)
	{
		subsplit = mf.splitonce(split[i], '=');
		key = subsplit[0];
		value = subsplit[1];
		if(key == 'CFG')
		{
			params.stereo = mf.fmtInfo.v30bondStereoMap[mf.parseDecimalInt(value)];
			if(params.type == chem.Struct.BOND.TYPE.DOUBLE && params.stereo == chem.Struct.BOND.STEREO.EITHER)
				params.stereo = chem.Struct.BOND.STEREO.CIS_TRANS;
		}
		else if(key == 'TOPO')
		{
			params.topology = mf.fmtInfo.bondTopologyMap[mf.parseDecimalInt(value)];
		}
		else if(key == 'RXCTR')
		{
			params.reactingCenterStatus = mf.parseDecimalInt(value);
		}
		else if(key == 'STBOX')
		{
			params.stereoCare = mf.parseDecimalInt(value);
		}
	}
	return new chem.Struct.Bond(params);
};

chem.Molfile.parseBondLine = function (bondLine)
{
	var mf = chem.Molfile;
	var bondSplit = mf.partitionLine(bondLine, mf.fmtInfo.bondLinePartition);
	var params = {
		begin: mf.parseDecimalInt(bondSplit[0]) - 1,
		end: mf.parseDecimalInt(bondSplit[1]) - 1,
		type: mf.fmtInfo.bondTypeMap[mf.parseDecimalInt(bondSplit[2])],
		stereo: mf.fmtInfo.bondStereoMap[mf.parseDecimalInt(bondSplit[3])],
		topology: mf.fmtInfo.bondTopologyMap[mf.parseDecimalInt(bondSplit[5])],
		reactingCenterStatus: mf.parseDecimalInt(bondSplit[6])
	};

	return new chem.Struct.Bond(params);
};

chem.Molfile.parseAtomListLine = function ( /* string */ atomListLine)
{
	var mf = chem.Molfile;
	var split = mf.partitionLine(atomListLine, mf.fmtInfo.atomListHeaderPartition);

	var number = mf.parseDecimalInt(split[0]) - 1;
	var notList = (split[2].trim() == "T");
	var count = mf.parseDecimalInt(split[4].trim());

	var ids = atomListLine.slice(mf.fmtInfo.atomListHeaderLength);
	var list = [];
	var itemLength = mf.fmtInfo.atomListHeaderItemLength;
	for(var i = 0; i < count; ++i)
		list[i] = mf.parseDecimalInt(ids.slice(i * itemLength, (i + 1) * itemLength - 1));

	return {
		"aid": number,
		"atomList": new chem.Struct.AtomList(
		{
			"notList": notList,
			"ids": list
		})
	};
};

chem.Molfile.readKeyValuePairs = function (str, /* bool */ valueString)
{
	var mf = chem.Molfile;
	var ret = {};
	var partition = mf.partitionLineFixed(str, 3, true);
	var count = mf.parseDecimalInt(partition[0]);
	for(var i = 0; i < count; ++i)
		ret[mf.parseDecimalInt(partition[2 * i + 1]) - 1] =
		valueString ? partition[2 * i + 2].trim() :
		mf.parseDecimalInt(partition[2 * i + 2]);
	return ret;
};

chem.Molfile.readKeyMultiValuePairs = function (str, /* bool */ valueString)
{
	var mf = chem.Molfile;
	var ret = [];
	var partition = mf.partitionLineFixed(str, 3, true);
	var count = mf.parseDecimalInt(partition[0]);
	for(var i = 0; i < count; ++i)
		ret.push([
            mf.parseDecimalInt(partition[2 * i + 1]) - 1,
            valueString ? partition[2 * i + 2].trim() : mf.parseDecimalInt(partition[2 * i + 2])
        ]);
	return ret;
};

chem.Molfile.labelsListToIds = function (labels)
{
	var ids = [];
	for(var i = 0; i < labels.length; ++i)
	{
		ids.push(chem.Element.getElementByLabel(labels[i].trim()));
	}
	return ids;
};

chem.Molfile.parsePropertyLineAtomList = function (hdr, lst)
{
	var mf = chem.Molfile;
	var aid = mf.parseDecimalInt(hdr[1]) - 1;
	var count = mf.parseDecimalInt(hdr[2]);
	var notList = hdr[4].trim() == 'T';
	var ids = mf.labelsListToIds(lst.slice(0, count));
	var ret = {};
	ret[aid] = new chem.Struct.AtomList(
	{
		"notList": notList,
		"ids": ids
	});
	return ret;
};

chem.Molfile.initSGroup = function (sGroups, propData)
{
	var mf = chem.Molfile;
	var kv = mf.readKeyValuePairs(propData, true);
	for(var key in kv)
	{
		var type = kv[key];
		if(!(type in chem.SGroup.TYPES))
			throw new Error('Unsupported S-group type');
		var sg = new chem.SGroup(type);
		sg.number = key;
		sGroups[key] = sg;
	}
};

chem.Molfile.applySGroupProp = function (sGroups, propName, propData, numeric, core)
{
	var mf = chem.Molfile;
	var kv = mf.readKeyValuePairs(propData, !(numeric));
	for(var key in kv)
	{
		// "core" properties are stored directly in an sgroup, not in sgroup.data
		(core ? sGroups[key] : sGroups[key].data)[propName] = kv[key];
	}
};

chem.Molfile.toIntArray = function (strArray)
{
	var mf = chem.Molfile;
	var ret = [];
	for(var j = 0; j < strArray.length; ++j)
		ret[j] = mf.parseDecimalInt(strArray[j]);
	return ret;
};

chem.Molfile.applySGroupArrayProp = function (sGroups, propName, propData, shift)
{
	var mf = chem.Molfile;
	var sid = mf.parseDecimalInt(propData.slice(1, 4)) - 1;
	var num = mf.parseDecimalInt(propData.slice(4, 8));
	var part = mf.toIntArray(mf.partitionLineFixed(propData.slice(8), 3, true));

	if(part.length != num)
		throw new Error('File format invalid');
	if(shift)
	{
		util.apply(part, function (v)
		{
			return v + shift;
		});
	}
	sGroups[sid][propName] = sGroups[sid][propName].concat(part);
};

chem.Molfile.applyDataSGroupName = function (sg, name)
{
	sg.data.fieldName = name;
};

chem.Molfile.applyDataSGroupQuery = function (sg, query)
{
	sg.data.query = query;
};

chem.Molfile.applyDataSGroupQueryOp = function (sg, queryOp)
{
	sg.data.queryOp = queryOp;
};

chem.Molfile.applyDataSGroupDesc = function (sGroups, propData)
{
	var mf = chem.Molfile;
	var split = mf.partitionLine(propData, [4, 31, 2, 20, 2, 3], false);
	var id = mf.parseDecimalInt(split[0]) - 1;
	var fieldName = split[1].trim();
	var fieldType = split[2].trim();
	var units = split[3].trim();
	var query = split[4].trim();
	var queryOp = split[5].trim();
	var sGroup = sGroups[id];
	sGroup.data.fieldType = fieldType;
	sGroup.data.fieldName = fieldName;
	sGroup.data.units = units;
	sGroup.data.query = query;
	sGroup.data.queryOp = queryOp;
};

chem.Molfile.applyDataSGroupInfo = function (sg, propData)
{
	var mf = chem.Molfile;
	var split = mf.partitionLine(propData, [10 /*x.x*/ , 10 /*y.y*/ , 4 /* eee*/ , 1 /*f*/ , 1 /*g*/ , 1 /*h*/ , 3 /* i */ , 3 /*jjj*/ , 3 /*kkk*/ , 3 /*ll*/ , 2 /*m*/ , 3 /*n*/ , 2 /*oo*/ ], false);

	var x = parseFloat(split[0]);
	var y = parseFloat(split[1]);
	var attached = split[3].trim() == 'A';
	var absolute = split[4].trim() == 'A';
	var showUnits = split[5].trim() == 'U';
	var nCharsToDisplay = split[7].trim();
	nCharsToDisplay = nCharsToDisplay == 'ALL' ? -1 : mf.parseDecimalInt(nCharsToDisplay);
	var tagChar = split[10].trim();
	var daspPos = mf.parseDecimalInt(split[11].trim());

	sg.pp = new util.Vec2(x, -y);
	sg.data.attached = attached;
	sg.data.absolute = absolute;
	sg.data.showUnits = showUnits;
	sg.data.nCharsToDisplay = nCharsToDisplay;
	sg.data.tagChar = tagChar;
	sg.data.daspPos = daspPos;
};

chem.Molfile.applyDataSGroupInfoLine = function (sGroups, propData)
{
	var mf = chem.Molfile;
	var id = mf.parseDecimalInt(propData.substr(0, 4)) - 1;
	var sg = sGroups[id];
	mf.applyDataSGroupInfo(sg, propData.substr(5));
};

chem.Molfile.applyDataSGroupData = function (sg, data, finalize)
{
	sg.data.fieldValue = (sg.data.fieldValue || '') + data;
	if(finalize)
	{
		sg.data.fieldValue = util.stripRight(sg.data.fieldValue);
		if(sg.data.fieldValue.startsWith('"') && sg.data.fieldValue.endsWith('"'))
			sg.data.fieldValue = sg.data.fieldValue.substr(1, sg.data.fieldValue.length - 2);
		sg.data.fieldValue += '\n';
	}
};

chem.Molfile.applyDataSGroupDataLine = function (sGroups, propData, finalize)
{
	var mf = chem.Molfile;
	var id = mf.parseDecimalInt(propData.substr(0, 5)) - 1;
	var data = propData.substr(5);
	var sg = sGroups[id];
	mf.applyDataSGroupData(sg, data, finalize);
};

chem.Molfile.parsePropertyLines = function (ctab, ctabLines, shift, end, sGroups, rLogic)
{
	var mf = chem.Molfile;
	var props = new util.Map();
	while(shift < end)
	{
		var line = ctabLines[shift];
		if(line.charAt(0) == 'A')
		{
			if(!props.get('label'))
				props.set('label', new util.Map());
			props.get('label').set(mf.parseDecimalInt(line.slice(3, 6)) - 1, ctabLines[++shift]);
		}
		else if(line.charAt(0) == 'M')
		{
			var type = line.slice(3, 6);
			var propertyData = line.slice(6);
			if(type == "END")
			{
				break;
			}
			else if(type == "CHG")
			{
				if(!props.get('charge'))
					props.set('charge', new util.Map());
				props.get('charge').update(mf.readKeyValuePairs(propertyData));
			}
			else if(type == "RAD")
			{
				if(!props.get('radical'))
					props.set('radical', new util.Map());
				props.get('radical').update(mf.readKeyValuePairs(propertyData));
			}
			else if(type == "ISO")
			{
				if(!props.get('isotope'))
					props.set('isotope', new util.Map());
				props.get('isotope').update(mf.readKeyValuePairs(propertyData));
			}
			else if(type == "RBC")
			{
				if(!props.get('ringBondCount'))
					props.set('ringBondCount', new util.Map());
				props.get('ringBondCount').update(mf.readKeyValuePairs(propertyData));
			}
			else if(type == "SUB")
			{
				if(!props.get('substitutionCount'))
					props.set('substitutionCount', new util.Map());
				props.get('substitutionCount').update(mf.readKeyValuePairs(propertyData));
			}
			else if(type == "UNS")
			{
				if(!props.get('unsaturatedAtom'))
					props.set('unsaturatedAtom', new util.Map());
				props.get('unsaturatedAtom').update(mf.readKeyValuePairs(propertyData));
				// else if (type == "LIN") // link atom
			}
			else if(type == "RGP")
			{ // rgroup atom
				if(!props.get('rglabel'))
					props.set('rglabel', new util.Map());
				var rglabels = props.get('rglabel');
				var a2rs = mf.readKeyMultiValuePairs(propertyData);
				for(var a2ri = 0; a2ri < a2rs.length; a2ri++)
				{
					var a2r = a2rs[a2ri];
					rglabels.set(a2r[0], (rglabels.get(a2r[0]) || 0) | (1 << (a2r[1] - 1)));
				}
			}
			else if(type == "LOG")
			{ // rgroup atom
				propertyData = propertyData.slice(4);
				var rgid = mf.parseDecimalInt(propertyData.slice(0, 3).trim());
				var iii = mf.parseDecimalInt(propertyData.slice(4, 7).trim());
				var hhh = mf.parseDecimalInt(propertyData.slice(8, 11).trim());
				var ooo = propertyData.slice(12).trim();
				var logic = {};
				if(iii > 0)
					logic.ifthen = iii;
				logic.resth = hhh == 1;
				logic.range = ooo;
				rLogic[rgid] = logic;
			}
			else if(type == "APO")
			{
				if(!props.get('attpnt'))
					props.set('attpnt', new util.Map());
				props.get('attpnt').update(mf.readKeyValuePairs(propertyData));
			}
			else if(type == "ALS")
			{ // atom list
				if(!props.get('atomList'))
					props.set('atomList', new util.Map());
				var list = mf.parsePropertyLineAtomList(
					mf.partitionLine(propertyData, [1, 3, 3, 1, 1, 1]),
					mf.partitionLineFixed(propertyData.slice(10), 4, false));
				props.get('atomList').update(
					list);
				if(!props.get('label'))
					props.set('label', new util.Map());
				for(var aid in list) props.get('label').set(aid, 'L#');
			}
			else if(type == "STY")
			{ // introduce s-group
				mf.initSGroup(sGroups, propertyData);
			}
			else if(type == "SST")
			{
				mf.applySGroupProp(sGroups, 'subtype', propertyData);
			}
			else if(type == "SLB")
			{
				mf.applySGroupProp(sGroups, 'label', propertyData, true);
			}
			else if(type == "SPL")
			{
				mf.applySGroupProp(sGroups, 'parent', propertyData, true, true);
			}
			else if(type == "SCN")
			{
				mf.applySGroupProp(sGroups, 'connectivity', propertyData);
			}
			else if(type == "SAL")
			{
				mf.applySGroupArrayProp(sGroups, 'atoms', propertyData, -1);
			}
			else if(type == "SBL")
			{
				mf.applySGroupArrayProp(sGroups, 'bonds', propertyData, -1);
			}
			else if(type == "SPA")
			{
				mf.applySGroupArrayProp(sGroups, 'patoms', propertyData, -1);
			}
			else if(type == "SMT")
			{
				var sid = mf.parseDecimalInt(propertyData.slice(0, 4)) - 1;
				sGroups[sid].data.subscript = propertyData.slice(4).trim();
			}
			else if(type == "SDT")
			{
				mf.applyDataSGroupDesc(sGroups, propertyData);
			}
			else if(type == "SDD")
			{
				mf.applyDataSGroupInfoLine(sGroups, propertyData);
			}
			else if(type == "SCD")
			{
				mf.applyDataSGroupDataLine(sGroups, propertyData, false);
			}
			else if(type == "SED")
			{
				mf.applyDataSGroupDataLine(sGroups, propertyData, true);
			}
		}
		++shift;
	}
	return props;
};

chem.Molfile.applyAtomProp = function (atoms /* Pool */ , values /* util.Map */ , propId /* string */ , clean /* boolean */ )
{
	values.each(function (aid, propVal)
	{
		atoms.get(aid)[propId] = propVal;
	});
};

chem.Molfile.parseCTabV2000 = function (ctabLines, countsSplit)
{
	var ctab = new chem.Struct();
	var i;
	var mf = chem.Molfile;
	var atomCount = mf.parseDecimalInt(countsSplit[0]);
	var bondCount = mf.parseDecimalInt(countsSplit[1]);
	var atomListCount = mf.parseDecimalInt(countsSplit[2]);
	ctab.isChiral = mf.parseDecimalInt(countsSplit[4]) != 0;
	var stextLinesCount = mf.parseDecimalInt(countsSplit[5]);
	var propertyLinesCount = mf.parseDecimalInt(countsSplit[10]);

	var shift = 0;
	var atomLines = ctabLines.slice(shift, shift + atomCount);
	shift += atomCount;
	var bondLines = ctabLines.slice(shift, shift + bondCount);
	shift += bondCount;
	var atomListLines = ctabLines.slice(shift, shift + atomListCount);
	shift += atomListCount + stextLinesCount;

	var atoms = atomLines.map(mf.parseAtomLine);
	for(i = 0; i < atoms.length; ++i)
		ctab.atoms.add(atoms[i]);
	var bonds = bondLines.map(mf.parseBondLine);
	for(i = 0; i < bonds.length; ++i)
		ctab.bonds.add(bonds[i]);

	var atomLists = atomListLines.map(mf.parseAtomListLine);
	util.each(atomLists, function (pair)
	{
		ctab.atoms.get(pair.aid).atomList = pair.atomList;
		ctab.atoms.get(pair.aid).label = 'L#';
	});

	var sGroups = {},
		rLogic = {};
	var props = mf.parsePropertyLines(ctab, ctabLines, shift,
		Math.min(ctabLines.length, shift + propertyLinesCount), sGroups, rLogic);
	props.each(function (propId, values)
	{
		mf.applyAtomProp(ctab.atoms, values, propId);
	});

	var atomMap = {};
	var sid;
	for(sid in sGroups)
	{
		var sg = sGroups[sid];
		if(sg.type === 'DAT' && sg.atoms.length === 0)
		{
			var parent = sGroups[sid].parent;
			if(parent >= 0)
			{
				var psg = sGroups[parent - 1];
				if(psg.type === 'GEN')
				{
					sg.atoms = util.array(psg.atoms);
				}
			}
		}
	}
	for(sid in sGroups)
	{
		chem.SGroup.addGroup(ctab, sGroups[sid], atomMap);
	}
	var emptyGroups = [];
	for(sid in sGroups)
	{ // TODO: why do we need that?
		chem.SGroup.filter(ctab, sGroups[sid], atomMap);
		if(sGroups[sid].atoms.length == 0 && !sGroups[sid].allAtoms)
			emptyGroups.push(sid);
	}
	for(i = 0; i < emptyGroups.length; ++i)
	{
		ctab.sGroupForest.remove(emptyGroups[i]);
		ctab.sgroups.remove(emptyGroups[i]);
	}
	for(var rgid in rLogic)
	{
		ctab.rgroups.set(rgid, new chem.Struct.RGroup(rLogic[rgid]));
	}
	return ctab;
};

// split a line by spaces outside parentheses
chem.Molfile.spaceparsplit = function (line)
{
	var split = [],
		pc = 0,
		c, i, i0 = -1;
	var line_array = line.toArray(); // IE7 doesn't support line[i]
	var quoted = false;

	for(i = 0; i < line.length; ++i)
	{
		c = line_array[i];
		if(c == '(')
			pc++;
		else if(c == ')')
			pc--;
		if(c == '"')
			quoted = !quoted;
		if(!quoted && line_array[i] == ' ' && pc == 0)
		{
			if(i > i0 + 1)
				split.push(line.slice(i0 + 1, i));
			i0 = i;
		}
	}
	if(i > i0 + 1)
		split.push(line.slice(i0 + 1, i));
	i0 = i;
	return split;
};

chem.Molfile.splitonce = function (line, delim)
{
	var p = line.indexOf(delim);
	return [line.slice(0, p), line.slice(p + 1)];
};

chem.Molfile.splitSGroupDef = function (line)
{
	var split = [];
	var braceBalance = 0;
	var quoted = false;
	for(var i = 0; i < line.length; ++i)
	{
		var c = line.charAt(i);
		if(c == '"')
		{
			quoted = !quoted;
		}
		else if(!quoted)
		{
			if(c == '(')
			{
				braceBalance++;
			}
			else if(c == ')')
			{
				braceBalance--;
			}
			else if(c == ' ' && braceBalance == 0)
			{
				split.push(line.slice(0, i));
				line = line.slice(i + 1).trim();
				i = 0;
			}
		}
	}
	if(braceBalance != 0)
		throw new Error("Brace balance broken. S-group properies invalid!");
	if(line.length > 0)
		split.push(line.trim());
	return split;
};

chem.Molfile.parseBracedNumberList = function (line, shift)
{
	if(!line)
		return null;
	var list = [];
	line = line.trim();
	line = line.substr(1, line.length - 2);
	var split = line.split(" ");
	shift = shift || 0;
	for(var i = 1; i < split.length; ++i)
	{ // skip the first element
		list.push(split[i] - 0 + shift);
	}
	return list;
};

chem.Molfile.v3000parseCollection = function (ctab, ctabLines, shift)
{
	shift++;
	while(ctabLines[shift].trim() != "M  V30 END COLLECTION")
		shift++;
	shift++;
	return shift;
};

chem.Molfile.v3000parseSGroup = function (ctab, ctabLines, sgroups, atomMap, shift)
{
	var mf = chem.Molfile;
	var line = '';
	shift++;
	while(shift < ctabLines.length)
	{
		line = mf.stripV30(ctabLines[shift++]).trim();
		if(line.trim() == 'END SGROUP')
			return shift;
		while(line.charAt(line.length - 1) == '-')
			line = (line.substr(0, line.length - 1) +
				mf.stripV30(ctabLines[shift++])).trim();
		var split = mf.splitSGroupDef(line);
		var type = split[1];
		var sg = new chem.SGroup(type);
		sg.number = split[0] - 0;
		sg.type = type;
		sg.label = split[2] - 0;
		sgroups[sg.number] = sg;
		var props = {};
		for(var i = 3; i < split.length; ++i)
		{
			var subsplit = mf.splitonce(split[i], '=');
			if(subsplit.length != 2)
			{
				throw new Error("A record of form AAA=BBB or AAA=(...) expected, got '" + split[i] + "'");
			}
			var name = subsplit[0];
			if(!(name in props))
				props[name] = [];
			props[name].push(subsplit[1]);
		}
		sg.atoms = mf.parseBracedNumberList(props['ATOMS'][0], -1);
		if(props['PATOMS'])
			sg.patoms = mf.parseBracedNumberList(props['PATOMS'][0], -1);
		sg.bonds = props['BONDS'] ? mf.parseBracedNumberList(props['BONDS'][0], -1) : [];
		var brkxyzStrs = props['BRKXYZ'];
		sg.brkxyz = [];
		if(brkxyzStrs)
		{
			for(var j = 0; j < brkxyzStrs.length; ++j)
				sg.brkxyz.push(mf.parseBracedNumberList(brkxyzStrs[j]));
		}
		if(props['MULT'])
		{
			sg.data.subscript = props['MULT'][0] - 0;
		}
		if(props['LABEL'])
		{
			sg.data.subscript = props['LABEL'][0].trim();
		}
		if(props['CONNECT'])
		{
			sg.data.connectivity = props['CONNECT'][0].toLowerCase();
		}
		if(props['FIELDDISP'])
		{
			mf.applyDataSGroupInfo(sg, util.stripQuotes(props['FIELDDISP'][0]));
		}
		if(props['FIELDDATA'])
		{
			mf.applyDataSGroupData(sg, props['FIELDDATA'][0], true);
		}
		if(props['FIELDNAME'])
		{
			mf.applyDataSGroupName(sg, props['FIELDNAME'][0]);
		}
		if(props['QUERYTYPE'])
		{
			mf.applyDataSGroupQuery(sg, props['QUERYTYPE'][0]);
		}
		if(props['QUERYOP'])
		{
			mf.applyDataSGroupQueryOp(sg, props['QUERYOP'][0]);
		}
		chem.SGroup.addGroup(ctab, sg, atomMap);
	}
	throw new Error("S-group declaration incomplete.");
};

chem.Molfile.parseCTabV3000 = function (ctabLines, norgroups)
{
	var ctab = new chem.Struct();
	var mf = chem.Molfile;

	var shift = 0;
	if(ctabLines[shift++].trim() != "M  V30 BEGIN CTAB")
		throw Error("CTAB V3000 invalid");
	if(ctabLines[shift].slice(0, 13) != "M  V30 COUNTS")
		throw Error("CTAB V3000 invalid");
	var vals = ctabLines[shift].slice(14).split(' ');
	ctab.isChiral = (mf.parseDecimalInt(vals[4]) == 1);
	shift++;

	if(ctabLines[shift].trim() == "M  V30 BEGIN ATOM")
	{
		shift++;
		var line;
		while(shift < ctabLines.length)
		{
			line = mf.stripV30(ctabLines[shift++]).trim();
			if(line == 'END ATOM')
				break;
			while(line.charAt(line.length - 1) == '-')
				line = (line.substring(0, line.length - 1) + mf.stripV30(ctabLines[shift++])).trim();
			ctab.atoms.add(mf.parseAtomLineV3000(line));
		}

		if(ctabLines[shift].trim() == "M  V30 BEGIN BOND")
		{
			shift++;
			while(shift < ctabLines.length)
			{
				line = mf.stripV30(ctabLines[shift++]).trim();
				if(line == 'END BOND')
					break;
				while(line.charAt(line.length - 1) == '-')
					line = (line.substring(0, line.length - 1) + mf.stripV30(ctabLines[shift++])).trim();
				ctab.bonds.add(mf.parseBondLineV3000(line));
			}
		}

		// TODO: let sections follow in arbitrary order
		var sgroups = {};
		var atomMap = {};

		while(ctabLines[shift].trim() != "M  V30 END CTAB")
		{
			if(ctabLines[shift].trim() == "M  V30 BEGIN COLLECTION")
			{
				// TODO: read collection information
				shift = mf.v3000parseCollection(ctab, ctabLines, shift);
			}
			else if(ctabLines[shift].trim() == "M  V30 BEGIN SGROUP")
			{
				shift = mf.v3000parseSGroup(ctab, ctabLines, sgroups, atomMap, shift);
			}
			else
			{
				throw Error("CTAB V3000 invalid");
			}
		}
	}
	if(ctabLines[shift++].trim() != "M  V30 END CTAB")
		throw Error("CTAB V3000 invalid");

	if(!norgroups)
	{
		mf.readRGroups3000(ctab, ctabLines.slice(shift));
	}

	return ctab;
};

chem.Molfile.readRGroups3000 = function (ctab, /* string */ ctabLines) /* chem.Struct */
{
	var rfrags = {};
	var rLogic = {};
	var shift = 0;
	var mf = chem.Molfile;
	while(shift < ctabLines.length && ctabLines[shift].search("M  V30 BEGIN RGROUP") == 0)
	{
		var id = ctabLines[shift++].split(' ').pop();
		rfrags[id] = [];
		rLogic[id] = {};
		while(true)
		{
			var line = ctabLines[shift].trim();
			if(line.search("M  V30 RLOGIC") == 0)
			{
				line = line.slice(13);
				var rlsplit = line.trim().split(/\s+/g);
				var iii = mf.parseDecimalInt(rlsplit[0]);
				var hhh = mf.parseDecimalInt(rlsplit[1]);
				var ooo = rlsplit.slice(2).join(" ");
				var logic = {};
				if(iii > 0)
					logic.ifthen = iii;
				logic.resth = hhh == 1;
				logic.range = ooo;
				rLogic[id] = logic;
				shift++;
				continue;
			}
			if(line != "M  V30 BEGIN CTAB")
				throw Error("CTAB V3000 invalid");
			for(var i = 0; i < ctabLines.length; ++i)
				if(ctabLines[shift + i].trim() == "M  V30 END CTAB")
					break;
			var lines = ctabLines.slice(shift, shift + i + 1);
			var rfrag = this.parseCTabV3000(lines, true);
			rfrags[id].push(rfrag);
			shift = shift + i + 1;
			if(ctabLines[shift].trim() == "M  V30 END RGROUP")
			{
				shift++;
				break;
			}
		}
	}

	for(var rgid in rfrags)
	{
		for(var j = 0; j < rfrags[rgid].length; ++j)
		{
			var rg = rfrags[rgid][j];
			rg.rgroups.set(rgid, new chem.Struct.RGroup(rLogic[rgid]));
			var frid = rg.frags.add(new chem.Struct.Fragment());
			rg.rgroups.get(rgid).frags.add(frid);
			rg.atoms.each(function (aid, atom)
			{
				atom.fragment = frid;
			});
			rg.mergeInto(ctab);
		}
	}
};

chem.Molfile.parseMol = function ( /* string */ ctabLines) /* chem.Struct */
{
	if(ctabLines[0].search("\\$MDL") == 0)
	{
		return this.parseRg2000(ctabLines);
	}
	var struct = this.parseCTab(ctabLines.slice(3));
	struct.name = ctabLines[0].trim();
	return struct;
};

chem.Molfile.parseCTab = function ( /* string */ ctabLines) /* chem.Struct */
{
	var mf = chem.Molfile;
	var countsSplit = mf.partitionLine(ctabLines[0], mf.fmtInfo.countsLinePartition);
	var version = countsSplit[11].trim();
	ctabLines = ctabLines.slice(1);
	if(version == 'V2000')
		return this.parseCTabV2000(ctabLines, countsSplit);
	else if(version == 'V3000')
		return this.parseCTabV3000(ctabLines, !chem.Molfile.loadRGroupFragments);
	else
		throw Error("Molfile version unknown: " + version);
};

chem.MolfileSaver = function (v3000)
{
	this.molecule = null;
	this.molfile = null;

	this.v3000 = v3000 || false
};

chem.MolfileSaver.prototype.prepareSGroups = function (skipErrors)
{
	var mol = this.molecule;
	var sgroups = mol.sgroups;
	var toRemove = [];

	util.each(this.molecule.sGroupForest.getSGroupsBFS().reverse(), function (id)
	{
		var sg = mol.sgroups.get(id);
		try
		{
			sg.prepareForSaving(mol);
		}
		catch(ex)
		{
			if(ui.forwardExceptions)
				throw ex;
			if(skipErrors && typeof (ex.id) == 'number')
			{
				toRemove.push(ex.id);
			}
			else
			{
				throw ex;
			}
		}
	}, this);
	if(toRemove.length > 0)
	{
		throw new Error(toRemove.length.toString() + " invalid S-groups were detected. They will be omitted.");
	}
	for(var i = 0; i < toRemove.length; ++i)
	{
		mol.sGroupDelete(toRemove[i]);
	}
	return mol;
};

chem.MolfileSaver.getComponents = function (molecule)
{
	var ccs = molecule.findConnectedComponents(true);
	var submols = [];
	var barriers = [];
	var arrowPos = null;
	molecule.rxnArrows.each(function (id, item)
	{ // there's just one arrow
		arrowPos = item.pp.x;
	});
	molecule.rxnPluses.each(function (id, item)
	{
		barriers.push(item.pp.x);
	});
	if(arrowPos != null)
		barriers.push(arrowPos);
	barriers.sort(function (a, b)
	{
		return a - b;
	});
	var components = [];

	var i;
	for(i = 0; i < ccs.length; ++i)
	{
		var bb = molecule.getCoordBoundingBox(ccs[i]);
		var c = util.Vec2.lc2(bb.min, 0.5, bb.max, 0.5);
		var j = 0;
		while(c.x > barriers[j])
		++j;
		components[j] = components[j] ||
		{};
		util.Set.mergeIn(components[j], ccs[i]);
	}
	var submolTexts = [];
	var reactants = [],
		products = [];
	for(i = 0; i < components.length; ++i)
	{
		if(!components[i])
		{
			submolTexts.push("");
			continue;
		}
		bb = molecule.getCoordBoundingBox(components[i]);
		c = util.Vec2.lc2(bb.min, 0.5, bb.max, 0.5);
		if(c.x < arrowPos)
			reactants.push(components[i]);
		else
			products.push(components[i]);
	}

	return {
		'reactants': reactants,
		'products': products
	};
};

chem.MolfileSaver.prototype.getCTab = function (molecule, rgroups)
{
	this.molecule = molecule.clone();
	this.molfile = '';
	this.writeCTab2000(rgroups);
	return this.molfile;
};

chem.MolfileSaver.prototype.saveMolecule = function (molecule, skipSGroupErrors, norgroups)
{
	this.reaction = molecule.rxnArrows.count() > 0;
	if(molecule.rxnArrows.count() > 1)
		throw new Error("Reaction may not contain more than one arrow");
	this.molfile = '';
	if(this.reaction)
	{
		if(molecule.rgroups.count() > 0)
			throw new Error("Unable to save the structure - reactions with r-groups are not supported at the moment");
		var components = chem.MolfileSaver.getComponents(molecule);

		var reactants = components.reactants,
			products = components.products,
			all = reactants.concat(products);
		this.molfile = "$RXN\n\n\n\n" + util.paddedInt(reactants.length, 3) + util.paddedInt(products.length, 3) + util.paddedInt(0, 3) + "\n";
		for(var i = 0; i < all.length; ++i)
		{
			var saver = new chem.MolfileSaver(false);
			var submol = molecule.clone(all[i], null, true);
			var molfile = saver.saveMolecule(submol, false, true);
			this.molfile += "$MOL\n" + molfile;
		}
		return this.molfile;
	}

	if(molecule.rgroups.count() > 0)
	{
		if(norgroups)
		{
			molecule = molecule.getScaffold();
		}
		else
		{
			var scaffold = new chem.MolfileSaver(false).getCTab(molecule.getScaffold(), molecule.rgroups);
			this.molfile = "$MDL  REV  1\n$MOL\n$HDR\n\n\n\n$END HDR\n";
			this.molfile += "$CTAB\n" + scaffold + "$END CTAB\n";

			molecule.rgroups.each(function (rgid, rg)
			{
				this.molfile += "$RGP\n";
				this.writePaddedNumber(rgid, 3);
				this.molfile += "\n";
				rg.frags.each(function (fnum, fid)
				{
					var group = new chem.MolfileSaver(false).getCTab(molecule.getFragment(fid));
					this.molfile += "$CTAB\n" + group + "$END CTAB\n";
				}, this);
				this.molfile += "$END RGP\n";
			}, this);
			this.molfile += "$END MOL\n";

			return this.molfile;
		}
	}

	this.molecule = molecule.clone();

	this.prepareSGroups(skipSGroupErrors);

	this.writeHeader();

	// TODO: saving to V3000
	this.writeCTab2000();

	return this.molfile;
};

chem.MolfileSaver.prototype.writeHeader = function ()
{
	var date = new Date();

	this.writeCR(); // TODO: write structure name
	this.writeWhiteSpace(2);
	this.write('MolView');
	this.writeWhiteSpace();
	this.writeCR((date.getMonth() + 1).toPaddedString(2) + date.getDate().toPaddedString(2) + (date.getFullYear() % 100).toPaddedString(2) +
		date.getHours().toPaddedString(2) + date.getMinutes().toPaddedString(2) + '2D 1   1.00000     0.00000     0');
	this.writeCR();
};

chem.MolfileSaver.prototype.write = function (str)
{
	this.molfile += str;
};

chem.MolfileSaver.prototype.writeCR = function (str)
{
	if(arguments.length == 0)
		str = '';

	this.molfile += str + '\n';
};

chem.MolfileSaver.prototype.writeWhiteSpace = function (length)
{
	if(arguments.length == 0) length = 1;
	for(var i = 0; i < length; i++) this.write(' ');
};

chem.MolfileSaver.prototype.writePadded = function (str, width)
{
	this.write(str);
	this.writeWhiteSpace(width - str.length);
};

chem.MolfileSaver.prototype.writePaddedNumber = function (number, width)
{
	var str = (number - 0).toString();

	this.writeWhiteSpace(width - str.length);
	this.write(str);
};

chem.MolfileSaver.prototype.writePaddedFloat = function (number, width, precision)
{
	this.write(util.paddedFloat(number, width, precision));
};

chem.MolfileSaver.prototype.writeCTab2000Header = function ()
{
	this.writePaddedNumber(this.molecule.atoms.count(), 3);
	this.writePaddedNumber(this.molecule.bonds.count(), 3);

	this.writePaddedNumber(0, 3);
	this.writeWhiteSpace(3);
	this.writePaddedNumber(this.molecule.isChiral ? 1 : 0, 3);
	this.writePaddedNumber(0, 3);
	this.writeWhiteSpace(12);
	this.writePaddedNumber(999, 3);
	this.writeCR(' V2000');
};

chem.MolfileSaver.prototype.writeCTab2000 = function (rgroups)
{
	this.writeCTab2000Header();

	this.mapping = {};
	var i = 1;

	var atomList_list = [];
	var atomLabel_list = [];
	this.molecule.atoms.each(function (id, atom)
	{
		this.writePaddedFloat(atom.pp.x, 10, 4);
		this.writePaddedFloat(-atom.pp.y, 10, 4);
		this.writePaddedFloat(0, 10, 4);
		this.writeWhiteSpace();

		var label = atom.label;
		if(atom.atomList != null)
		{
			label = 'L';
			atomList_list.push(id);
		}
		else if(chem.Element.getElementByLabel(label) == null && ['A', 'Q', 'X', '*', 'R#'].indexOf(label) == -1)
		{
			label = 'C';
			atomLabel_list.push(id);
		}
		this.writePadded(label, 3);
		this.writePaddedNumber(0, 2);
		this.writePaddedNumber(0, 3);
		this.writePaddedNumber(0, 3);

		if(isUndefined(atom.hCount))
			atom.hCount = 0;
		this.writePaddedNumber(atom.hCount, 3);

		if(isUndefined(atom.stereoCare))
			atom.stereoCare = 0;
		this.writePaddedNumber(atom.stereoCare, 3);

		this.writePaddedNumber(atom.explicitValence < 0 ? 0 : (atom.explicitValence == 0 ? 15 : atom.explicitValence), 3);

		this.writePaddedNumber(0, 3);
		this.writePaddedNumber(0, 3);
		this.writePaddedNumber(0, 3);

		if(isUndefined(atom.aam))
			atom.aam = 0;
		this.writePaddedNumber(atom.aam, 3);

		if(isUndefined(atom.invRet))
			atom.invRet = 0;
		this.writePaddedNumber(atom.invRet, 3);

		if(isUndefined(atom.exactChangeFlag))
			atom.exactChangeFlag = 0;
		this.writePaddedNumber(atom.exactChangeFlag, 3);

		this.writeCR();

		this.mapping[id] = i;
		i++;
	}, this);

	this.bondMapping = {};
	i = 1;
	this.molecule.bonds.each(function (id, bond)
	{
		this.bondMapping[id] = i++;
		this.writePaddedNumber(this.mapping[bond.begin], 3);
		this.writePaddedNumber(this.mapping[bond.end], 3);
		this.writePaddedNumber(bond.type, 3);

		if(isUndefined(bond.stereo))
			bond.stereo = 0;
		this.writePaddedNumber(bond.stereo, 3);

		this.writeWhiteSpace(3);

		if(isUndefined(bond.topology))
			bond.topology = 0;
		this.writePaddedNumber(bond.topology, 3);

		if(isUndefined(bond.reactingCenterStatus))
			bond.reactingCenterStatus = 0;
		this.writePaddedNumber(bond.reactingCenterStatus, 3);

		this.writeCR();
	}, this);

	while(atomLabel_list.length > 0)
	{
		this.write('A  ');
		this.writePaddedNumber(atomLabel_list[0] + 1, 3);
		this.writeCR();
		this.writeCR(this.molecule.atoms.get(atomLabel_list[0]).label);
		atomLabel_list.splice(0, 1);
	}

	var charge_list = new Array();
	var isotope_list = new Array();
	var radical_list = new Array();
	var rglabel_list = new Array();
	var rglogic_list = new Array();
	var aplabel_list = new Array();
	var rbcount_list = new Array();
	var unsaturated_list = new Array();
	var substcount_list = new Array();

	this.molecule.atoms.each(function (id, atom)
	{
		if(atom.charge != 0)
			charge_list.push([id, atom.charge]);
		if(atom.isotope != 0)
			isotope_list.push([id, atom.isotope]);
		if(atom.radical != 0)
			radical_list.push([id, atom.radical]);
		if(atom.rglabel != null && atom.label == 'R#')
		{ // TODO need to force rglabel=null when label is not 'R#'
			for(var rgi = 0; rgi < 32; rgi++)
			{
				if(atom.rglabel & (1 << rgi)) rglabel_list.push([id, rgi + 1]);
			}
		}
		if(atom.attpnt != null)
			aplabel_list.push([id, atom.attpnt]);
		if(atom.ringBondCount != 0)
			rbcount_list.push([id, atom.ringBondCount]);
		if(atom.substitutionCount != 0)
			substcount_list.push([id, atom.substitutionCount]);
		if(atom.unsaturatedAtom != 0)
			unsaturated_list.push([id, atom.unsaturatedAtom]);
	});

	if(rgroups)
		rgroups.each(function (rgid, rg)
		{
			if(rg.resth || rg.ifthen > 0 || rg.range.length > 0)
			{
				var line = '  1 ' + util.paddedInt(rgid, 3) + ' ' + util.paddedInt(rg.ifthen, 3) + ' ' + util.paddedInt(rg.resth ? 1 : 0, 3) + '   ' + rg.range;
				rglogic_list.push(line);
			}
		});

	var writeAtomPropList = function (prop_id, values)
	{
		while(values.length > 0)
		{
			var part = new Array();

			while(values.length > 0 && part.length < 8)
			{
				part.push(values[0]);
				values.splice(0, 1);
			}

			this.write(prop_id);
			this.writePaddedNumber(part.length, 3);

			util.each(part, function (value)
			{
				this.writeWhiteSpace();
				this.writePaddedNumber(this.mapping[value[0]], 3);
				this.writeWhiteSpace();
				this.writePaddedNumber(value[1], 3);
			}, this);

			this.writeCR();
		}
	};

	writeAtomPropList.call(this, 'M  CHG', charge_list);
	writeAtomPropList.call(this, 'M  ISO', isotope_list);
	writeAtomPropList.call(this, 'M  RAD', radical_list);
	writeAtomPropList.call(this, 'M  RGP', rglabel_list);
	for(var j = 0; j < rglogic_list.length; ++j)
	{
		this.write('M  LOG' + rglogic_list[j] + '\n');
	}
	writeAtomPropList.call(this, 'M  APO', aplabel_list);
	writeAtomPropList.call(this, 'M  RBC', rbcount_list);
	writeAtomPropList.call(this, 'M  SUB', substcount_list);
	writeAtomPropList.call(this, 'M  UNS', unsaturated_list);

	if(atomList_list.length > 0)
	{
		for(j = 0; j < atomList_list.length; ++j)
		{
			var aid = atomList_list[j];
			var atomList = this.molecule.atoms.get(aid).atomList;
			this.write('M  ALS');
			this.writePaddedNumber(aid + 1, 4);
			this.writePaddedNumber(atomList.ids.length, 3);
			this.writeWhiteSpace();
			this.write(atomList.notList ? 'T' : 'F');

			var labelList = atomList.labelList();
			for(var k = 0; k < labelList.length; ++k)
			{
				this.writeWhiteSpace();
				this.writePadded(labelList[k], 3);
			}
			this.writeCR();
		}
	}

	var sgmap = {},
		cnt = 1,
		sgmapback = {};
	var sgorder = this.molecule.sGroupForest.getSGroupsBFS();
	util.each(sgorder, function (id)
	{
		sgmapback[cnt] = id;
		sgmap[id] = cnt++;
	}, this);
	for(var q = 1; q < cnt; ++q)
	{ // each group on its own
		var id = sgmapback[q];
		var sgroup = this.molecule.sgroups.get(id);
		this.write('M  STY');
		this.writePaddedNumber(1, 3);
		this.writeWhiteSpace(1);
		this.writePaddedNumber(q, 3);
		this.writeWhiteSpace(1);
		this.writePadded(sgroup.type, 3);
		this.writeCR();

		// TODO: write subtype, M SST

		this.write('M  SLB');
		this.writePaddedNumber(1, 3);
		this.writeWhiteSpace(1);
		this.writePaddedNumber(q, 3);
		this.writeWhiteSpace(1);
		this.writePaddedNumber(q, 3);
		this.writeCR();

		var parentid = this.molecule.sGroupForest.parent.get(id);
		if(parentid >= 0)
		{
			this.write('M  SPL');
			this.writePaddedNumber(1, 3);
			this.writeWhiteSpace(1);
			this.writePaddedNumber(q, 3);
			this.writeWhiteSpace(1);
			this.writePaddedNumber(sgmap[parentid], 3);
			this.writeCR();
		}

		// connectivity
		if(sgroup.type == 'SRU' && sgroup.data.connectivity)
		{
			var connectivity = '';
			connectivity += ' ';
			connectivity += util.stringPadded(q.toString(), 3);
			connectivity += ' ';
			connectivity += util.stringPadded(sgroup.data.connectivity, 3, true);
			this.write('M  SCN');
			this.writePaddedNumber(1, 3);
			this.write(connectivity.toUpperCase());
			this.writeCR();
		}

		if(sgroup.type == 'SRU')
		{
			this.write('M  SMT ');
			this.writePaddedNumber(q, 3);
			this.writeWhiteSpace();
			this.write(sgroup.data.subscript || 'n');
			this.writeCR();
		}

		this.writeCR(sgroup.saveToMolfile(this.molecule, sgmap, this.mapping, this.bondMapping));
	}

	// TODO: write M  APO
	// TODO: write M  AAL
	// TODO: write M  RGP
	// TODO: write M  LOG

	this.writeCR('M  END');
};

chem.Molfile.parseRxn = function ( /* string[] */ ctabLines) /* chem.Struct */
{
	var mf = chem.Molfile;
	var split = ctabLines[0].trim().split(' ');
	if(split.length > 1 && split[1] == 'V3000')
		return mf.parseRxn3000(ctabLines);
	else
		return mf.parseRxn2000(ctabLines);
};

chem.Molfile.parseRxn2000 = function ( /* string[] */ ctabLines) /* chem.Struct */
{
	var mf = chem.Molfile;
	ctabLines = ctabLines.slice(4);
	var countsSplit = mf.partitionLine(ctabLines[0], mf.fmtInfo.rxnItemsPartition);
	var nReactants = countsSplit[0] - 0,
		nProducts = countsSplit[1] - 0,
		nAgents = countsSplit[2] - 0;
	ctabLines = ctabLines.slice(1); // consume counts line

	var mols = [];
	while(ctabLines.length > 0 && ctabLines[0].substr(0, 4) == "$MOL")
	{
		ctabLines = ctabLines.slice(1);
		var n = 0;
		while(n < ctabLines.length && ctabLines[n].substr(0, 4) != "$MOL") n++;
		mols.push(chem.Molfile.parseMol(ctabLines.slice(0, n)));
		ctabLines = ctabLines.slice(n);
	}
	return mf.rxnMerge(mols, nReactants, nProducts, nAgents);
};

chem.Molfile.parseRxn3000 = function ( /* string[] */ ctabLines) /* chem.Struct */
{
	var mf = chem.Molfile;
	ctabLines = ctabLines.slice(4);
	var countsSplit = ctabLines[0].split(/\s+/g).slice(3);
	var nReactants = countsSplit[0] - 0,
		nProducts = countsSplit[1] - 0,
		nAgents = countsSplit.length > 2 ? countsSplit[2] - 0 : 0;

	var assert = function (condition)
	{
		util.assert(condition, "CTab format invalid");
	};

	var findCtabEnd = function (i)
	{
		for(var j = i; j < ctabLines.length; ++j)
		{
			if(ctabLines[j].trim() == "M  V30 END CTAB")
				return j;
		}
		assert(false);
	};

	var findRGroupEnd = function (i)
	{
		for(var j = i; j < ctabLines.length; ++j)
			if(ctabLines[j].trim() == "M  V30 END RGROUP")
				return j;
		assert(false);
	};

	var molLinesReactants = [],
		molLinesProducts = [],
		current = null,
		rGroups = [];
	for(var i = 0; i < ctabLines.length; ++i)
	{
		var line = ctabLines[i].trim();

		if(line.startsWith("M  V30 COUNTS"))
		{
			// do nothing
		}
		else if(line == "M  END")
		{
			break; // stop reading
		}
		else if(line == "M  V30 BEGIN PRODUCT")
		{
			assert(current == null);
			current = molLinesProducts;
		}
		else if(line == "M  V30 END PRODUCT")
		{
			assert(current === molLinesProducts);
			current = null;
		}
		else if(line == "M  V30 BEGIN REACTANT")
		{
			assert(current == null);
			current = molLinesReactants;
		}
		else if(line == "M  V30 END REACTANT")
		{
			assert(current === molLinesReactants);
			current = null;
		}
		else if(line.startsWith("M  V30 BEGIN RGROUP"))
		{
			assert(current == null);
			var j = findRGroupEnd(i);
			rGroups.push(ctabLines.slice(i, j + 1));
			i = j;
		}
		else if(line == "M  V30 BEGIN CTAB")
		{
			var j = findCtabEnd(i);
			current.push(ctabLines.slice(i, j + 1));
			i = j;
		}
		else
		{
			throw new Error("Line unrecognized: " + line);
		}
	}
	var mols = [];
	var molLines = molLinesReactants.concat(molLinesProducts);
	for(var j = 0; j < molLines.length; ++j)
	{
		var mol = chem.Molfile.parseCTabV3000(molLines[j], countsSplit);
		mols.push(mol);
	}
	var ctab = mf.rxnMerge(mols, nReactants, nProducts, nAgents);

	mf.readRGroups3000(ctab, function (array)
	{
		var res = [];
		for(var k = 0; k < array.length; ++k)
		{
			res = res.concat(array[k]);
		}
		return res;
	}(rGroups));

	return ctab;
};

chem.Molfile.rxnMerge = function (mols, nReactants, nProducts, nAgents) /* chem.Struct */
{
	var mf = chem.Molfile;

	var ret = new chem.Struct();
	var bbReact = [],
		bbAgent = [],
		bbProd = [];
	var molReact = [],
		molAgent = [],
		molProd = [];
	var j;
	var bondLengthData = {
		cnt: 0,
		totalLength: 0
	};
	for(j = 0; j < mols.length; ++j)
	{
		var mol = mols[j];
		var bondLengthDataMol = mol.getBondLengthData();
		bondLengthData.cnt += bondLengthDataMol.cnt;
		bondLengthData.totalLength += bondLengthDataMol.totalLength;
	}
	var avgBondLength = 1 / (bondLengthData.cnt == 0 ? 1 : bondLengthData.totalLength / bondLengthData.cnt);
	for(j = 0; j < mols.length; ++j)
	{
		mol = mols[j];
		mol.scale(avgBondLength);
	}

	for(j = 0; j < mols.length; ++j)
	{
		mol = mols[j];
		var bb = mol.getCoordBoundingBoxObj();
		if(!bb)
			continue;

		var fragmentType = (j < nReactants ? chem.Struct.FRAGMENT.REACTANT :
			(j < nReactants + nProducts ? chem.Struct.FRAGMENT.PRODUCT :
				chem.Struct.FRAGMENT.AGENT));
		if(fragmentType == chem.Struct.FRAGMENT.REACTANT)
		{
			bbReact.push(bb);
			molReact.push(mol);
		}
		else if(fragmentType == chem.Struct.FRAGMENT.AGENT)
		{
			bbAgent.push(bb);
			molAgent.push(mol);
		}
		else if(fragmentType == chem.Struct.FRAGMENT.PRODUCT)
		{
			bbProd.push(bb);
			molProd.push(mol);
		}

		mol.atoms.each(function (aid, atom)
		{
			atom.rxnFragmentType = fragmentType;
		});
	}

	// reaction fragment layout
	var xorig = 0;
	var shiftMol = function (ret, mol, bb, xorig, over)
	{
		var d = new util.Vec2(xorig - bb.min.x, over ? 1 - bb.min.y : -(bb.min.y + bb.max.y) / 2);
		mol.atoms.each(function (aid, atom)
		{
			atom.pp.add_(d);
		});
		mol.sgroups.each(function (id, item)
		{
			if(item.pp)
				item.pp.add_(d);
		});
		bb.min.add_(d);
		bb.max.add_(d);
		mol.mergeInto(ret);
		return bb.max.x - bb.min.x;
	};

	for(j = 0; j < molReact.length; ++j)
	{
		xorig += shiftMol(ret, molReact[j], bbReact[j], xorig, false) + 2.0;
	}
	xorig += 2.0;
	for(j = 0; j < molAgent.length; ++j)
	{
		xorig += shiftMol(ret, molAgent[j], bbAgent[j], xorig, true) + 2.0;
	}
	xorig += 2.0;

	for(j = 0; j < molProd.length; ++j)
	{
		xorig += shiftMol(ret, molProd[j], bbProd[j], xorig, false) + 2.0;
	}

	var bb1, bb2, x, y, bbReactAll = null,
		bbProdAll = null;
	for(j = 0; j < bbReact.length - 1; ++j)
	{
		bb1 = bbReact[j];
		bb2 = bbReact[j + 1];

		x = (bb1.max.x + bb2.min.x) / 2;
		y = (bb1.max.y + bb1.min.y + bb2.max.y + bb2.min.y) / 4;

		ret.rxnPluses.add(new chem.Struct.RxnPlus(
		{
			'pp': new util.Vec2(x, y)
		}));
	}
	for(j = 0; j < bbReact.length; ++j)
	{
		if(j == 0)
		{
			bbReactAll = {};
			bbReactAll.max = new util.Vec2(bbReact[j].max);
			bbReactAll.min = new util.Vec2(bbReact[j].min);
		}
		else
		{
			bbReactAll.max = util.Vec2.max(bbReactAll.max, bbReact[j].max);
			bbReactAll.min = util.Vec2.min(bbReactAll.min, bbReact[j].min);
		}
	}
	for(j = 0; j < bbProd.length - 1; ++j)
	{
		bb1 = bbProd[j];
		bb2 = bbProd[j + 1];

		x = (bb1.max.x + bb2.min.x) / 2;
		y = (bb1.max.y + bb1.min.y + bb2.max.y + bb2.min.y) / 4;

		ret.rxnPluses.add(new chem.Struct.RxnPlus(
		{
			'pp': new util.Vec2(x, y)
		}));
	}
	for(j = 0; j < bbProd.length; ++j)
	{
		if(j == 0)
		{
			bbProdAll = {};
			bbProdAll.max = new util.Vec2(bbProd[j].max);
			bbProdAll.min = new util.Vec2(bbProd[j].min);
		}
		else
		{
			bbProdAll.max = util.Vec2.max(bbProdAll.max, bbProd[j].max);
			bbProdAll.min = util.Vec2.min(bbProdAll.min, bbProd[j].min);
		}
	}
	bb1 = bbReactAll;
	bb2 = bbProdAll;
	if(!bb1 && !bb2)
	{
		ret.rxnArrows.add(new chem.Struct.RxnArrow(
		{
			'pp': new util.Vec2(0, 0)
		}));
	}
	else
	{
		var v1 = bb1 ? new util.Vec2(bb1.max.x, (bb1.max.y + bb1.min.y) / 2) : null;
		var v2 = bb2 ? new util.Vec2(bb2.min.x, (bb2.max.y + bb2.min.y) / 2) : null;
		var defaultOffset = 3;
		if(!v1)
			v1 = new util.Vec2(v2.x - defaultOffset, v2.y);
		if(!v2)
			v2 = new util.Vec2(v1.x + defaultOffset, v1.y);
		ret.rxnArrows.add(new chem.Struct.RxnArrow(
		{
			'pp': util.Vec2.lc2(v1, 0.5, v2, 0.5)
		}));
	}
	ret.isReaction = true;
	return ret;
};

chem.Molfile.rgMerge = function (scaffold, rgroups) /* chem.Struct */
{
	var ret = new chem.Struct();

	scaffold.mergeInto(ret, null, null, false, true);
	for(var rgid in rgroups)
	{
		for(var j = 0; j < rgroups[rgid].length; ++j)
		{
			var ctab = rgroups[rgid][j];
			ctab.rgroups.set(rgid, new chem.Struct.RGroup());
			var frid = ctab.frags.add(new chem.Struct.Fragment());
			ctab.rgroups.get(rgid).frags.add(frid);
			ctab.atoms.each(function (aid, atom)
			{
				atom.fragment = frid;
			});
			ctab.mergeInto(ret);
		}
	}

	return ret;
};

chem.Molfile.parseRg2000 = function ( /* string[] */ ctabLines) /* chem.Struct */
{
	var mf = chem.Molfile;
	ctabLines = ctabLines.slice(7);
	if(ctabLines[0].trim() != '$CTAB')
		throw new Error('RGFile format invalid');
	var i = 1;
	while(ctabLines[i].charAt(0) != '$') i++;
	if(ctabLines[i].trim() != '$END CTAB')
		throw new Error('RGFile format invalid');
	var coreLines = ctabLines.slice(1, i);
	ctabLines = ctabLines.slice(i + 1);
	var fragmentLines = {};
	while(true)
	{
		if(ctabLines.length == 0)
			throw new Error('Unexpected end of file');
		var line = ctabLines[0].trim();
		if(line == '$END MOL')
		{
			ctabLines = ctabLines.slice(1);
			break;
		}
		if(line != '$RGP')
			throw new Error('RGFile format invalid');
		var rgid = ctabLines[1].trim() - 0;
		fragmentLines[rgid] = [];
		ctabLines = ctabLines.slice(2);
		while(true)
		{
			if(ctabLines.length == 0)
				throw new Error('Unexpected end of file');
			line = ctabLines[0].trim();
			if(line == '$END RGP')
			{
				ctabLines = ctabLines.slice(1);
				break;
			}
			if(line != '$CTAB')
				throw new Error('RGFile format invalid');
			i = 1;
			while(ctabLines[i].charAt(0) != '$') i++;
			if(ctabLines[i].trim() != '$END CTAB')
				throw new Error('RGFile format invalid');
			fragmentLines[rgid].push(ctabLines.slice(1, i));
			ctabLines = ctabLines.slice(i + 1);
		}
	}

	var core = chem.Molfile.parseCTab(coreLines),
		frag = {};
	if(chem.Molfile.loadRGroupFragments)
	{
		for(var id in fragmentLines)
		{
			frag[id] = [];
			for(var j = 0; j < fragmentLines[id].length; ++j)
			{
				frag[id].push(chem.Molfile.parseCTab(fragmentLines[id][j]));
			}
		}
	}
	return mf.rgMerge(core, frag);
};
/****************************************************************************
 * Copyright (C) 2009-2010 GGA Software Services LLC
 *
 * This file may be distributed and/or modified under the terms of the
 * GNU Affero General Public License version 3 as published by the Free
 * Software Foundation and appearing in the file LICENSE.GPL included in
 * the packaging of this file.
 *
 * This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
 * WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ***************************************************************************/

if(!window.chem || !util.Vec2 || !util.Pool)
	throw new Error("Vec2, Pool should be defined first");
chem.SGroup = function (type)
{
	if(!type || !(type in chem.SGroup.TYPES))
		throw new Error("Invalid or unsupported s-group type");

	this.type = type;
	this.id = -1;
	chem.SGroup.equip(this, type);
	this.label = -1;
	this.bracketBox = null;
	this.bracketDir = new util.Vec2(1, 0);
	this.areas = [];

	this.highlight = false;
	this.highlighting = null;
	this.selected = false;
	this.selectionPlate = null;

	this.atoms = [];
	this.patoms = [];
	this.bonds = [];
	this.xBonds = [];
	this.neiAtoms = [];
	this.pp = null;
	this.data = {
		'mul': 1, // multiplication count for MUL group
		'connectivity': 'ht', // head-to-head, head-to-tail or either-unknown
		'name': '',
		'subscript': 'n',

		// data s-group fields
		'attached': false,
		'absolute': true,
		'showUnits': false,
		'nCharsToDisplay': -1,
		'tagChar': '',
		'daspPos': 1,
		'fieldType': 'F',
		'fieldName': '',
		'fieldValue': '',
		'units': '',
		'query': '',
		'queryOp': ''
	}
};

// TODO: these methods should be overridden
//      and should only accept valid attributes for each S-group type.
//      The attributes should be accessed via these methods only and not directly through this.data.
// stub
chem.SGroup.prototype.getAttr = function (attr)
{
	return this.data[attr];
};

// TODO: should be group-specific
chem.SGroup.prototype.getAttrs = function ()
{
	var attrs = {};
	for(var attr in this.data)
		attrs[attr] = this.data[attr];
	return attrs;
};

// stub
chem.SGroup.prototype.setAttr = function (attr, value)
{
	var oldValue = this.data[attr];
	this.data[attr] = value;
	return oldValue;
};

// stub
chem.SGroup.prototype.checkAttr = function (attr, value)
{
	return this.data[attr] == value;
};

chem.SGroup.equip = function (sgroup, type)
{
	var impl = chem.SGroup.TYPES[type];
	for(var method in impl)
		sgroup[method] = impl[method];
};

chem.SGroup.numberArrayToString = function (numbers, map)
{
	var str = util.stringPadded(numbers.length, 3);
	for(var i = 0; i < numbers.length; ++i)
	{
		str += ' ' + util.stringPadded(map[numbers[i]], 3);
	}
	return str;
};

chem.SGroup.addGroup = function (mol, sg, atomMap)
{
	// add the group to the molecule
	sg.id = mol.sgroups.add(sg);

	// apply type-specific post-processing
	sg.postLoad(mol, atomMap);

	// mark atoms in the group as belonging to it
	for(var s = 0; s < sg.atoms.length; ++s)
		if(mol.atoms.has(sg.atoms[s]))
			util.Set.add(mol.atoms.get(sg.atoms[s]).sgs, sg.id);

	mol.sGroupForest.insert(sg.id);
	return sg.id;
};

chem.SGroup.bracketsToMolfile = function (mol, sg, idstr)
{
	var inBonds = [],
		xBonds = [];
	var atomSet = util.Set.fromList(sg.atoms);
	chem.SGroup.getCrossBonds(inBonds, xBonds, mol, atomSet);
	chem.SGroup.bracketPos(sg, null, mol, xBonds);
	var bb = sg.bracketBox;
	var d = sg.bracketDir,
		n = d.rotateSC(1, 0);
	var brackets = chem.SGroup.getBracketParameters(mol, xBonds, atomSet, bb, d, n, null, sg.id);
	var lines = [];
	for(var i = 0; i < brackets.length; ++i)
	{
		var bracket = brackets[i];
		var a0 = bracket.c.addScaled(bracket.n, -0.5 * bracket.h).yComplement();
		var a1 = bracket.c.addScaled(bracket.n, 0.5 * bracket.h).yComplement();
		var line = 'M  SDI ' + idstr + util.paddedInt(4, 3);
		var coord = [a0.x, a0.y, a1.x, a1.y];
		for(var j = 0; j < coord.length; ++j)
		{
			line += util.paddedFloat(coord[j], 10, 4);
		}
		lines.push(line);
	}
	return lines;
};

chem.SGroup.filterAtoms = function (atoms, map)
{
	var newAtoms = [];
	for(var i = 0; i < atoms.length; ++i)
	{
		var aid = atoms[i];
		if(typeof (map[aid]) != "number")
		{
			newAtoms.push(aid);
		}
		else if(map[aid] >= 0)
		{
			newAtoms.push(map[aid]);
		}
		else
		{
			newAtoms.push(-1);
		}
	}
	return newAtoms;
};

chem.SGroup.removeNegative = function (atoms)
{
	var newAtoms = [];
	for(var j = 0; j < atoms.length; ++j)
		if(atoms[j] >= 0)
			newAtoms.push(atoms[j]);
	return newAtoms;
};

chem.SGroup.filter = function (mol, sg, atomMap)
{
	sg.atoms = chem.SGroup.removeNegative(chem.SGroup.filterAtoms(sg.atoms, atomMap));
};

chem.SGroup.clone = function (sgroup, aidMap, bidMap)
{
	var cp = new chem.SGroup(sgroup.type);

	for(var field in sgroup.data)
	{ // TODO: remove all non-primitive properties from 'data'
		cp.data[field] = sgroup.data[field];
	}
	cp.atoms = util.mapArray(sgroup.atoms, aidMap);
	cp.pp = sgroup.pp;
	cp.bracketBox = sgroup.bracketBox;
	cp.patoms = null;
	cp.bonds = null;
	cp.allAtoms = sgroup.allAtoms;
	return cp;
};

chem.SGroup.addAtom = function (sgroup, aid)
{
	sgroup.atoms.push(aid);
};

chem.SGroup.removeAtom = function (sgroup, aid)
{
	for(var i = 0; i < sgroup.atoms.length; ++i)
	{
		if(sgroup.atoms[i] === aid)
		{
			sgroup.atoms.splice(i, 1);
			return;
		}
	}
	throw new Error("The atom is not found in the given s-group");
};

chem.SGroup.getCrossBonds = function (inBonds, xBonds, mol, parentAtomSet)
{
	mol.bonds.each(function (bid, bond)
	{
		if(util.Set.contains(parentAtomSet, bond.begin) && util.Set.contains(parentAtomSet, bond.end))
		{
			if(!util.isNull(inBonds))
				inBonds.push(bid);
		}
		else if(util.Set.contains(parentAtomSet, bond.begin) || util.Set.contains(parentAtomSet, bond.end))
		{
			if(!util.isNull(xBonds))
				xBonds.push(bid);
		}
	}, this);
};

chem.SGroup.bracketPos = function (sg, render, mol, xbonds)
{
	var atoms = sg.atoms;
	if(!xbonds || xbonds.length !== 2)
	{
		sg.bracketDir = new util.Vec2(1, 0);
	}
	else
	{
		var b1 = mol.bonds.get(xbonds[0]),
			b2 = mol.bonds.get(xbonds[1]);
		var p1 = b1.getCenter(mol),
			p2 = b2.getCenter(mol);
		sg.bracketDir = util.Vec2.diff(p2, p1).normalized();
	}
	var d = sg.bracketDir;
	var n = d.rotateSC(1, 0);

	var bb = null;
	var contentBoxes = [];
	util.each(atoms, function (aid)
	{
		var atom = mol.atoms.get(aid);
		var bba = render ? render.ctab.atoms.get(aid).visel.boundingBox : null;
		var pos = new util.Vec2(atom.pp);
		if(util.isNull(bba))
		{
			bba = new util.Box2Abs(pos, pos);
			var ext = new util.Vec2(0.05 * 3, 0.05 * 3);
			bba = bba.extend(ext, ext);
		}
		else
		{
			bba = bba.translate((render.offset || new util.Vec2()).negated()).transform(render.scaled2obj, render);
		}
		contentBoxes.push(bba);
	}, this);
	util.each(mol.sGroupForest.children.get(sg.id), function (sgid)
	{
		var bba = render ? render.ctab.sgroups.get(sgid).visel.boundingBox : null;
		if(util.isNull(bba))
			return; // TODO: use object box instead
		bba = bba.translate((render.offset || new util.Vec2()).negated()).transform(render.scaled2obj, render);
		contentBoxes.push(bba);
	}, this);
	util.each(contentBoxes, function (bba)
	{
		var bbb = null;
		util.each([bba.p0.x, bba.p1.x], function (x)
		{
			util.each([bba.p0.y, bba.p1.y], function (y)
			{
				var v = new util.Vec2(x, y);
				var p = new util.Vec2(util.Vec2.dot(v, d), util.Vec2.dot(v, n));
				bbb = util.isNull(bbb) ? new util.Box2Abs(p, p) : bbb.include(p);
			}, this);
		}, this);
		bb = util.isNull(bb) ? bbb : util.Box2Abs.union(bb, bbb);
	}, this);
	var vext = new util.Vec2(0.2, 0.4);
	if(!util.isNull(bb))
		bb = bb.extend(vext, vext);
	sg.bracketBox = bb;
};

chem.SGroup.drawBrackets = function (set, render, sg, xbonds, atomSet, bb, d, n, lowerIndexText, upperIndexText, indexAttribute)
{
	var brackets = chem.SGroup.getBracketParameters(render.ctab.molecule, xbonds, atomSet, bb, d, n, render, sg.id);
	var ir = -1;
	for(var i = 0; i < brackets.length; ++i)
	{
		var bracket = brackets[i];
		var path = chem.SGroup.drawBracket(render, render.paper, render.styles, bracket.d, bracket.n, bracket.c, bracket.w, bracket.h);
		set.push(path);
		if(ir < 0 || brackets[ir].d.x < bracket.d.x || (brackets[ir].d.x == bracket.d.x && brackets[ir].d.y > bracket.d.y))
			ir = i;
	}
	var bracketR = brackets[ir];
	var renderIndex = function (text, shift)
	{
		var indexPos = render.ps(bracketR.c.addScaled(bracketR.n, shift * bracketR.h));
		var indexPath = render.paper.text(indexPos.x, indexPos.y, text)
			.attr(
			{
				'font': render.settings.font,
				'font-size': render.settings.fontszsub
			});
		if(indexAttribute)
			indexPath.attr(indexAttribute);
		var indexBox = util.Box2Abs.fromRelBox(rnd.relBox(indexPath.getBBox()));
		var t = Math.max(util.Vec2.shiftRayBox(indexPos, bracketR.d.negated(), indexBox), 3) + 2;
		indexPath.translateAbs(t * bracketR.d.x, t * bracketR.d.y);
		set.push(indexPath);
	}
	if(lowerIndexText)
	{
		renderIndex(lowerIndexText, 0.5);
	}
	if(upperIndexText)
	{
		renderIndex(upperIndexText, -0.5);
	}
};

chem.SGroup.drawBracket = function (render, paper, styles, d, n, c, bracketWidth, bracketHeight)
{
	bracketWidth = bracketWidth || 0.25;
	bracketHeight = bracketHeight || 1.0;
	var a0 = c.addScaled(n, -0.5 * bracketHeight);
	var a1 = c.addScaled(n, 0.5 * bracketHeight);
	var b0 = a0.addScaled(d, -bracketWidth);
	var b1 = a1.addScaled(d, -bracketWidth);

	a0 = render.obj2scaled(a0);
	a1 = render.obj2scaled(a1);
	b0 = render.obj2scaled(b0);
	b1 = render.obj2scaled(b1);

	return paper.path("M {0}, {1} L {2} , {3} L {4} , {5} L {6} , {7}",
			b0.x, b0.y, a0.x, a0.y, a1.x, a1.y, b1.x, b1.y)
		.attr(styles.sgroupBracketStyle);
}

chem.SGroup.getBracketParameters = function (mol, xbonds, atomSet, bb, d, n, render, id)
{
	var bracketParams = function (c, d, w, h)
	{
		this.c = c;
		this.d = d;
		this.n = d.rotateSC(1, 0);
		this.w = w;
		this.h = h;
	}
	var brackets = [];
	if(xbonds.length < 2)
	{
		(function ()
		{
			d = d || new util.Vec2(1, 0);
			n = n || d.rotateSC(1, 0);
			var bracketWidth = Math.min(0.25, bb.sz().x * 0.3);
			var cl = util.Vec2.lc2(d, bb.p0.x, n, 0.5 * (bb.p0.y + bb.p1.y));
			var cr = util.Vec2.lc2(d, bb.p1.x, n, 0.5 * (bb.p0.y + bb.p1.y));
			var bracketHeight = bb.sz().y;

			brackets.push(new bracketParams(cl, d.negated(), bracketWidth, bracketHeight), new bracketParams(cr, d, bracketWidth, bracketHeight));
		})();
	}
	else if(xbonds.length === 2)
	{
		(function ()
		{
			var b1 = mol.bonds.get(xbonds[0]),
				b2 = mol.bonds.get(xbonds[1]);
			var cl0 = b1.getCenter(mol),
				cr0 = b2.getCenter(mol),
				tl = -1,
				tr = -1,
				tt = -1,
				tb = -1,
				cc = util.Vec2.centre(cl0, cr0);
			var dr = util.Vec2.diff(cr0, cl0).normalized(),
				dl = dr.negated(),
				dt = dr.rotateSC(1, 0),
				db = dt.negated();

			util.each(mol.sGroupForest.children.get(id), function (sgid)
			{
				var bba = render ? render.ctab.sgroups.get(sgid).visel.boundingBox : null;
				if(util.isNull(bba))
					return; // TODO: use object box instead
				bba = bba.translate((render.offset || new util.Vec2()).negated()).transform(render.scaled2obj, render);
				tl = Math.max(tl, util.Vec2.shiftRayBox(cl0, dl, bba));
				tr = Math.max(tr, util.Vec2.shiftRayBox(cr0, dr, bba));
				tt = Math.max(tt, util.Vec2.shiftRayBox(cc, dt, bba));
				tb = Math.max(tb, util.Vec2.shiftRayBox(cc, db, bba));
			}, this);
			tl = Math.max(tl + 0.2, 0);
			tr = Math.max(tr + 0.2, 0);
			tt = Math.max(Math.max(tt, tb) + 0.1, 0);
			var bracketWidth = 0.25,
				bracketHeight = 1.5 + tt;
			brackets.push(new bracketParams(cl0.addScaled(dl, tl), dl, bracketWidth, bracketHeight),
				new bracketParams(cr0.addScaled(dr, tr), dr, bracketWidth, bracketHeight));
		})();

	}
	else
	{
		(function ()
		{
			for(var i = 0; i < xbonds.length; ++i)
			{
				var b = mol.bonds.get(xbonds[i]);
				var c = b.getCenter(mol);
				var d = util.Set.contains(atomSet, b.begin) ? b.getDir(mol) : b.getDir(mol).negated();
				brackets.push(new bracketParams(c, d, 0.2, 1.0));
			}
		})();
	}
	return brackets;
};

chem.SGroup.getObjBBox = function (atoms, mol)
{
	if(atoms.length == 0)
		throw new Error("Atom list is empty");

	var a0 = mol.atoms.get(atoms[0]).pp;
	var bb = new util.Box2Abs(a0, a0);
	for(var i = 1; i < atoms.length; ++i)
	{
		var aid = atoms[i];
		var atom = mol.atoms.get(aid);
		var p = atom.pp;
		bb = bb.include(p);
	}
	return bb;
};

chem.SGroup.makeAtomBondLines = function (prefix, idstr, ids, map)
{
	if(!ids)
		return [];
	var lines = [];
	for(var i = 0; i < Math.floor((ids.length + 14) / 15); ++i)
	{
		var rem = Math.min(ids.length - 15 * i, 15);
		var salLine = 'M  ' + prefix + ' ' + idstr + ' ' + util.paddedInt(rem, 2);
		for(var j = 0; j < rem; ++j)
		{
			salLine += ' ' + util.paddedInt(map[ids[i * 15 + j]], 3);
		}
		lines.push(salLine);
	}
	return lines;
};

chem.SGroup.getAtoms = function (mol, sg)
{
	if(!sg.allAtoms)
		return sg.atoms;
	var atoms = [];
	mol.atoms.each(function (aid)
	{
		atoms.push(aid);
	});
	return atoms;
};

chem.SGroup.getBonds = function (mol, sg)
{
	var atoms = chem.SGroup.getAtoms(mol, sg);
	var bonds = [];
	mol.bonds.each(function (bid, bond)
	{
		if(atoms.indexOf(bond.begin) >= 0 && atoms.indexOf(bond.end) >= 0) bonds.push(bid);
	});
	return bonds;
};

chem.SGroup.GroupMul = {
	draw: function (remol)
	{
		var render = remol.render;
		var set = render.paper.set();
		var inBonds = [],
			xBonds = [];
		var atomSet = util.Set.fromList(this.atoms);
		chem.SGroup.getCrossBonds(inBonds, xBonds, remol.molecule, atomSet);
		chem.SGroup.bracketPos(this, render, remol.molecule, xBonds);
		var bb = this.bracketBox;
		var d = this.bracketDir,
			n = d.rotateSC(1, 0);
		this.areas = [bb];
		chem.SGroup.drawBrackets(set, render, this, xBonds, atomSet, bb, d, n, this.data.mul);
		return set;
	},

	saveToMolfile: function (mol, sgMap, atomMap, bondMap)
	{
		var idstr = util.stringPadded(sgMap[this.id], 3);

		var lines = [];
		lines = lines.concat(chem.SGroup.makeAtomBondLines('SAL', idstr, util.idList(this.atomSet), atomMap)); // TODO: check atomSet
		lines = lines.concat(chem.SGroup.makeAtomBondLines('SPA', idstr, util.idList(this.parentAtomSet), atomMap));
		lines = lines.concat(chem.SGroup.makeAtomBondLines('SBL', idstr, this.bonds, bondMap));
		var smtLine = 'M  SMT ' + idstr + ' ' + this.data.mul;
		lines.push(smtLine);
		lines = lines.concat(chem.SGroup.bracketsToMolfile(mol, this, idstr));
		return lines.join('\n');
	},

	prepareForSaving: function (mol)
	{
		var j;
		this.atoms.sort();
		this.atomSet = util.Set.fromList(this.atoms);
		this.parentAtomSet = util.Set.clone(this.atomSet);
		var inBonds = [];
		var xBonds = [];

		mol.bonds.each(function (bid, bond)
		{
			if(util.Set.contains(this.parentAtomSet, bond.begin) && util.Set.contains(this.parentAtomSet, bond.end))
				inBonds.push(bid);
			else if(util.Set.contains(this.parentAtomSet, bond.begin) || util.Set.contains(this.parentAtomSet, bond.end))
				xBonds.push(bid);
		}, this);
		if(xBonds.length != 0 && xBonds.length != 2)
			throw {
				'id': this.id,
				'error-type': 'cross-bond-number',
				'message': "Unsupported cross-bonds number"
			};

		var xAtom1 = -1,
			xAtom2 = -1;
		var crossBond = null;
		if(xBonds.length == 2)
		{
			var bond1 = mol.bonds.get(xBonds[0]);
			if(util.Set.contains(this.parentAtomSet, bond1.begin))
			{
				xAtom1 = bond1.begin;
			}
			else
			{
				xAtom1 = bond1.end;
			}
			var bond2 = mol.bonds.get(xBonds[1]);
			if(util.Set.contains(this.parentAtomSet, bond2.begin))
			{
				xAtom2 = bond2.begin;
			}
			else
			{
				xAtom2 = bond2.end;
			}
			crossBond = bond2;
		}

		var amap = null;
		var tailAtom = xAtom1;

		var newAtoms = [];
		for(j = 0; j < this.data.mul - 1; ++j)
		{
			amap = {};
			util.each(this.atoms, function (aid)
			{
				var atom = mol.atoms.get(aid);
				var aid2 = mol.atoms.add(new chem.Struct.Atom(atom));
				newAtoms.push(aid2);
				this.atomSet[aid2] = 1;
				amap[aid] = aid2;
			}, this);
			util.each(inBonds, function (bid)
			{
				var bond = mol.bonds.get(bid);
				var newBond = new chem.Struct.Bond(bond);
				newBond.begin = amap[newBond.begin];
				newBond.end = amap[newBond.end];
				mol.bonds.add(newBond);
			}, this);
			if(crossBond != null)
			{
				var newCrossBond = new chem.Struct.Bond(crossBond);
				newCrossBond.begin = tailAtom;
				newCrossBond.end = amap[xAtom2];
				mol.bonds.add(newCrossBond);
				tailAtom = amap[xAtom1];
			}
		}

		util.each(newAtoms, function (aid)
		{
			util.each(mol.sGroupForest.getPathToRoot(this.id).reverse(), function (sgid)
			{
				mol.atomAddToSGroup(sgid, aid);
			}, this);
		}, this);
		if(tailAtom >= 0)
		{
			var xBond2 = mol.bonds.get(xBonds[0]);
			if(xBond2.begin == xAtom1)
				xBond2.begin = tailAtom;
			else
				xBond2.end = tailAtom;
		}

		this.bonds = xBonds;
	},

	postLoad: function (mol, atomMap)
	{
		this.data.mul = this.data.subscript - 0;
		var atomReductionMap = {};

		this.atoms = chem.SGroup.filterAtoms(this.atoms, atomMap);
		this.patoms = chem.SGroup.filterAtoms(this.patoms, atomMap);

		// mark repetitions for removal
		for(var k = 1; k < this.data.mul; ++k)
		{
			for(var m = 0; m < this.patoms.length; ++m)
			{
				var raid = this.atoms[k * this.patoms.length + m];
				if(raid < 0)
					continue;
				if(this.patoms[m] < 0)
				{
					throw new Error("parent atom missing");
				}
				//                mol.atoms.get(raid).pp.y -= 3*k; // for debugging purposes
				atomReductionMap[raid] = this.patoms[m]; // "merge" atom in parent
			}
		}
		this.patoms = chem.SGroup.removeNegative(this.patoms);

		var patomsMap = util.identityMap(this.patoms);

		var bondsToRemove = [];
		mol.bonds.each(function (bid, bond)
		{
			var beginIn = bond.begin in atomReductionMap;
			var endIn = bond.end in atomReductionMap;
			// if both adjacent atoms of a bond are to be merged, remove it
			if(beginIn && endIn || beginIn && bond.end in patomsMap || endIn && bond.begin in patomsMap)
			{
				bondsToRemove.push(bid);
				// if just one atom is merged, modify the bond accordingly
			}
			else if(beginIn)
			{
				bond.begin = atomReductionMap[bond.begin];
			}
			else if(endIn)
			{
				bond.end = atomReductionMap[bond.end];
			}
		}, this);

		// apply removal lists
		for(var b = 0; b < bondsToRemove.length; ++b)
		{
			mol.bonds.remove(bondsToRemove[b]);
		}
		for(var a in atomReductionMap)
		{
			mol.atoms.remove(a);
			atomMap[a] = -1;
		}
		this.atoms = this.patoms;
		this.patoms = null;
	}
};

chem.SGroup.GroupSru = {
	draw: function (remol)
	{
		var render = remol.render;
		var set = render.paper.set();
		var inBonds = [],
			xBonds = [];
		var atomSet = util.Set.fromList(this.atoms);
		chem.SGroup.getCrossBonds(inBonds, xBonds, remol.molecule, atomSet);
		chem.SGroup.bracketPos(this, render, remol.molecule, xBonds);
		var bb = this.bracketBox;
		var d = this.bracketDir,
			n = d.rotateSC(1, 0);
		this.areas = [bb];
		var connectivity = this.data.connectivity || 'eu';
		if(connectivity == 'ht')
			connectivity = '';
		var subscript = this.data.subscript || 'n';
		chem.SGroup.drawBrackets(set, render, this, xBonds, atomSet, bb, d, n, subscript, connectivity);
		return set;
	},

	saveToMolfile: function (mol, sgMap, atomMap, bondMap)
	{
		var idstr = util.stringPadded(sgMap[this.id], 3);

		var lines = [];
		lines = lines.concat(chem.SGroup.makeAtomBondLines('SAL', idstr, this.atoms, atomMap));
		lines = lines.concat(chem.SGroup.makeAtomBondLines('SBL', idstr, this.bonds, bondMap));
		lines = lines.concat(chem.SGroup.bracketsToMolfile(mol, this, idstr));
		return lines.join('\n');
	},

	prepareForSaving: function (mol)
	{
		var xBonds = [];
		mol.bonds.each(function (bid, bond)
		{
			var a1 = mol.atoms.get(bond.begin);
			var a2 = mol.atoms.get(bond.end);
			if(util.Set.contains(a1.sgs, this.id) && !util.Set.contains(a2.sgs, this.id) ||
				util.Set.contains(a2.sgs, this.id) && !util.Set.contains(a1.sgs, this.id))
				xBonds.push(bid);
		}, this);
		if(xBonds.length != 0 && xBonds.length != 2)
			throw {
				'id': this.id,
				'error-type': 'cross-bond-number',
				'message': "Unsupported cross-bonds number"
			};
		this.bonds = xBonds;
	},

	postLoad: function (mol, atomMap)
	{
		this.data.connectivity = (this.data.connectivity || 'EU').strip().toLowerCase();
	}
};

chem.SGroup.GroupSup = {
	draw: function (remol)
	{
		var render = remol.render;
		var set = render.paper.set();
		var inBonds = [],
			xBonds = [];
		var atomSet = util.Set.fromList(this.atoms);
		chem.SGroup.getCrossBonds(inBonds, xBonds, remol.molecule, atomSet);
		chem.SGroup.bracketPos(this, render, remol.molecule, xBonds);
		var bb = this.bracketBox;
		var d = this.bracketDir,
			n = d.rotateSC(1, 0);
		this.areas = [bb];
		chem.SGroup.drawBrackets(set, render, this, xBonds, atomSet, bb, d, n, this.data.name, null,
		{
			'font-style': 'italic'
		});
		return set;
	},

	saveToMolfile: function (mol, sgMap, atomMap, bondMap)
	{
		var idstr = util.stringPadded(sgMap[this.id], 3);

		var lines = [];
		lines = lines.concat(chem.SGroup.makeAtomBondLines('SAL', idstr, this.atoms, atomMap));
		lines = lines.concat(chem.SGroup.makeAtomBondLines('SBL', idstr, this.bonds, bondMap));
		if(this.data.name && this.data.name != '')
			lines.push('M  SMT ' + idstr + ' ' + this.data.name);
		return lines.join('\n');
	},

	prepareForSaving: function (mol)
	{
		// This code is also used for GroupSru and should be moved into a separate common method
		// It seems that such code should be used for any sgroup by this this should be checked
		var xBonds = [];
		mol.bonds.each(function (bid, bond)
		{
			var a1 = mol.atoms.get(bond.begin);
			var a2 = mol.atoms.get(bond.end);
			if(util.Set.contains(a1.sgs, this.id) && !util.Set.contains(a2.sgs, this.id) ||
				util.Set.contains(a2.sgs, this.id) && !util.Set.contains(a1.sgs, this.id))
				xBonds.push(bid);
		}, this);
		this.bonds = xBonds;
	},

	postLoad: function (mol, atomMap)
	{
		this.data.name = (this.data.subscript || '').strip();
		this.data.subscript = '';
	}
};

chem.SGroup.GroupGen = {
	draw: function (remol)
	{
		var render = remol.render;
		var settings = render.settings;
		var styles = render.styles;
		var paper = render.paper;
		var set = paper.set();
		var inBonds = [],
			xBonds = [];
		var atomSet = util.Set.fromList(this.atoms);
		chem.SGroup.getCrossBonds(inBonds, xBonds, remol.molecule, atomSet);
		chem.SGroup.bracketPos(this, render, remol.molecule, xBonds);
		var bb = this.bracketBox;
		var d = this.bracketDir,
			n = d.rotateSC(1, 0);
		this.areas = [bb];
		chem.SGroup.drawBrackets(set, render, this, xBonds, atomSet, bb, d, n);
		return set;
	},

	saveToMolfile: function (mol, sgMap, atomMap, bondMap)
	{
		var idstr = util.stringPadded(sgMap[this.id], 3);

		var lines = [];
		lines = lines.concat(chem.SGroup.makeAtomBondLines('SAL', idstr, this.atoms, atomMap));
		lines = lines.concat(chem.SGroup.makeAtomBondLines('SBL', idstr, this.bonds, bondMap));
		lines = lines.concat(chem.SGroup.bracketsToMolfile(mol, this, idstr));
		return lines.join('\n');
	},

	prepareForSaving: function (mol) {},

	postLoad: function (mol, atomMap) {}
};

chem.SGroup.getMassCentre = function (mol, atoms)
{
	var c = new util.Vec2(); // mass centre
	for(var i = 0; i < atoms.length; ++i)
	{
		c = c.addScaled(mol.atoms.get(atoms[i]).pp, 1.0 / atoms.length);
	}
	return c;
};

chem.SGroup.setPos = function (remol, sg, pos)
{
	sg.pp = pos;
};

chem.SGroup.GroupDat = {
	showValue: function (paper, pos, sg, settings)
	{
		var name = paper.text(pos.x, pos.y, sg.data.fieldValue)
			.attr(
			{
				'font': settings.font,
				'font-size': settings.fontsz
			});
		return name;
	},

	draw: function (remol)
	{
		var render = remol.render;
		var settings = render.settings;
		var paper = render.paper;
		var set = paper.set();
		var atoms = chem.SGroup.getAtoms(remol, this);
		var i;
		chem.SGroup.bracketPos(this, render, remol.molecule);
		this.areas = this.bracketBox ? [this.bracketBox] : [];
		if(this.pp == null)
		{
			// NB: we did not pass xbonds parameter to the backetPos method above,
			//  so the result will be in the regular coordinate system
			chem.SGroup.setPos(remol, this, this.bracketBox.p1.add(new util.Vec2(0.5, 0.5)));
		}
		var ps = this.pp.scaled(settings.scaleFactor);

		if(this.data.attached)
		{
			for(i = 0; i < atoms.length; ++i)
			{
				var atom = remol.atoms.get(atoms[i]);
				var p = render.ps(atom.a.pp);
				var bb = atom.visel.boundingBox;
				if(bb != null)
				{
					p.x = Math.max(p.x, bb.p1.x);
				}
				p.x += settings.lineWidth; // shift a bit to the right
				var name_i = this.showValue(paper, p, this, settings);
				var box_i = rnd.relBox(name_i.getBBox());
				name_i.translateAbs(0.5 * box_i.width, -0.3 * box_i.height);
				set.push(name_i);
				var sbox_i = util.Box2Abs.fromRelBox(rnd.relBox(name_i.getBBox()));
				sbox_i = sbox_i.transform(render.scaled2obj, render);
				this.areas.push(sbox_i);
			}
		}
		else
		{
			var name = this.showValue(paper, ps, this, settings);
			var box = rnd.relBox(name.getBBox());
			name.translateAbs(0.5 * box.width, -0.5 * box.height);
			set.push(name);
			var sbox = util.Box2Abs.fromRelBox(rnd.relBox(name.getBBox()));
			this.dataArea = sbox.transform(render.scaled2obj, render);
			if(!remol.sgroupData.has(this.id))
				remol.sgroupData.set(this.id, new rnd.ReDataSGroupData(this));
		}
		return set;
	},

	saveToMolfile: function (mol, sgMap, atomMap, bondMap)
	{
		var idstr = util.stringPadded(sgMap[this.id], 3);

		var data = this.data;
		var pp = this.pp;
		if(!data.absolute)
			pp = pp.sub(chem.SGroup.getMassCentre(mol, this.atoms));
		var lines = [];
		lines = lines.concat(chem.SGroup.makeAtomBondLines('SAL', idstr, this.atoms, atomMap));
		var sdtLine = 'M  SDT ' + idstr +
			' ' + util.stringPadded(data.fieldName, 30, true) +
			util.stringPadded(data.fieldType, 2) +
			util.stringPadded(data.units, 20, true) +
			util.stringPadded(data.query, 2) +
			util.stringPadded(data.queryOp, 3);
		lines.push(sdtLine);
		var sddLine = 'M  SDD ' + idstr +
			' ' + util.paddedFloat(pp.x, 10, 4) + util.paddedFloat(-pp.y, 10, 4) +
			'    ' + // ' eee'
			(data.attached ? 'A' : 'D') + // f
			(data.absolute ? 'A' : 'R') + // g
			(data.showUnits ? 'U' : ' ') + // h
			'   ' + //  i
			(data.nCharnCharsToDisplay >= 0 ? util.paddedInt(data.nCharnCharsToDisplay, 3) : 'ALL') + // jjj
			'  1   ' + // 'kkk ll '
			util.stringPadded(data.tagChar, 1) + // m
			'  ' + util.paddedInt(data.daspPos, 1) + // n
			'  '; // oo
		lines.push(sddLine);
		data.fieldValue.replace(/[\r\n|\n|\r]*$/, '').split(/\r\n|\n|\r/).each(function (str)
		{
			var charsPerLine = 69;
			while(str.length > charsPerLine)
			{
				lines.push('M  SCD ' + idstr + ' ' + str.slice(0, charsPerLine));
				str = str.slice(69);
			}
			lines.push('M  SED ' + idstr + ' ' + util.stringPadded(str, charsPerLine, true));
		}, this);
		return lines.join('\n');
	},

	prepareForSaving: function (mol)
	{
		this.atoms = chem.SGroup.getAtoms(mol, this);
	},

	postLoad: function (mol, atomMap)
	{
		var allAtomsInGroup = this.atoms.length == mol.atoms.count();
		if(!this.data.absolute)
			this.pp = this.pp.add(chem.SGroup.getMassCentre(mol, this.atoms));
		if(allAtomsInGroup &&
			(this.data.fieldName == 'MDLBG_FRAGMENT_STEREO' ||
				this.data.fieldName == 'MDLBG_FRAGMENT_COEFFICIENT' ||
				this.data.fieldName == 'MDLBG_FRAGMENT_CHARGE'))
		{
			this.atoms = [];
			this.allAtoms = true;
		}
	}
};

chem.SGroup.TYPES = {
	'MUL': chem.SGroup.GroupMul,
	'SRU': chem.SGroup.GroupSru,
	'SUP': chem.SGroup.GroupSup,
	'DAT': chem.SGroup.GroupDat,
	'GEN': chem.SGroup.GroupGen
};


chem.SGroupForest = function (molecule)
{
	this.parent = new util.Map(); // child id -> parent id
	this.children = new util.Map(); // parent id -> list of child ids
	this.children.set(-1, []); // extra root node
	this.molecule = molecule;
}

// returns an array or s-group ids in the order of breadth-first search
chem.SGroupForest.prototype.getSGroupsBFS = function ()
{
	var order = [],
		queue = [],
		id = -1;
	queue = util.array(this.children.get(-1));
	while(queue.length > 0)
	{
		var id = queue.shift();
		queue = queue.concat(this.children.get(id));
		order.push(id);
	}
	return order;
}

chem.SGroupForest.prototype.getAtomSets = function ()
{
	return this.molecule.sgroups.map(function (sgid, sgroup)
	{
		return util.Set.fromList(sgroup.atoms);
	});
}

chem.SGroupForest.prototype.getAtomSetRelations = function (newId, atoms /* util.Set */ , atomSets /* util.Map of util.Set */ )
{
	// find the lowest superset in the hierarchy
	var isStrictSuperset = new util.Map(),
		isSubset = new util.Map();
	var atomSets = this.getAtomSets();
	atomSets.unset(newId);
	atomSets.each(function (id, atomSet)
	{
		isSubset.set(id, util.Set.subset(atoms, atomSet));
		isStrictSuperset.set(id, util.Set.subset(atomSet, atoms) && !util.Set.eq(atomSet, atoms));
	}, this);
	var parents = atomSets.findAll(function (id)
	{
		if(!isSubset.get(id))
			return false;
		if(util.find(this.children.get(id), function (childId)
		{
			return isSubset.get(childId);
		}, this) >= 0)
		{
			return false;
		}
		return true;
	}, this);
	util.assert(parents.length <= 1); // there should be only one parent
	var children = atomSets.findAll(function (id, set)
	{
		return isStrictSuperset.get(id) && !isStrictSuperset.get(this.parent.get(id));
	}, this);
	return {
		'children': children,
		'parent': parents.length === 0 ? -1 : parents[0]
	};
}

chem.SGroupForest.prototype.getPathToRoot = function (sgid)
{
	var path = [];
	for(var id = sgid; id >= 0; id = this.parent.get(id))
	{
		util.assert(path.indexOf(id) < 0, "SGroupForest: loop detected");
		path.push(id);
	}
	return path;
}

chem.SGroupForest.prototype.validate = function ()
{
	var atomSets = this.getAtomSets();
	this.molecule.sgroups.each(function (id)
	{
		this.getPathToRoot(id); // this will throw an exception if there is a loop in the path to root
	}, this);

	var valid = true;
	// 1) child group's atom set is a subset of the parent one's
	this.parent.each(function (id, parentId)
	{
		if(parentId >= 0 && !util.Set.subset(atomSets.get(id), atomSets.get(parentId)))
			valid = false;
	}, this);

	// 2) siblings have disjoint atom sets
	this.children.each(function (parentId)
	{
		var list = this.children.get(parentId);
		for(var i = 0; i < list.length; ++i)
			for(var j = i + 1; j < list.length; ++j)
				if(!util.Set.disjoint(atomSets.get(list[i]), atomSets.get(list[j])))
					valid = false;
	}, this);
	return valid;
}

chem.SGroupForest.prototype.insert = function (id, parent /* int, optional */ , children /* [int], optional */ )
{
	util.assert(!this.parent.has(id), "sgid already present in the forest");
	util.assert(!this.children.has(id), "sgid already present in the forest");

	util.assert(this.validate(), "s-group forest invalid");
	var atomSets = this.getAtomSets();
	var atoms = util.Set.fromList(this.molecule.sgroups.get(id).atoms);
	if(util.isUndefined(parent) || util.isUndefined(children))
	{ // if these are not provided, deduce automatically
		var guess = this.getAtomSetRelations(id, atoms, atomSets);
		parent = guess.parent;
		children = guess.children;
	}

	// TODO: make children Map<int, Set> instead of Map<int, []>?
	util.each(children, function (childId)
	{ // reset parent links
		util.assert(util.arrayRemoveByValue(this.children.get(this.parent.get(childId)), childId) === 1);
		this.parent.set(childId, id);
	}, this);
	this.children.set(id, children);
	this.parent.set(id, parent);
	this.children.get(parent).push(id);
	util.assert(this.validate(), "s-group forest invalid");
	return {
		parent: parent,
		children: children
	};
}

chem.SGroupForest.prototype.remove = function (id)
{
	util.assert(this.parent.has(id), "sgid is not in the forest");
	util.assert(this.children.has(id), "sgid is not in the forest");

	util.assert(this.validate(), "s-group forest invalid");
	var parentId = this.parent.get(id);
	util.each(this.children.get(id), function (childId)
	{ // reset parent links
		this.parent.set(childId, parentId);
		this.children.get(parentId).push(childId);
	}, this);
	util.assert(util.arrayRemoveByValue(this.children.get(parentId), id) === 1);
	this.children.unset(id);
	this.parent.unset(id);
	util.assert(this.validate(), "s-group forest invalid");
}
/****************************************************************************
 * Copyright (C) 2009-2010 GGA Software Services LLC
 *
 * This file may be distributed and/or modified under the terms of the
 * GNU Affero General Public License version 3 as published by the Free
 * Software Foundation and appearing in the file LICENSE.GPL included in
 * the packaging of this file.
 *
 * This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
 * WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ***************************************************************************/

if(!window.chem || !chem.Struct)
	throw new Error("Include MolData.js first");

chem.Struct.prototype.calcConn = function (aid)
{
	var conn = 0;
	var atom = this.atoms.get(aid);
	var hasAromatic = false;
	for(var i = 0; i < atom.neighbors.length; ++i)
	{
		var hb = this.halfBonds.get(atom.neighbors[i]);
		var bond = this.bonds.get(hb.bid);
		switch(bond.type)
		{
		case chem.Struct.BOND.TYPE.SINGLE:
			conn += 1;
			break;
		case chem.Struct.BOND.TYPE.DOUBLE:
			conn += 2;
			break;
		case chem.Struct.BOND.TYPE.TRIPLE:
			conn += 3;
			break;
		case chem.Struct.BOND.TYPE.AROMATIC:
			conn += 1;
			hasAromatic = true;
			break;
		default:
			return -1;
		}
	}
	if(hasAromatic)
		conn += 1;
	return conn;
};

chem.Struct.Atom.prototype.calcValence = function (conn)
{
	var atom = this;
	var charge = atom.charge;
	var label = atom.label;
	if(atom.isQuery())
	{
		this.implicitH = 0;
		return true;
	}
	var elem = chem.Element.getElementByLabel(label);
	if(elem == null)
	{
		this.implicitH = 0;
		return true;
	}

	var groupno = chem.Element.elements.get(elem).group;
	var rad = chem.Struct.radicalElectrons(atom.radical);

	var valence = conn;
	var hyd = 0;
	var absCharge = Math.abs(charge);

	if(groupno == 1)
	{
		if(label == 'H' ||
			label == 'Li' || label == 'Na' || label == 'K' ||
			label == 'Rb' || label == 'Cs' || label == 'Fr')
		{
			valence = 1;
			hyd = 1 - rad - conn - absCharge;
		}
	}
	else if(groupno == 3)
	{
		if(label == 'B' || label == 'Al' || label == 'Ga' || label == 'In')
		{
			if(charge == -1)
			{
				valence = 4;
				hyd = 4 - rad - conn;
			}
			else
			{
				valence = 3;
				hyd = 3 - rad - conn - absCharge;
			}
		}
		else if(label == 'Tl')
		{
			if(charge == -1)
			{
				if(rad + conn <= 2)
				{
					valence = 2;
					hyd = 2 - rad - conn;
				}
				else
				{
					valence = 4;
					hyd = 4 - rad - conn;
				}
			}
			else if(charge == -2)
			{
				if(rad + conn <= 3)
				{
					valence = 3;
					hyd = 3 - rad - conn;
				}
				else
				{
					valence = 5;
					hyd = 5 - rad - conn;
				}
			}
			else
			{
				if(rad + conn + absCharge <= 1)
				{
					valence = 1;
					hyd = 1 - rad - conn - absCharge;
				}
				else
				{
					valence = 3;
					hyd = 3 - rad - conn - absCharge;
				}
			}
		}
	}
	else if(groupno == 4)
	{
		if(label == 'C' || label == 'Si' || label == 'Ge')
		{
			valence = 4;
			hyd = 4 - rad - conn - absCharge;
		}
		else if(label == 'Sn' || label == 'Pb')
		{
			if(conn + rad + absCharge <= 2)
			{
				valence = 2;
				hyd = 2 - rad - conn - absCharge;
			}
			else
			{
				valence = 4;
				hyd = 4 - rad - conn - absCharge;
			}
		}
	}
	else if(groupno == 5)
	{
		if(label == 'N' || label == 'P')
		{
			if(charge == 1)
			{
				valence = 4;
				hyd = 4 - rad - conn;
			}
			else if(charge == 2)
			{
				valence = 3;
				hyd = 3 - rad - conn;
			}
			else
			{
				if(label == 'N' || rad + conn + absCharge <= 3)
				{
					valence = 3;
					hyd = 3 - rad - conn - absCharge;
				}
				else // ELEM_P && rad + conn + absCharge > 3
				{
					valence = 5;
					hyd = 5 - rad - conn - absCharge;
				}
			}
		}
		else if(label == 'Bi' || label == 'Sb' || label == 'As')
		{
			if(charge == 1)
			{
				if(rad + conn <= 2 && label != 'As')
				{
					valence = 2;
					hyd = 2 - rad - conn;
				}
				else
				{
					valence = 4;
					hyd = 4 - rad - conn;
				}
			}
			else if(charge == 2)
			{
				valence = 3;
				hyd = 3 - rad - conn;
			}
			else
			{
				if(rad + conn <= 3)
				{
					valence = 3;
					hyd = 3 - rad - conn - absCharge;
				}
				else
				{
					valence = 5;
					hyd = 5 - rad - conn - absCharge;
				}
			}
		}
	}
	else if(groupno == 6)
	{
		if(label == 'O')
		{
			if(charge >= 1)
			{
				valence = 3;
				hyd = 3 - rad - conn;
			}
			else
			{
				valence = 2;
				hyd = 2 - rad - conn - absCharge;
			}
		}
		else if(label == 'S' || label == 'Se' || label == 'Po')
		{
			if(charge == 1)
			{
				if(conn <= 3)
				{
					valence = 3;
					hyd = 3 - rad - conn;
				}
				else
				{
					valence = 5;
					hyd = 5 - rad - conn;
				}
			}
			else
			{
				if(conn + rad + absCharge <= 2)
				{
					valence = 2;
					hyd = 2 - rad - conn - absCharge;
				}
				else if(conn + rad + absCharge <= 4)
				// See examples in PubChem
				// [S] : CID 16684216
				// [Se]: CID 5242252
				// [Po]: no example, just following ISIS/Draw logic here
				{
					valence = 4;
					hyd = 4 - rad - conn - absCharge;
				}
				else
				// See examples in PubChem
				// [S] : CID 46937044
				// [Se]: CID 59786
				// [Po]: no example, just following ISIS/Draw logic here
				{
					valence = 6;
					hyd = 6 - rad - conn - absCharge;
				}
			}
		}
		else if(label == 'Te')
		{
			if(charge == -1)
			{
				if(conn <= 2)
				{
					valence = 2;
					hyd = 2 - rad - conn - absCharge;
				}
			}
			else if(charge == 0 || charge == 2)
			{
				if(conn <= 2)
				{
					valence = 2;
					hyd = 2 - rad - conn - absCharge;
				}
				else if(conn <= 4)
				{
					valence = 4;
					hyd = 4 - rad - conn - absCharge;
				}
				else if(charge == 0 && conn <= 6)
				{
					valence = 6;
					hyd = 6 - rad - conn - absCharge;
				}
				else
					hyd = -1;
			}
		}
	}
	else if(groupno == 7)
	{
		if(label == 'F')
		{
			valence = 1;
			hyd = 1 - rad - conn - absCharge;
		}
		else if(label == 'Cl' || label == 'Br' ||
			label == 'I' || label == 'At')
		{
			if(charge == 1)
			{
				if(conn <= 2)
				{
					valence = 2;
					hyd = 2 - rad - conn;
				}
				else if(conn == 3 || conn == 5 || conn >= 7)
					hyd = -1;
			}
			else if(charge == 0)
			{
				if(conn <= 1)
				{
					valence = 1;
					hyd = 1 - rad - conn;
				}
				// While the halogens can have valence 3, they can not have
				// hydrogens in that case.
				else if(conn == 2 || conn == 4 || conn == 6)
				{
					if(rad == 1)
					{
						valence = conn;
						hyd = 0;
					}
					else
						hyd = -1; // will throw an error in the end
				}
				else if(conn > 7)
					hyd = -1; // will throw an error in the end
			}
		}
	}

	this.valence = valence;
	this.implicitH = hyd;
	if(this.implicitH < 0)
	{
		this.valence = conn;
		this.implicitH = 0;
		this.badConn = true;
		return false;
	}
	return true;
};

chem.Struct.Atom.prototype.calcValenceMinusHyd = function (conn)
{
	var atom = this;
	var charge = atom.charge;
	var label = atom.label;
	var elem = chem.Element.getElementByLabel(label);
	if(elem == null)
		throw new Error("Element " + label + " unknown");
	if(elem < 0)
	{ // query atom, skip
		this.implicitH = 0;
		return null;
	}

	var groupno = chem.Element.elements.get(elem).group;
	var rad = chem.Struct.radicalElectrons(atom.radical);

	if(groupno == 3)
	{
		if(label == 'B' || label == 'Al' || label == 'Ga' || label == 'In')
		{
			if(charge == -1)
				if(rad + conn <= 4)
					return rad + conn;
		}
	}
	else if(groupno == 5)
	{
		if(label == 'N' || label == 'P')
		{
			if(charge == 1)
				return rad + conn;
			if(charge == 2)
				return rad + conn;
		}
		else if(label == 'Sb' || label == 'Bi' || label == 'As')
		{
			if(charge == 1)
				return rad + conn;
			else if(charge == 2)
				return rad + conn;
		}
	}
	else if(groupno == 6)
	{
		if(label == 'O')
		{
			if(charge >= 1)
				return rad + conn;
		}
		else if(label == 'S' || label == 'Se' || label == 'Po')
		{
			if(charge == 1)
				return rad + conn;
		}
	}
	else if(groupno == 7)
	{
		if(label == 'Cl' || label == 'Br' ||
			label == 'I' || label == 'At')
		{
			if(charge == 1)
				return rad + conn;
		}
	}

	return rad + conn + Math.abs(charge);
};

chem.Struct.prototype.calcImplicitHydrogen = function (aid)
{
	var conn = this.calcConn(aid);
	var atom = this.atoms.get(aid);
	atom.badConn = false;
	if(conn < 0 || atom.isQuery())
	{
		atom.implicitH = 0;
		return;
	}
	if(atom.explicitValence >= 0)
	{
		var elem = chem.Element.getElementByLabel(atom.label);
		atom.implicitH = 0;
		if(elem != null)
		{
			atom.implicitH = atom.explicitValence - atom.calcValenceMinusHyd(conn);
			if(atom.implicitH < 0)
			{
				atom.implicitH = 0;
				atom.badConn = true;
			}
		}
	}
	else
	{
		atom.calcValence(conn);
	}
};
/****************************************************************************
 * Copyright (C) 2009-2010 GGA Software Services LLC
 *
 * This file may be distributed and/or modified under the terms of the
 * GNU Affero General Public License version 3 as published by the Free
 * Software Foundation and appearing in the file LICENSE.GPL included in
 * the packaging of this file.
 *
 * This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
 * WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ***************************************************************************/

if(!window.chem || !chem.Struct)
	throw new Error("Molecule should be defined first");

chem.Dfs = function (mol, atom_data, components, nReactants)
{
	this.molecule = mol;
	this.atom_data = atom_data;
	this.components = components;
	this.nComponentsInReactants = -1;
	this.nReactants = nReactants;

	this.vertices = new Array(this.molecule.atoms.count()); // Minimum size
	this.molecule.atoms.each(function (aid)
	{
		this.vertices[aid] = new chem.Dfs.VertexDesc();
	}, this);

	this.edges = new Array(this.molecule.bonds.count()); // Minimum size
	this.molecule.bonds.each(function (bid)
	{
		this.edges[bid] = new chem.Dfs.EdgeDesc();
	}, this);

	this.v_seq = new Array();
};

chem.Dfs.VertexDesc = function ()
{
	this.dfs_state = 0; // 0 -- not on stack
	// 1 -- on stack
	// 2 -- removed from stack
	this.parent_vertex = 0; // parent vertex in DFS tree
	this.parent_edge = 0; // edge to parent vertex
	this.branches = 0; // how many DFS branches go out from this vertex}
};

chem.Dfs.EdgeDesc = function ()
{
	this.opening_cycles = 0; // how many cycles are
	// (i) starting with this edge
	// and (ii) ending in this edge's first vertex
	this.closing_cycle = 0; // 1 if this edge closes a cycle
};

chem.Dfs.SeqElem = function (v_idx, par_vertex, par_edge)
{
	this.idx = v_idx; // index of vertex in _graph
	this.parent_vertex = par_vertex; // parent vertex in DFS tree
	this.parent_edge = par_edge; // edge to parent vertex
};

chem.Dfs.prototype.walk = function ()
{
	var v_stack = new Array();
	var i, j;
	var cid = 0;
	var component = 0;

	while(true)
	{
		if(v_stack.length < 1)
		{
			var selected = -1;

			var findFunc = function (aid)
			{
				if(this.vertices[aid].dfs_state == 0)
				{
					selected = aid;
					return true;
				}
				return false;
			};

			while(cid < this.components.length && selected == -1)
			{
				selected = util.Set.find(this.components[cid], findFunc, this);
				if(selected === null)
				{
					selected = -1;
					cid++;
					if(cid == this.nReactants)
					{
						this.nComponentsInReactants = component;
					}
				}
			}
			if(selected < -1)
			{
				this.molecule.atoms.find(findFunc, this);
			}
			if(selected == -1)
				break;
			this.vertices[selected].parent_vertex = -1;
			this.vertices[selected].parent_edge = -1;
			v_stack.push(selected);
			component++;
		}

		var v_idx = v_stack.pop();
		var parent_vertex = this.vertices[v_idx].parent_vertex;

		var seq_elem = new chem.Dfs.SeqElem(v_idx, parent_vertex, this.vertices[v_idx].parent_edge);
		this.v_seq.push(seq_elem);

		this.vertices[v_idx].dfs_state = 2;

		var atom_d = this.atom_data[v_idx];

		for(i = 0; i < atom_d.neighbours.length; i++)
		{
			var nei_idx = atom_d.neighbours[i].aid;
			var edge_idx = atom_d.neighbours[i].bid;

			if(nei_idx == parent_vertex)
				continue;

			if(this.vertices[nei_idx].dfs_state == 2)
			{
				this.edges[edge_idx].closing_cycle = 1;

				j = v_idx;

				while(j != -1)
				{
					if(this.vertices[j].parent_vertex == nei_idx)
						break;
					j = this.vertices[j].parent_vertex;
				}

				if(j == -1)
					throw new Error("Cycle unwind error");

				this.edges[this.vertices[j].parent_edge].opening_cycles++;
				this.vertices[v_idx].branches++;

				seq_elem = new chem.Dfs.SeqElem(nei_idx, v_idx, edge_idx);
				this.v_seq.push(seq_elem);
			}
			else
			{
				if(this.vertices[nei_idx].dfs_state == 1)
				{
					j = v_stack.indexOf(nei_idx);

					if(j == -1)
						throw new Error("Internal: removing vertex from stack");

					v_stack.splice(j, 1);

					var parent = this.vertices[nei_idx].parent_vertex;

					if(parent >= 0)
						this.vertices[parent].branches--;
				}

				this.vertices[v_idx].branches++;
				this.vertices[nei_idx].parent_vertex = v_idx;
				this.vertices[nei_idx].parent_edge = edge_idx;
				this.vertices[nei_idx].dfs_state = 1;
				v_stack.push(nei_idx);
			}
		}
	}
};

chem.Dfs.prototype.edgeClosingCycle = function (e_idx)
{
	return this.edges[e_idx].closing_cycle != 0;
};

chem.Dfs.prototype.numBranches = function (v_idx)
{
	return this.vertices[v_idx].branches;
};

chem.Dfs.prototype.numOpeningCycles = function (e_idx)
{
	return this.edges[e_idx].opening_cycles;
};

chem.Dfs.prototype.toString = function ()
{
	var str = '';
	this.v_seq.each(function (seq_elem)
	{
		str += seq_elem.idx + ' -> '
	});
	str += '*';
	return str;
};
/****************************************************************************
 * Copyright (C) 2009-2010 GGA Software Services LLC
 *
 * This file may be distributed and/or modified under the terms of the
 * GNU Affero General Public License version 3 as published by the Free
 * Software Foundation and appearing in the file LICENSE.GPL included in
 * the packaging of this file.
 *
 * This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
 * WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ***************************************************************************/

if(!window.chem || !chem.Struct)
	throw new Error("Vec2 and Molecule should be defined first");

chem.CisTrans = function (mol, neighbors_func, context)
{
	this.molecule = mol;
	this.bonds = new util.Map();
	this.getNeighbors = neighbors_func;
	this.context = context;
};

chem.CisTrans.PARITY = {
	NONE: 0,
	CIS: 1,
	TRANS: 2
};

chem.CisTrans.prototype.each = function (func, context)
{
	this.bonds.each(func, context);
};

chem.CisTrans.prototype.getParity = function (idx)
{
	return this.bonds.get(idx).parity;
};

chem.CisTrans.prototype.getSubstituents = function (idx)
{
	return this.bonds.get(idx).substituents;
};

chem.CisTrans.prototype.sameside = function (beg, end, nei_beg, nei_end)
{
	var diff = util.Vec2.diff(beg, end);
	var norm = new util.Vec2(-diff.y, diff.x);

	if(!norm.normalize())
		return 0;

	var norm_beg = util.Vec2.diff(nei_beg, beg);
	var norm_end = util.Vec2.diff(nei_end, end);

	if(!norm_beg.normalize())
		return 0;
	if(!norm_end.normalize())
		return 0;

	var prod_beg = util.Vec2.dot(norm_beg, norm);
	var prod_end = util.Vec2.dot(norm_end, norm);

	if(Math.abs(prod_beg) < 0.001 || Math.abs(prod_end) < 0.001)
		return 0;

	return(prod_beg * prod_end > 0) ? 1 : -1;
};

chem.CisTrans.prototype._sameside = function (i_beg, i_end, i_nei_beg, i_nei_end)
{
	return this.sameside(this.molecule.atoms.get(i_beg).pp, this.molecule.atoms.get(i_end).pp,
		this.molecule.atoms.get(i_nei_beg).pp, this.molecule.atoms.get(i_nei_end).pp);
};

chem.CisTrans.prototype._sortSubstituents = function (substituents)
{
	var h0 = this.molecule.atoms.get(substituents[0]).pureHydrogen();
	var h1 = substituents[1] < 0 || this.molecule.atoms.get(substituents[1]).pureHydrogen();
	var h2 = this.molecule.atoms.get(substituents[2]).pureHydrogen();
	var h3 = substituents[3] < 0 || this.molecule.atoms.get(substituents[3]).pureHydrogen();

	if(h0 && h1)
		return false;
	if(h2 && h3)
		return false;

	if(h1)
		substituents[1] = -1;
	else if(h0)
	{
		substituents[0] = substituents[1];
		substituents[1] = -1;
	}
	else if(substituents[0] > substituents[1])
		substituents.swap(0, 1);

	if(h3)
		substituents[3] = -1;
	else if(h2)
	{
		substituents[2] = substituents[3];
		substituents[3] = -1;
	}
	else if(substituents[2] > substituents[3])
		substituents.swap(2, 3);

	return true;
};

chem.CisTrans.prototype.isGeomStereoBond = function (bond_idx, substituents)
{
	// it must be [C,N,Si]=[C,N,Si] bond

	var bond = this.molecule.bonds.get(bond_idx);

	if(bond.type != chem.Struct.BOND.TYPE.DOUBLE)
		return false;

	var label1 = this.molecule.atoms.get(bond.begin).label;
	var label2 = this.molecule.atoms.get(bond.end).label;

	if(label1 != 'C' && label1 != 'N' && label1 != 'Si' && label1 != 'Ge')
		return false;
	if(label2 != 'C' && label2 != 'N' && label2 != 'Si' && label2 != 'Ge')
		return false;

	// the atoms should have 1 or 2 single bonds
	// (apart from the double bond under consideration)
	var nei_begin = this.getNeighbors.call(this.context, bond.begin);
	var nei_end = this.getNeighbors.call(this.context, bond.end);

	if(nei_begin.length < 2 || nei_begin.length > 3 ||
		nei_end.length < 2 || nei_end.length > 3)
		return false;

	substituents[0] = -1;
	substituents[1] = -1;
	substituents[2] = -1;
	substituents[3] = -1;

	var i;
	var nei;

	for(i = 0; i < nei_begin.length; i++)
	{
		nei = nei_begin[i];

		if(nei.bid == bond_idx)
			continue;

		if(this.molecule.bonds.get(nei.bid).type != chem.Struct.BOND.TYPE.SINGLE)
			return false;

		if(substituents[0] == -1)
			substituents[0] = nei.aid;
		else // (substituents[1] == -1)
			substituents[1] = nei.aid;
	}

	for(i = 0; i < nei_end.length; i++)
	{
		nei = nei_end[i];

		if(nei.bid == bond_idx)
			continue;

		if(this.molecule.bonds.get(nei.bid).type != chem.Struct.BOND.TYPE.SINGLE)
			return false;

		if(substituents[2] == -1)
			substituents[2] = nei.aid;
		else // (substituents[3] == -1)
			substituents[3] = nei.aid;
	}

	if(substituents[1] != -1 && this._sameside(bond.begin, bond.end, substituents[0], substituents[1]) != -1)
		return false;
	if(substituents[3] != -1 && this._sameside(bond.begin, bond.end, substituents[2], substituents[3]) != -1)
		return false;

	return true;
};

chem.CisTrans.prototype.build = function (exclude_bonds)
{
	this.molecule.bonds.each(function (bid, bond)
	{
		var ct = this.bonds.set(bid,
		{
			parity: 0,
			substituents: new Array(4)
		});

		if(util.isArray(exclude_bonds) && exclude_bonds[bid])
			return;

		if(!this.isGeomStereoBond(bid, ct.substituents))
			return;

		/* if(!this._sortSubstituents(ct.substituents))
			return; */

		var sign = this._sameside(bond.begin, bond.end, ct.substituents[0], ct.substituents[2]);

		if(sign == 1)
			ct.parity = chem.CisTrans.PARITY.CIS;
		else if(sign == -1)
			ct.parity = chem.CisTrans.PARITY.TRANS;
	}, this);
};
/****************************************************************************
 * Copyright (C) 2009-2010 GGA Software Services LLC
 *
 * This file may be distributed and/or modified under the terms of the
 * GNU Affero General Public License version 3 as published by the Free
 * Software Foundation and appearing in the file LICENSE.GPL included in
 * the packaging of this file.
 *
 * This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
 * WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ***************************************************************************/

if(!window.chem || !chem.Struct)
	throw new Error("Vec2 and Molecule should be defined first");

chem.Stereocenters = function (mol, neighbors_func, context)
{
	this.molecule = mol;
	this.atoms = new util.Map();
	this.getNeighbors = neighbors_func;
	this.context = context;
};

chem.Stereocenters.prototype.each = function (func, context)
{
	this.atoms.each(func, context);
};

chem.Stereocenters.prototype.buildFromBonds = function ( /*const int *atom_types, const int *atom_groups, const int *bond_orientations, */ ignore_errors)
{
	var atoms = this.molecule.atoms;
	var bonds = this.molecule.bonds;

	// this is a set of atoms that are likely to belong to allene structures and
	//  therefore should not be considered as potential stereocenters in the code below,
	//  as allenes cannot be encoded in the SMILES notation
	var alleneMask = util.Set.empty();
	atoms.each(function (aid, atom)
	{
		var nei_list = this.getNeighbors.call(this.context, aid);
		if(nei_list.length != 2)
			return false;
		var nei1 = nei_list[0];
		var nei2 = nei_list[1];
		// check atom labels
		if(util.find([aid, nei1.aid, nei2.aid], function (aid)
		{
			return ['C', 'Si'].indexOf(atoms.get(aid).label) < 0;
		}, this) >= 0)
			return false;

		// check adjacent bond types
		if(util.find([nei1.bid, nei2.bid], function (bid)
		{
			return bonds.get(bid).type != chem.Struct.BOND.TYPE.DOUBLE;
		}, this) >= 0)
			return false;

		// get the other neighbors of the two adjacent atoms except for the central atom
		var nei1nei = util.findAll(this.getNeighbors.call(this.context, nei1.aid), function (nei)
		{
			return nei.aid != aid;
		}, this);
		var nei2nei = util.findAll(this.getNeighbors.call(this.context, nei2.aid), function (nei)
		{
			return nei.aid != aid;
		}, this);
		if(nei1nei.length < 1 || nei1nei.length > 2 || nei2nei.length < 1 || nei2nei.length > 2)
			return false;

		if(util.find(nei1nei.concat(nei2nei), function (nei)
		{
			return bonds.get(nei.bid).type != chem.Struct.BOND.TYPE.SINGLE;
		}, this) >= 0)
			return false;

		if(util.find(nei1nei.concat(nei2nei), function (nei)
		{
			return bonds.get(nei.bid).stereo == chem.Struct.BOND.STEREO.EITHER;
		}, this) >= 0)
			return false;
		util.Set.add(alleneMask, nei1.aid);
		util.Set.add(alleneMask, nei2.aid);
	}, this);

	if(util.Set.size(alleneMask) > 0)
		throw new Error("This structure may contain allenes, which cannot be represented in the SMILES notation. Relevant stereo-information will be discarded.");

	atoms.each(function (aid)
	{
		if(util.Set.contains(alleneMask, aid))
			return;
		/*
      if (atom_types[atom_idx] == 0)
         continue;
         */
		var nei_list = this.getNeighbors.call(this.context, aid);
		var stereocenter = false;

		util.find(nei_list, function (nei)
		{
			var bond = this.molecule.bonds.get(nei.bid);

			if(bond.type == chem.Struct.BOND.TYPE.SINGLE && bond.begin == aid)
				if(bond.stereo == chem.Struct.BOND.STEREO.UP || bond.stereo == chem.Struct.BOND.STEREO.DOWN)
				{
					stereocenter = true;
					return true;
				}
			return false;
		}, this);

		if(!stereocenter)
			return;

		if(ignore_errors)
		{
			//         try
			//         {
			this._buildOneCenter(aid /*, atom_groups[atom_idx], atom_types[atom_idx], bond_orientations*/ );
			//         }
			//         catch (er)
			//         {
			//         }
		}
		else
			this._buildOneCenter(aid /*, atom_groups[atom_idx], atom_types[atom_idx], bond_orientations*/ );
	}, this);
};

chem.Stereocenters.allowed_stereocenters = [
	{
		elem: 'C',
		charge: 0,
		degree: 3,
		n_double_bonds: 0,
		implicit_degree: 4
	},
	{
		elem: 'C',
		charge: 0,
		degree: 4,
		n_double_bonds: 0,
		implicit_degree: 4
	},
	{
		elem: 'Si',
		charge: 0,
		degree: 3,
		n_double_bonds: 0,
		implicit_degree: 4
	},
	{
		elem: 'Si',
		charge: 0,
		degree: 4,
		n_double_bonds: 0,
		implicit_degree: 4
	},
	{
		elem: 'N',
		charge: 1,
		degree: 3,
		n_double_bonds: 0,
		implicit_degree: 4
	},
	{
		elem: 'N',
		charge: 1,
		degree: 4,
		n_double_bonds: 0,
		implicit_degree: 4
	},
	{
		elem: 'N',
		charge: 0,
		degree: 3,
		n_double_bonds: 0,
		implicit_degree: 3
	},
	{
		elem: 'S',
		charge: 0,
		degree: 4,
		n_double_bonds: 2,
		implicit_degree: 4
	},
	{
		elem: 'S',
		charge: 1,
		degree: 3,
		n_double_bonds: 0,
		implicit_degree: 3
	},
	{
		elem: 'S',
		charge: 0,
		degree: 3,
		n_double_bonds: 1,
		implicit_degree: 3
	},
	{
		elem: 'P',
		charge: 0,
		degree: 3,
		n_double_bonds: 0,
		implicit_degree: 3
	},
	{
		elem: 'P',
		charge: 1,
		degree: 4,
		n_double_bonds: 0,
		implicit_degree: 4
	},
	{
		elem: 'P',
		charge: 0,
		degree: 4,
		n_double_bonds: 1,
		implicit_degree: 4
	}
];


chem.Stereocenters.prototype._buildOneCenter = function (atom_idx /*, int group, int type, const int *bond_orientations*/ )
{
	var atom = this.molecule.atoms.get(atom_idx);

	var nei_list = this.getNeighbors.call(this.context, atom_idx);
	var degree = nei_list.length;
	var implicit_degree = -1;

	var stereocenter = {
		group: 0, // = group;
		type: 0, // = type;
		pyramid: new Array(4)
	};

	var nei_idx = 0;
	var edge_ids = new Array(4);

	var last_atom_dir = 0;
	var n_double_bonds = 0;

	stereocenter.pyramid[0] = -1;
	stereocenter.pyramid[1] = -1;
	stereocenter.pyramid[2] = -1;
	stereocenter.pyramid[3] = -1;

	var n_pure_hydrogens = 0;

	if(degree > 4)
		throw new Error("Stereocenter with " + degree + " bonds are not supported");

	nei_list.each(function (nei)
	{
		var nei_atom = this.molecule.atoms.get(nei.aid);
		var bond = this.molecule.bonds.get(nei.bid);

		edge_ids[nei_idx] = {
			edge_idx: nei.bid,
			nei_idx: nei.aid,
			rank: nei.aid,
			vec: util.Vec2.diff(nei_atom.pp, atom.pp).yComplement()
		};

		if(nei_atom.pureHydrogen())
		{
			n_pure_hydrogens++;
			edge_ids[nei_idx].rank = 10000;
		}
		else if(nei_atom.label == 'H')
			edge_ids[nei_idx].rank = 5000;

		if(!edge_ids[nei_idx].vec.normalize())
			throw new Error("Zero bond length");

		if(bond.type == chem.Struct.BOND.TYPE.TRIPLE)
			throw new Error("Non-single bonds not allowed near stereocenter");
		else if(bond.type == chem.Struct.BOND.TYPE.AROMATIC)
			throw new Error("Aromatic bonds not allowed near stereocenter");
		else if(bond.type == chem.Struct.BOND.TYPE.DOUBLE)
			n_double_bonds++;

		nei_idx++;
	}, this);

	util.find(chem.Stereocenters.allowed_stereocenters, function (as)
	{
		if(as.elem == atom.label && as.charge == atom.charge &&
			as.degree == degree && as.n_double_bonds == n_double_bonds)
		{
			implicit_degree = as.implicit_degree;
			return true;
		}
		return false;
	}, this);

	if(implicit_degree == -1)
		throw new Error("Unknown stereocenter configuration: " + atom.label + ", charge " + atom.charge + ", " + degree + " bonds (" + n_double_bonds + " double)");

	if(degree == 4 && n_pure_hydrogens > 1)
		throw new Error(n_pure_hydrogens + " hydrogens near stereocenter");

	if(degree == 3 && implicit_degree == 4 && n_pure_hydrogens > 0)
		throw new Error("Has hydrogen(s) besides implicit hydrogen near stereocenter");

	/*
   if (stereocenter.type == ATOM_ANY)
   {
      _stereocenters.insert(atom_idx, stereocenter);
      return;
   }
   */

	if(degree == 4)
	{
		// sort by neighbor atom index (ascending)
		if(edge_ids[0].rank > edge_ids[1].rank)
			edge_ids.swap(0, 1);
		if(edge_ids[1].rank > edge_ids[2].rank)
			edge_ids.swap(1, 2);
		if(edge_ids[2].rank > edge_ids[3].rank)
			edge_ids.swap(2, 3);
		if(edge_ids[1].rank > edge_ids[2].rank)
			edge_ids.swap(1, 2);
		if(edge_ids[0].rank > edge_ids[1].rank)
			edge_ids.swap(0, 1);
		if(edge_ids[1].rank > edge_ids[2].rank)
			edge_ids.swap(1, 2);

		var main1 = -1,
			main2 = -1,
			side1 = -1,
			side2 = -1;
		var main_dir = 0;

		for(nei_idx = 0; nei_idx < 4; nei_idx++)
		{
			var stereo = this._getBondStereo(atom_idx, edge_ids[nei_idx].edge_idx);

			if(stereo == chem.Struct.BOND.STEREO.UP || stereo == chem.Struct.BOND.STEREO.DOWN)
			{
				main1 = nei_idx;
				main_dir = stereo;
				break;
			}
		}

		if(main1 == -1)
			throw new Error("None of 4 bonds going from stereocenter is stereobond");

		var xyz1, xyz2;

		// find main2 as opposite to main1
		if(main2 == -1)
		{
			xyz1 = chem.Stereocenters._xyzzy(edge_ids[main1].vec, edge_ids[(main1 + 1) % 4].vec, edge_ids[(main1 + 2) % 4].vec);
			xyz2 = chem.Stereocenters._xyzzy(edge_ids[main1].vec, edge_ids[(main1 + 1) % 4].vec, edge_ids[(main1 + 3) % 4].vec);

			if(xyz1 + xyz2 == 3 || xyz1 + xyz2 == 12)
			{
				main2 = (main1 + 1) % 4;
				side1 = (main1 + 2) % 4;
				side2 = (main1 + 3) % 4;
			}
		}
		if(main2 == -1)
		{
			xyz1 = chem.Stereocenters._xyzzy(edge_ids[main1].vec, edge_ids[(main1 + 2) % 4].vec, edge_ids[(main1 + 1) % 4].vec);
			xyz2 = chem.Stereocenters._xyzzy(edge_ids[main1].vec, edge_ids[(main1 + 2) % 4].vec, edge_ids[(main1 + 3) % 4].vec);

			if(xyz1 + xyz2 == 3 || xyz1 + xyz2 == 12)
			{
				main2 = (main1 + 2) % 4;
				side1 = (main1 + 1) % 4;
				side2 = (main1 + 3) % 4;
			}
		}
		if(main2 == -1)
		{
			xyz1 = chem.Stereocenters._xyzzy(edge_ids[main1].vec, edge_ids[(main1 + 3) % 4].vec, edge_ids[(main1 + 1) % 4].vec);
			xyz2 = chem.Stereocenters._xyzzy(edge_ids[main1].vec, edge_ids[(main1 + 3) % 4].vec, edge_ids[(main1 + 2) % 4].vec);

			if(xyz1 + xyz2 == 3 || xyz1 + xyz2 == 12)
			{
				main2 = (main1 + 3) % 4;
				side1 = (main1 + 2) % 4;
				side2 = (main1 + 1) % 4;
			}
		}

		if(main2 == -1)
			throw new Error("Internal error: can not find opposite bond");

		if(main_dir == chem.Struct.BOND.STEREO.UP && this._getBondStereo(atom_idx, edge_ids[main2].edge_idx) == chem.Struct.BOND.STEREO.DOWN)
			throw new Error("Stereo types of the opposite bonds mismatch");
		if(main_dir == chem.Struct.BOND.STEREO.DOWN && this._getBondStereo(atom_idx, edge_ids[main2].edge_idx) == chem.Struct.BOND.STEREO.UP)
			throw new Error("Stereo types of the opposite bonds mismatch");

		if(main_dir == this._getBondStereo(atom_idx, edge_ids[side1].edge_idx))
			throw new Error("Stereo types of non-opposite bonds match");
		if(main_dir == this._getBondStereo(atom_idx, edge_ids[side2].edge_idx))
			throw new Error("Stereo types of non-opposite bonds match");

		if(main1 == 3 || main2 == 3)
			last_atom_dir = main_dir;
		else
			last_atom_dir = (main_dir == chem.Struct.BOND.STEREO.UP ? chem.Struct.BOND.STEREO.DOWN : chem.Struct.BOND.STEREO.UP);

		sign = chem.Stereocenters._sign(edge_ids[0].vec, edge_ids[1].vec, edge_ids[2].vec);

		if((last_atom_dir == chem.Struct.BOND.STEREO.UP && sign > 0) ||
			(last_atom_dir == chem.Struct.BOND.STEREO.DOWN && sign < 0))
		{
			stereocenter.pyramid[0] = edge_ids[0].nei_idx;
			stereocenter.pyramid[1] = edge_ids[1].nei_idx;
			stereocenter.pyramid[2] = edge_ids[2].nei_idx;
		}
		else
		{
			stereocenter.pyramid[0] = edge_ids[0].nei_idx;
			stereocenter.pyramid[1] = edge_ids[2].nei_idx;
			stereocenter.pyramid[2] = edge_ids[1].nei_idx;
		}

		stereocenter.pyramid[3] = edge_ids[3].nei_idx;
	}
	else if(degree == 3)
	{
		// sort by neighbor atom index (ascending)
		if(edge_ids[0].rank > edge_ids[1].rank)
			edge_ids.swap(0, 1);
		if(edge_ids[1].rank > edge_ids[2].rank)
			edge_ids.swap(1, 2);
		if(edge_ids[0].rank > edge_ids[1].rank)
			edge_ids.swap(0, 1);

		var stereo0 = this._getBondStereo(atom_idx, edge_ids[0].edge_idx);
		var stereo1 = this._getBondStereo(atom_idx, edge_ids[1].edge_idx);
		var stereo2 = this._getBondStereo(atom_idx, edge_ids[2].edge_idx);

		var n_up = 0,
			n_down = 0;

		n_up += ((stereo0 == chem.Struct.BOND.STEREO.UP) ? 1 : 0);
		n_up += ((stereo1 == chem.Struct.BOND.STEREO.UP) ? 1 : 0);
		n_up += ((stereo2 == chem.Struct.BOND.STEREO.UP) ? 1 : 0);

		n_down += ((stereo0 == chem.Struct.BOND.STEREO.DOWN) ? 1 : 0);
		n_down += ((stereo1 == chem.Struct.BOND.STEREO.DOWN) ? 1 : 0);
		n_down += ((stereo2 == chem.Struct.BOND.STEREO.DOWN) ? 1 : 0);

		if(implicit_degree == 4) // have implicit hydrogen
		{
			if(n_up == 3)
				throw new Error("All 3 bonds up near stereoatom");
			if(n_down == 3)
				throw new Error("All 3 bonds down near stereoatom");

			if(n_up == 0 && n_down == 0)
				throw new Error("No up/down bonds near stereoatom -- indefinite case");
			if(n_up == 1 && n_down == 1)
				throw new Error("One bond up, one bond down -- indefinite case");

			main_dir = 0;

			if(n_up == 2)
				last_atom_dir = chem.Struct.BOND.STEREO.DOWN;
			else if(n_down == 2)
				last_atom_dir = chem.Struct.BOND.STEREO.UP;
			else
			{
				main1 = -1;
				side1 = -1;
				side2 = -1;

				for(nei_idx = 0; nei_idx < 3; nei_idx++)
				{
					dir = this._getBondStereo(atom_idx, edge_ids[nei_idx].edge_idx);

					if(dir == chem.Struct.BOND.STEREO.UP || dir == chem.Struct.BOND.STEREO.DOWN)
					{
						main1 = nei_idx;
						main_dir = dir;
						side1 = (nei_idx + 1) % 3;
						side2 = (nei_idx + 2) % 3;
						break;
					}
				}

				if(main1 == -1)
					throw new Error("Internal error: can not find up or down bond");

				var xyz = chem.Stereocenters._xyzzy(edge_ids[side1].vec, edge_ids[side2].vec, edge_ids[main1].vec);

				if(xyz == 3 || xyz == 4)
					throw new Error("Degenerate case for 3 bonds near stereoatom");

				if(xyz == 1)
					last_atom_dir = main_dir;
				else
					last_atom_dir = (main_dir == chem.Struct.BOND.STEREO.UP ? chem.Struct.BOND.STEREO.DOWN : chem.Struct.BOND.STEREO.UP);
			}

			var sign = chem.Stereocenters._sign(edge_ids[0].vec, edge_ids[1].vec, edge_ids[2].vec);

			if((last_atom_dir == chem.Struct.BOND.STEREO.UP && sign > 0) ||
				(last_atom_dir == chem.Struct.BOND.STEREO.DOWN && sign < 0))
			{
				stereocenter.pyramid[0] = edge_ids[0].nei_idx;
				stereocenter.pyramid[1] = edge_ids[1].nei_idx;
				stereocenter.pyramid[2] = edge_ids[2].nei_idx;
			}
			else
			{
				stereocenter.pyramid[0] = edge_ids[0].nei_idx;
				stereocenter.pyramid[1] = edge_ids[2].nei_idx;
				stereocenter.pyramid[2] = edge_ids[1].nei_idx;
			}

			stereocenter.pyramid[3] = -1;
		}
		else // 3-connected P, N or S; no implicit hydrogens
		{
			var dir;

			if(n_down > 0 && n_up > 0)
				throw new Error("One bond up, one bond down -- indefinite case");
			else if(n_down == 0 && n_up == 0)
				throw new Error("No up-down bonds attached to stereocenter");
			else if(n_up > 0)
				dir = 1;
			else
				dir = -1;

			if(chem.Stereocenters._xyzzy(edge_ids[0].vec, edge_ids[1].vec, edge_ids[2].vec) == 1 ||
				chem.Stereocenters._xyzzy(edge_ids[0].vec, edge_ids[2].vec, edge_ids[1].vec) == 1 ||
				chem.Stereocenters._xyzzy(edge_ids[2].vec, edge_ids[1].vec, edge_ids[0].vec) == 1)
			// all bonds belong to the same half-plane
				dir = -dir;

			sign = chem.Stereocenters._sign(edge_ids[0].vec, edge_ids[1].vec, edge_ids[2].vec);

			if(sign == dir)
			{
				stereocenter.pyramid[0] = edge_ids[0].nei_idx;
				stereocenter.pyramid[1] = edge_ids[2].nei_idx;
				stereocenter.pyramid[2] = edge_ids[1].nei_idx;
			}
			else
			{
				stereocenter.pyramid[0] = edge_ids[0].nei_idx;
				stereocenter.pyramid[1] = edge_ids[1].nei_idx;
				stereocenter.pyramid[2] = edge_ids[2].nei_idx;
			}
			stereocenter.pyramid[3] = -1;
		}
	}

	this.atoms.set(atom_idx, stereocenter);
};

chem.Stereocenters.prototype._getBondStereo = function (center_idx, edge_idx)
{
	var bond = this.molecule.bonds.get(edge_idx);

	if(center_idx != bond.begin) // TODO: check this
		return 0;

	return bond.stereo;
};

// 1 -- in the smaller angle, 2 -- in the bigger angle,
// 4 -- in the 'positive' straight angle, 8 -- in the 'negative' straight angle
chem.Stereocenters._xyzzy = function (v1, v2, u)
{
	var eps = 0.001;

	var sine1 = util.Vec2.cross(v1, v2);
	var cosine1 = util.Vec2.dot(v1, v2);

	var sine2 = util.Vec2.cross(v1, u);
	var cosine2 = util.Vec2.dot(v1, u);

	if(Math.abs(sine1) < eps)
	{
		if(Math.abs(sine2) < eps)
			throw new Error("Degenerate case -- bonds overlap");

		return(sine2 > 0) ? 4 : 8;
	}

	if(sine1 * sine2 < -eps * eps)
		return 2;

	if(cosine2 < cosine1)
		return 2;

	return 1;
};

chem.Stereocenters._sign = function (v1, v2, v3)
{
	var res = (v1.x - v3.x) * (v2.y - v3.y) - (v1.y - v3.y) * (v2.x - v3.x);
	var eps = 0.001;

	if(res > eps)
		return 1;
	if(res < -eps)
		return -1;

	throw new Error("Degenerate triangle");
};

chem.Stereocenters.isPyramidMappingRigid = function (mapping)
{
	var arr = mapping.clone();
	var rigid = true;

	if(arr[0] > arr[1])
		arr.swap(0, 1), rigid = !rigid;
	if(arr[1] > arr[2])
		arr.swap(1, 2), rigid = !rigid;
	if(arr[2] > arr[3])
		arr.swap(2, 3), rigid = !rigid;
	if(arr[1] > arr[2])
		arr.swap(1, 2), rigid = !rigid;
	if(arr[0] > arr[1])
		arr.swap(0, 1), rigid = !rigid;
	if(arr[1] > arr[2])
		arr.swap(1, 2), rigid = !rigid;

	return rigid;
};
/****************************************************************************
 * Copyright (C) 2009-2010 GGA Software Services LLC
 *
 * This file may be distributed and/or modified under the terms of the
 * GNU Affero General Public License version 3 as published by the Free
 * Software Foundation and appearing in the file LICENSE.GPL included in
 * the packaging of this file.
 *
 * This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
 * WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ***************************************************************************/

if(!window.chem || !chem.Struct)
	throw new Error("Vec2 and Molecule should be defined first");

chem.SmilesSaver = function ()
{
	this.smiles = '';
	this._written_atoms = new Array();
	this._written_components = 0;

	this.ignore_errors = false;
};

chem.SmilesSaver._Atom = function (h_count)
{
	this.neighbours = new Array(); // Array of integer pairs {a, b}
	this.aromatic = false; // has aromatic bond
	this.lowercase = false; // aromatic and has to be written lowercase
	this.chirality = 0; // 0 means no chirality, 1 means CCW pyramid, 2 means CW pyramid
	this.branch_cnt = 0; // runs from 0 to (branches - 1)
	this.paren_written = false;
	this.h_count = h_count;
	this.parent = -1;
};

// NB: only loops of length up to 6 are included here
chem.SmilesSaver.prototype.isBondInRing = function (bid)
{
	if(util.isUndefined(this.inLoop) || util.isNull(this.inLoop))
		throw new Error("Init this.inLoop prior to calling this method");
	return this.inLoop[bid];
};

chem.SmilesSaver.prototype.saveMolecule = function (molecule, ignore_errors)
{
	var i, j, k;

	if(!util.isUndefined(ignore_errors))
		this.ignore_errors = ignore_errors;

	//[RB]: KETCHER-498 (Incorrect smile-string for multiple Sgroup)
	//TODO the fix is temporary, still need to implement error handling/reporting
	//BEGIN
	//    if (molecule.sgroups.count() > 0 && !this.ignore_errors)
	//        throw new Error("SMILES doesn't support s-groups");
	molecule = molecule.clone();
	molecule.sgroups.each(function (sgid, sg)
	{
		if(sg.type == 'MUL')
		{
			try
			{
				sg.prepareForSaving(molecule);
			}
			catch(ex)
			{
				throw {
					message: 'Bad s-group (' + ex.message + ')'
				};
			}
		}
		else if(!this.ignore_errors)
		{
			throw new Error("SMILES data format doesn't support s-groups");
		}
	}, this);
	//END

	this.atoms = new Array(molecule.atoms.count());

	molecule.atoms.each(function (aid, atom)
	{
		this.atoms[aid] = new chem.SmilesSaver._Atom(atom.implicitH);
	}, this);

	// From the SMILES specification:
	// Please note that only atoms on the following list
	// can be considered aromatic: C, N, O, P, S, As, Se, and * (wildcard).
	var allowed_lowercase = ['B', 'C', 'N', 'O', 'P', 'S', 'Se', 'As'];

	// Detect atoms that have aromatic bonds and count neighbours
	molecule.bonds.each(function (bid, bond)
	{
		if(bond.type == chem.Struct.BOND.TYPE.AROMATIC)
		{
			this.atoms[bond.begin].aromatic = true;
			if(allowed_lowercase.indexOf(molecule.atoms.get(bond.begin).label) != -1)
				this.atoms[bond.begin].lowercase = true;
			this.atoms[bond.end].aromatic = true;
			if(allowed_lowercase.indexOf(molecule.atoms.get(bond.end).label) != -1)
				this.atoms[bond.end].lowercase = true;
		}
		this.atoms[bond.begin].neighbours.push(
		{
			aid: bond.end,
			bid: bid
		});
		this.atoms[bond.end].neighbours.push(
		{
			aid: bond.begin,
			bid: bid
		});
	}, this);

	this.inLoop = (function ()
	{
		molecule.prepareLoopStructure();
		var bondsInLoops = util.Set.empty();
		molecule.loops.each(function (lid, loop)
		{
			if(loop.hbs.length <= 6)
				util.Set.mergeIn(bondsInLoops, util.Set.fromList(util.map(loop.hbs, function (hbid)
				{
					return molecule.halfBonds.get(hbid).bid;
				}, this)));
		}, this);
		var inLoop = {};
		util.Set.each(bondsInLoops, function (bid)
		{
			inLoop[bid] = 1;
		}, this);
		return inLoop;
	})();

	this._touched_cistransbonds = 0;
	this._markCisTrans(molecule);

	var components = chem.MolfileSaver.getComponents(molecule);
	var componentsAll = components.reactants.concat(components.products);

	var walk = new chem.Dfs(molecule, this.atoms, componentsAll, components.reactants.length);

	walk.walk();

	util.each(this.atoms, function (atom)
	{
		atom.neighbours = [];
	}, this);

	// fill up neighbor lists for the stereocenters calculation
	for(i = 0; i < walk.v_seq.length; i++)
	{
		var seq_el = walk.v_seq[i];
		var v_idx = seq_el.idx;
		var e_idx = seq_el.parent_edge;
		var v_prev_idx = seq_el.parent_vertex;

		if(e_idx >= 0)
		{
			var atom = this.atoms[v_idx];

			var opening_cycles = walk.numOpeningCycles(e_idx);

			for(j = 0; j < opening_cycles; j++)
				this.atoms[v_prev_idx].neighbours.push(
				{
					aid: -1,
					bid: -1
				});

			if(walk.edgeClosingCycle(e_idx))
			{
				for(k = 0; k < atom.neighbours.length; k++)
				{
					if(atom.neighbours[k].aid == -1)
					{
						atom.neighbours[k].aid = v_prev_idx;
						atom.neighbours[k].bid = e_idx;
						break;
					}
				}
				if(k == atom.neighbours.length)
					throw new Error("Internal: can not put closing bond to its place");
			}
			else
			{
				atom.neighbours.push(
				{
					aid: v_prev_idx,
					bid: e_idx
				});
				atom.parent = v_prev_idx;
			}
			this.atoms[v_prev_idx].neighbours.push(
			{
				aid: v_idx,
				bid: e_idx
			});
		}
	}

	try
	{
		// detect chiral configurations
		var stereocenters = new chem.Stereocenters(molecule, function (idx)
		{
			return this.atoms[idx].neighbours;
		}, this);
		stereocenters.buildFromBonds(this.ignore_errors);

		stereocenters.each(function (atom_idx, sc)
		{
			//if (sc.type < MoleculeStereocenters::ATOM_AND)
			//    continue;

			var implicit_h_idx = -1;

			if(sc.pyramid[3] == -1)
				implicit_h_idx = 3;
			/*
            else for (j = 0; j < 4; j++)
                if (ignored_vertices[pyramid[j]])
                {
                    implicit_h_idx = j;
                    break;
                }
                */

			var pyramid_mapping = new Array(4);
			var counter = 0;

			var atom = this.atoms[atom_idx];

			if(atom.parent != -1)
				for(k = 0; k < 4; k++)
					if(sc.pyramid[k] == atom.parent)
					{
						pyramid_mapping[counter++] = k;
						break;
					}

			if(implicit_h_idx != -1)
				pyramid_mapping[counter++] = implicit_h_idx;

			for(j = 0; j != atom.neighbours.length; j++)
			{
				if(atom.neighbours[j].aid == atom.parent)
					continue;

				for(k = 0; k < 4; k++)
					if(atom.neighbours[j].aid == sc.pyramid[k])
					{
						if(counter >= 4)
							throw new Error("Internal: pyramid overflow");
						pyramid_mapping[counter++] = k;
						break;
					}
			}

			if(counter == 4)
			{
				// move the 'from' atom to the end
				counter = pyramid_mapping[0];
				pyramid_mapping[0] = pyramid_mapping[1];
				pyramid_mapping[1] = pyramid_mapping[2];
				pyramid_mapping[2] = pyramid_mapping[3];
				pyramid_mapping[3] = counter;
			}
			else if(counter != 3)
				throw new Error("Cannot calculate chirality");

			if(chem.Stereocenters.isPyramidMappingRigid(pyramid_mapping))
				this.atoms[atom_idx].chirality = 1;
			else
				this.atoms[atom_idx].chirality = 2;
		}, this);
	}
	catch(ex)
	{
		throw new Error(ex.message);
	}

	// write the SMILES itself

	// cycle_numbers[i] == -1 means that the number is available
	// cycle_numbers[i] == n means that the number is used by vertex n
	var cycle_numbers = new Array();

	cycle_numbers.push(0); // never used

	var first_component = true;

	for(i = 0; i < walk.v_seq.length; i++)
	{
		seq_el = walk.v_seq[i];
		v_idx = seq_el.idx;
		e_idx = seq_el.parent_edge;
		v_prev_idx = seq_el.parent_vertex;
		var write_atom = true;

		if(v_prev_idx >= 0)
		{
			if(walk.numBranches(v_prev_idx) > 1)
				if(this.atoms[v_prev_idx].branch_cnt > 0 && this.atoms[v_prev_idx].paren_written)
					this.smiles += ')';

			opening_cycles = walk.numOpeningCycles(e_idx);

			for(j = 0; j < opening_cycles; j++)
			{
				for(k = 1; k < cycle_numbers.length; k++)
					if(cycle_numbers[k] == -1)
						break;
				if(k == cycle_numbers.length)
					cycle_numbers.push(v_prev_idx);
				else
					cycle_numbers[k] = v_prev_idx;

				this._writeCycleNumber(k);
			}

			if(v_prev_idx >= 0)
			{
				var branches = walk.numBranches(v_prev_idx);

				if(branches > 1)
					if(this.atoms[v_prev_idx].branch_cnt < branches - 1)
					{
						if(walk.edgeClosingCycle(e_idx))
							this.atoms[v_prev_idx].paren_written = false;
						else
						{
							this.smiles += '(';
							this.atoms[v_prev_idx].paren_written = true;
						}
					}

				this.atoms[v_prev_idx].branch_cnt++;

				if(this.atoms[v_prev_idx].branch_cnt > branches)
					throw new Error("Unexpected branch");
			}

			var bond = molecule.bonds.get(e_idx);
			var bond_written = true;

			var dir = 0;

			if(bond.type == chem.Struct.BOND.TYPE.SINGLE)
				dir = this._calcBondDirection(molecule, e_idx, v_prev_idx);

			if((dir == 1 && v_idx == bond.end) || (dir == 2 && v_idx == bond.begin))
				this.smiles += '/';
			else if((dir == 2 && v_idx == bond.end) || (dir == 1 && v_idx == bond.begin))
				this.smiles += '\\';
			else if(bond.type == chem.Struct.BOND.TYPE.ANY)
				this.smiles += '~';
			else if(bond.type == chem.Struct.BOND.TYPE.DOUBLE)
				this.smiles += '=';
			else if(bond.type == chem.Struct.BOND.TYPE.TRIPLE)
				this.smiles += '#';
			else if(bond.type == chem.Struct.BOND.TYPE.AROMATIC &&
				(!this.atoms[bond.begin].lowercase || !this.atoms[bond.end].lowercase || !this.isBondInRing(e_idx)))
				this.smiles += ':'; // TODO: Check if this : is needed
			else if(bond.type == chem.Struct.BOND.TYPE.SINGLE && this.atoms[bond.begin].aromatic && this.atoms[bond.end].aromatic)
				this.smiles += '-';
			else
				bond_written = false;


			if(walk.edgeClosingCycle(e_idx))
			{
				for(j = 1; j < cycle_numbers.length; j++)
					if(cycle_numbers[j] == v_idx)
						break;

				if(j == cycle_numbers.length)
					throw new Error("Cycle number not found");

				this._writeCycleNumber(j);

				cycle_numbers[j] = -1;
				write_atom = false;
			}
		}
		else
		{
			if(!first_component)
				this.smiles += (this._written_components == walk.nComponentsInReactants) ? '>>' : '.';
			first_component = false;
			this._written_components++;
		}
		if(write_atom)
		{
			this._writeAtom(molecule, v_idx, this.atoms[v_idx].aromatic, this.atoms[v_idx].lowercase, this.atoms[v_idx].chirality);
			this._written_atoms.push(seq_el.idx);
		}
	}

	this.comma = false;

	//this._writeStereogroups(mol, atoms);
	this._writeRadicals(molecule);
	//this._writePseudoAtoms(mol);
	//this._writeHighlighting();

	if(this.comma)
		this.smiles += '|';

	return this.smiles;

};

chem.SmilesSaver.prototype._writeCycleNumber = function (n)
{
	if(n > 0 && n < 10)
		this.smiles += n;
	else if(n >= 10 && n < 100)
		this.smiles += '%' + n;
	else if(n >= 100 && n < 1000)
		this.smiles += '%%' + n;
	else
		throw new Error("Bad cycle number: " + n);
};

chem.SmilesSaver.prototype._writeAtom = function (mol, idx, aromatic, lowercase, chirality)
{
	var atom = mol.atoms.get(idx);
	var i;
	var need_brackets = false;
	var hydro = -1;
	var aam = 0;

	/*
    if (mol.haveQueryAtoms())
    {
      query_atom = &mol.getQueryAtom(idx);

      if (query_atom->type == QUERY_ATOM_RGROUP)
      {
         if (mol.getRGroups()->isRGroupAtom(idx))
         {
            const Array<int> &rg = mol.getRGroups()->getSiteRGroups(idx);

            if (rg.size() != 1)
               throw Error("rgroup count %d", rg.size());

            _output.printf("[&%d]", rg[0] + 1);
         }
         else
            _output.printf("[&%d]", 1);

         return;
      }
    }
    */

	if(atom.label == 'A')
	{
		this.smiles += '*';
		return;
	}

	if(atom.label == 'R' || atom.label == 'R#')
	{
		this.smiles += '[*]';
		return;
	}

	//KETCHER-598 (Ketcher does not save AAM into reaction SMILES)
	//BEGIN
	//    if (this.atom_atom_mapping)
	//        aam = atom_atom_mapping[idx];
	aam = atom.aam;
	//END

	if(atom.label != 'C' && atom.label != 'P' &&
		atom.label != 'N' && atom.label != 'S' &&
		atom.label != 'O' && atom.label != 'Cl' &&
		atom.label != 'F' && atom.label != 'Br' &&
		atom.label != 'B' && atom.label != 'I')
		need_brackets = true;

	if(atom.explicitValence >= 0 || atom.radical != 0 || chirality > 0 ||
		(aromatic && atom.label != 'C' && atom.label != 'O') ||
		(aromatic && atom.label == 'C' && this.atoms[idx].neighbours.length < 3 && this.atoms[idx].h_count == 0))
		hydro = this.atoms[idx].h_count;

	var label = atom.label;
	if(atom.atomList && !atom.atomList.notList)
	{
		label = atom.atomList.label();
		need_brackets = false; // atom list label already has brackets
	}
	else if(atom.isPseudo() || (atom.atomList && atom.atomList.notList))
	{
		label = '*';
		need_brackets = true;
	}
	else if(chirality || atom.charge != 0 || atom.isotope > 0 || hydro >= 0 || aam > 0)
	{
		need_brackets = true;
	}

	if(need_brackets)
	{
		if(hydro == -1)
			hydro = this.atoms[idx].h_count;
		this.smiles += '[';
	}

	if(atom.isotope > 0)
		this.smiles += atom.isotope;

	if(lowercase)
		this.smiles += label.toLowerCase();
	else
		this.smiles += label;

	if(chirality > 0)
	{
		if(chirality == 1)
			this.smiles += '@';
		else // chirality == 2
			this.smiles += '@@';

		if(atom.implicitH > 1)
			throw new Error(atom.implicitH + " implicit H near stereocenter");
	}

	if(atom.label != 'H')
	{
		if(hydro > 1 || (hydro == 0 && !need_brackets))
			this.smiles += 'H' + hydro;
		else if(hydro == 1)
			this.smiles += 'H';
	}

	if(atom.charge > 1)
		this.smiles += '+' + atom.charge;
	else if(atom.charge < -1)
		this.smiles += atom.charge;
	else if(atom.charge == 1)
		this.smiles += '+';
	else if(atom.charge == -1)
		this.smiles += '-';

	if(aam > 0)
		this.smiles += ':' + aam;

	if(need_brackets)
		this.smiles += ']';

	/*
    if (mol.getRGroupFragment() != 0)
    {
      for (i = 0; i < 2; i++)
      {
         int j;

         for (j = 0; mol.getRGroupFragment()->getAttachmentPoint(i, j) != -1; j++)
            if (idx == mol.getRGroupFragment()->getAttachmentPoint(i, j))
            {
               _output.printf("([*])");
               break;
            }

         if (mol.getRGroupFragment()->getAttachmentPoint(i, j) != -1)
            break;
      }
    }
    */
};

chem.SmilesSaver.prototype._markCisTrans = function (mol)
{
	this.cis_trans = new chem.CisTrans(mol, function (idx)
	{
		return this.atoms[idx].neighbours;
	}, this);
	this.cis_trans.build();
	this._dbonds = new Array(mol.bonds.count());

	mol.bonds.each(function (bid)
	{
		this._dbonds[bid] = {
			ctbond_beg: -1,
			ctbond_end: -1,
			saved: 0
		}
	}, this);

	this.cis_trans.each(function (bid, ct)
	{
		var bond = mol.bonds.get(bid);

		if(ct.parity != 0 && !this.isBondInRing(bid))
		{
			var nei_beg = this.atoms[bond.begin].neighbours;
			var nei_end = this.atoms[bond.end].neighbours;
			var arom_fail_beg = true,
				arom_fail_end = true;

			util.each(nei_beg, function (nei)
			{
				if(nei.bid != bid && mol.bonds.get(nei.bid).type == chem.Struct.BOND.TYPE.SINGLE)
					arom_fail_beg = false;
			}, this);

			util.each(nei_end, function (nei)
			{
				if(nei.bid != bid && mol.bonds.get(nei.bid).type == chem.Struct.BOND.TYPE.SINGLE)
					arom_fail_end = false;
			}, this);

			if(arom_fail_beg || arom_fail_end)
				return;

			util.each(nei_beg, function (nei)
			{
				if(nei.bid != bid)
				{
					if(mol.bonds.get(nei.bid).begin == bond.begin)
						this._dbonds[nei.bid].ctbond_beg = bid;
					else
						this._dbonds[nei.bid].ctbond_end = bid;
				}
			}, this);

			util.each(nei_end, function (nei)
			{
				if(nei.bid != bid)
				{
					if(mol.bonds.get(nei.bid).begin == bond.end)
						this._dbonds[nei.bid].ctbond_beg = bid;
					else
						this._dbonds[nei.bid].ctbond_end = bid;
				}
			}, this);
		}
	}, this);
};

chem.SmilesSaver.prototype._updateSideBonds = function (mol, bond_idx)
{
	var bond = mol.bonds.get(bond_idx);
	var subst = this.cis_trans.getSubstituents(bond_idx);
	var parity = this.cis_trans.getParity(bond_idx);

	var sidebonds = [-1, -1, -1, -1];

	sidebonds[0] = mol.findBondId(subst[0], bond.begin);
	if(subst[1] != -1)
		sidebonds[1] = mol.findBondId(subst[1], bond.begin);

	sidebonds[2] = mol.findBondId(subst[2], bond.end);
	if(subst[3] != -1)
		sidebonds[3] = mol.findBondId(subst[3], bond.end);

	var n1 = 0,
		n2 = 0,
		n3 = 0,
		n4 = 0;

	if(this._dbonds[sidebonds[0]].saved != 0)
	{
		if((this._dbonds[sidebonds[0]].saved == 1 && mol.bonds.get(sidebonds[0]).begin == bond.begin) ||
			(this._dbonds[sidebonds[0]].saved == 2 && mol.bonds.get(sidebonds[0]).end == bond.begin))
			n1++;
		else
			n2++;
	}
	if(sidebonds[1] != -1 && this._dbonds[sidebonds[1]].saved != 0)
	{
		if((this._dbonds[sidebonds[1]].saved == 2 && mol.bonds.get(sidebonds[1]).begin == bond.begin) ||
			(this._dbonds[sidebonds[1]].saved == 1 && mol.bonds.get(sidebonds[1]).end == bond.begin))
			n1++;
		else
			n2++;
	}
	if(this._dbonds[sidebonds[2]].saved != 0)
	{
		if((this._dbonds[sidebonds[2]].saved == 1 && mol.bonds.get(sidebonds[2]).begin == bond.end) ||
			(this._dbonds[sidebonds[2]].saved == 2 && mol.bonds.get(sidebonds[2]).end == bond.end))
			n3++;
		else
			n4++;
	}
	if(sidebonds[3] != -1 && this._dbonds[sidebonds[3]].saved != 0)
	{
		if((this._dbonds[sidebonds[3]].saved == 2 && mol.bonds.get(sidebonds[3]).begin == bond.end) ||
			(this._dbonds[sidebonds[3]].saved == 1 && mol.bonds.get(sidebonds[3]).end == bond.end))
			n3++;
		else
			n4++;
	}

	if(parity == chem.CisTrans.PARITY.CIS)
	{
		n1 += n3;
		n2 += n4;
	}
	else
	{
		n1 += n4;
		n2 += n3;
	}

	if(n1 > 0 && n2 > 0)
		throw new Error("Incompatible cis-trans configuration");

	if(n1 == 0 && n2 == 0)
		return false;

	if(n1 > 0)
	{
		this._dbonds[sidebonds[0]].saved =
			(mol.bonds.get(sidebonds[0]).begin == bond.begin) ? 1 : 2;
		if(sidebonds[1] != -1)
			this._dbonds[sidebonds[1]].saved =
			(mol.bonds.get(sidebonds[1]).begin == bond.begin) ? 2 : 1;

		this._dbonds[sidebonds[2]].saved =
			((mol.bonds.get(sidebonds[2]).begin == bond.end) == (parity == chem.CisTrans.PARITY.CIS)) ? 1 : 2;
		if(sidebonds[3] != -1)
			this._dbonds[sidebonds[3]].saved =
			((mol.bonds.get(sidebonds[3]).begin == bond.end) == (parity == chem.CisTrans.PARITY.CIS)) ? 2 : 1;
	}
	if(n2 > 0)
	{
		this._dbonds[sidebonds[0]].saved =
			(mol.bonds.get(sidebonds[0]).begin == bond.begin) ? 2 : 1;
		if(sidebonds[1] != -1)
			this._dbonds[sidebonds[1]].saved =
			(mol.bonds.get(sidebonds[1]).begin == bond.begin) ? 1 : 2;

		this._dbonds[sidebonds[2]].saved =
			((mol.bonds.get(sidebonds[2]).begin == bond.end) == (parity == chem.CisTrans.PARITY.CIS)) ? 2 : 1;
		if(sidebonds[3] != -1)
			this._dbonds[sidebonds[3]].saved =
			((mol.bonds.get(sidebonds[3]).begin == bond.end) == (parity == chem.CisTrans.PARITY.CIS)) ? 1 : 2;
	}

	return true;
};

chem.SmilesSaver.prototype._calcBondDirection = function (mol, idx, vprev)
{
	var ntouched;

	if(this._dbonds[idx].ctbond_beg == -1 && this._dbonds[idx].ctbond_end == -1)
		return 0;

	if(mol.bonds.get(idx).type != chem.Struct.BOND.TYPE.SINGLE)
		throw new Error("Internal: directed bond type " + mol.bonds.get(idx).type);

	while(true)
	{
		ntouched = 0;
		this.cis_trans.each(function (bid, ct)
		{
			if(ct.parity != 0 && !this.isBondInRing(bid))
			{
				if(this._updateSideBonds(mol, bid))
					ntouched++;
			}
		}, this);
		if(ntouched == this._touched_cistransbonds)
			break;
		this._touched_cistransbonds = ntouched;
	}

	if(this._dbonds[idx].saved == 0)
	{
		if(vprev == mol.bonds.get(idx).begin)
			this._dbonds[idx].saved = 1;
		else
			this._dbonds[idx].saved = 2;
	}

	return this._dbonds[idx].saved;
};

chem.SmilesSaver.prototype._writeRadicals = function (mol)
{
	var marked = new Array(this._written_atoms.length);
	var i, j;

	for(i = 0; i < this._written_atoms.length; i++)
	{
		if(marked[i])
			continue;

		var radical = mol.atoms.get(this._written_atoms[i]).radical;

		if(radical == 0)
			continue;

		if(this.comma)
			this.smiles += ',';
		else
		{
			this.smiles += ' |';
			this.comma = true;
		}

		if(radical == chem.Struct.ATOM.RADICAL.SINGLET)
			this.smiles += '^3:';
		else if(radical == chem.Struct.ATOM.RADICAL.DOUPLET)
			this.smiles += '^1:';
		else // RADICAL_TRIPLET
			this.smiles += '^4:';

		this.smiles += i;

		for(j = i + 1; j < this._written_atoms.length; j++)
			if(mol.atoms.get(this._written_atoms[j]).radical == radical)
			{
				marked[j] = true;
				this.smiles += ',' + j;
			}
	}
};

/*
void SmilesSaver::_writeStereogroups (const Struct &mol, const Array<_Atom> &atoms)
{
   MoleculeStereocenters &stereocenters = mol.getStereocenters();
   int i, j;
   int single_and_group = -1;

   for (i = stereocenters.begin(); i != stereocenters.end(); i = stereocenters.next(i))
   {
      int idx, type, group;

      stereocenters.get(i, idx, type, group, 0);

      if (type < MoleculeStereocenters::ATOM_ANY)
         continue;
      if (type != MoleculeStereocenters::ATOM_AND)
         break;
      if (single_and_group == -1)
         single_and_group = group;
      else if (single_and_group != group)
         break;
   }

   if (i == stereocenters.end())
      return;

   int and_group_idx = 1;
   int or_group_idx = 1;

   QS_DEF(Array<int>, marked);

   marked.clear_resize(_written_atoms.size());
   marked.zerofill();

   for (i = 0; i < _written_atoms.size(); i++)
   {
      if (marked[i])
         continue;

      int type = stereocenters.getType(_written_atoms[i]);

      if (type > 0)
      {
         if (_comma)
            _output.writeChar(',');
         else
         {
            _output.writeString(" |");
            _comma = true;
         }
      }

      if (type == MoleculeStereocenters::ATOM_ANY)
      {
         _output.printf("w:%d", i);

         for (j = i + 1; j < _written_atoms.size(); j++)
            if (stereocenters.getType(_written_atoms[j]) == MoleculeStereocenters::ATOM_ANY)
            {
               marked[j] = 1;
               _output.printf(",%d", j);
            }
      }
      else if (type == MoleculeStereocenters::ATOM_ABS)
      {
         _output.printf("a:%d", i);

         for (j = i + 1; j < _written_atoms.size(); j++)
            if (stereocenters.getType(_written_atoms[j]) == MoleculeStereocenters::ATOM_ABS)
            {
               marked[j] = 1;
               _output.printf(",%d", j);
            }
      }
      else if (type == MoleculeStereocenters::ATOM_AND)
      {
         int group = stereocenters.getGroup(_written_atoms[i]);

         _output.printf("&%d:%d", and_group_idx++, i);
         for (j = i + 1; j < _written_atoms.size(); j++)
            if (stereocenters.getType(_written_atoms[j]) == MoleculeStereocenters::ATOM_AND &&
                stereocenters.getGroup(_written_atoms[j]) == group)
            {
               marked[j] = 1;
               _output.printf(",%d", j);
            }
      }
      else if (type == MoleculeStereocenters::ATOM_OR)
      {
         int group = stereocenters.getGroup(_written_atoms[i]);

         _output.printf("o%d:%d", or_group_idx++, i);
         for (j = i + 1; j < _written_atoms.size(); j++)
            if (stereocenters.getType(_written_atoms[j]) == MoleculeStereocenters::ATOM_OR &&
                stereocenters.getGroup(_written_atoms[j]) == group)
            {
               marked[j] = 1;
               _output.printf(",%d", j);
            }
      }
   }
}
*/
/**
 * This file is part of MolView (http://molview.org)
 * Copyright (c) 2014, 2015 Herman Bergwerf
 *
 * MolView is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MolView is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with MolView.  If not, see <http://www.gnu.org/licenses/>.
 */

var JmolAtomColorsHashHex = { "D":"#111111","H":"#888888","He":"#849b9b","Li":"#c87efa","Be":"#82ab00","B":"#c38a8a","C":"#000000","N":"#304ff7","O":"#ff0d0d","F":"#6dab3c","Ne":"#7b9ca8","Na":"#ab5cf2","Mg":"#61b400","Al":"#a79191","Si":"#b09276","P":"#ff8000","S":"#c39517","Cl":"#1dc51d","Ar":"#63a2b0","K":"#8f40d4","Ca":"#2fc300","Sc":"#969696","Ti":"#94969a","V":"#96969a","Cr":"#8796c3","Mn":"#9c7ac7","Fe":"#e06633","Co":"#db8293","Ni":"#45b645","Cu":"#c78033","Zn":"#7d80b0","Ga":"#bd8c8c","Ge":"#668f8f","As":"#bd80e3","Se":"#e28f00","Br":"#a62929","Kr":"#53a6bc","Rb":"#702eb0","Sr":"#00d000","Y":"#5fa4a4","Zr":"#6ba2a2","Nb":"#61a4a9","Mo":"#4ea9a9","Tc":"#3b9e9e","Ru":"#248f8f","Rh":"#0a7d8c","Pd":"#006985","Ag":"#969696","Cd":"#ae9462","In":"#a67573","Sn":"#668080","Sb":"#9e63b5","Te":"#d47a00","I":"#940094","Xe":"#429eb0","Cs":"#57178f","Ba":"#00c900","La":"#57a4c5","Ce":"#989877","Pr":"#869d7b","Nd":"#7da07d","Pm":"#69a581","Sm":"#5ea883","Eu":"#43b089","Gd":"#31b48d","Tb":"#23b890","Dy":"#17bb92","Ho":"#00c578","Er":"#00c765","Tm":"#00c94e","Yb":"#00bf38","Lu":"#00ab24","Hf":"#42a8dc","Ta":"#4ba2f9","W":"#2194d6","Re":"#267dab","Os":"#266696","Ir":"#175487","Pt":"#9595a0","Au":"#b9981a","Hg":"#9595a9","Tl":"#a6544d","Pb":"#575961","Bi":"#9e4fb5","Po":"#ab5c00","At":"#754f45","Rn":"#428296","Fr":"#420066","Ra":"#007d00","Ac":"#669ce4","Th":"#00b8fc","Pa":"#00a1ff","U":"#008fff","Np":"#0080ff","Pu":"#006bff","Am":"#545cf2","Cm":"#785ce3","Bk":"#8a4fe3","Cf":"#a136d4","Es":"#b31fd4","Fm":"#B31FBA","Md":"#B30DA6","No":"#BD0D87","Lr":"#C70066","Rf":"#CC0059","Db":"#D1004F","Sg":"#D90045","Bh":"#E00038","Hs":"#E6002E","Mt":"#EB0026","Ds":"#9595a0","Rg":"#b9981a","Cn":"#9595a9" };
/**
 * This file is part of MolView (http://molview.org)
 * Copyright (c) 2014, 2015 Herman Bergwerf
 *
 * MolView is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MolView is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with MolView.  If not, see <http://www.gnu.org/licenses/>.
 */

var PI2 = 2 * Math.PI;

/**
 * Calculate if value is inside deviation relative to a number
 * @param  {Float} val Input value
 * @param  {Float} num Deviation base
 * @param  {Float} dev Deviation value
 * @return {Boolean}
 */
function indev(val, num, dev)
{
    return val > num - dev && val < num + dev;
}

/**
 * Calculate on which side b is relative to a in counter clockwise direction
 * @param {Float} a
 * @param {Float} b
 */
function radSide(a, b)
{
    return angleBetween(a, b) < Math.PI ? 1 : -1;
}

/**
 * Normalize angle to value between 0 and 2PI
 * @param {Float} a
 */
function posRad(a)
{
    while(a < 0) a += PI2;
    while(a > PI2) a -= PI2;
    return a;
}

/**
 * Calcualte smallest angle between two angles
 * @param {Float} a
 * @param {Float} b
 */
function smallestAngleBetween(a, b)
{
    var d = Math.abs(posRad(a) - posRad(b));
    return d < PI2 - d ? d : PI2 - d;
}

/**
 * Calculate angle between two angles where from is the first encountered angle
 * in counter clockwise direction
 * @param {Float} from
 * @param {Float} to
 */
function angleBetween(from, to)
{
    from = posRad(from);
    to = posRad(to);

	if(to <= from)//the point 'to' on a circle is actually 2PI behind
	{
		return to - from + PI2;
	}
	else
	{
		return to - from;
	}
}

/**
 * Calculate the given clamped angle between a point and a center
 * @param  {Float}   start  Angle offset
 * @param  {MPPoint} center Center of rotation
 * @param  {MPPoint} point  Target point
 * @param  {Float}   steps  Number of rotation steps in one circle
 * @return {Float}
 */
function clampedAngle(start, center, point, steps)
{
	var a = center.angleTo(point);
	var clampFactor = steps / PI2;
	return posRad(Math.round((a - start) * clampFactor) / clampFactor
			+ start);//clamp to x steps, normalize to startAngle
}

/**
 * Maps an array using a given map, removes all elements which are not
 * in the map
 * @param  {Array}  array
 * @param  {Object} map
 * @return {Array}
 */
function mapArray(array, map)
{
    for(var i = 0; i < array.length; i++)
	{
		if(map[array[i]] !== undefined)
		{
			array[i] = map[array[i]];
		}
		else
		{
			array.splice(i, 1);
			i--;
		}
	}

    return array;
}

/**
 * Multiply all values in an array with a given multiplier into new array
 * @param  {Array} array
 * @param  {Float} mult
 * @return {Array}
 */
function transformArrayMult(array, mult)
{
	var ret = []
	for(var i = 0; i < array.length; i++)
		ret.push(array[i] * mult);
	return ret;
}

/**
 * Copy array into new array and add value
 * @param  {Array} array
 * @param  {Float} val
 * @return {Array}
 */
function transformArrayAdd(array, val)
{
	var ret = []
	for(var i = 0; i < array.length; i++)
		ret.push(array[i] + val);
	return ret;
}

/**
 * Also defined in main MolView Utility but this makes MolPad standalone
 * @param {String} nail
 * @param {Array}  haystack
 */
function oneOf(nail, haystack)
{
	return haystack.indexOf(nail) !== -1;
}

function getMultiTouchDelta(e)
{
	var t = e.originalEvent.targetTouches;
	if(t.length <= 1) return 0;
	else
	{
		var dx = Math.abs(t[0].pageX - t[1].pageX);
		var dy = Math.abs(t[0].pageY - t[1].pageY);
		return Math.sqrt(dx * dx + dy * dy);
	}
}

function sign(x)
{
    //polyfill from Mozilla
    x = +x;// convert to a number
    if(x === 0 || isNaN(x)) return x
    return x > 0 ? 1 : -1
}
/**
 * This file is part of MolView (http://molview.org)
 * Copyright (c) 2014, 2015 Herman Bergwerf
 *
 * MolView is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MolView is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with MolView.  If not, see <http://www.gnu.org/licenses/>.
 */

function MPPoint(x, y)
{
	this.x = x || 0;
	this.y = y || 0;
}

/**
 * MPPoint From Object
 * @param {Object} obj
 */
function MPPFO(obj)
{
	return new MPPoint(obj.x, obj.y);
}

MPPoint.prototype.clone = function()
{
	return new MPPoint(this.x, this.y);
}

MPPoint.prototype.equals = function(point)
{
	return this.x === point.x && this.y === point.y;
}

MPPoint.prototype.set = function(x, y)
{
	this.x = x;
	this.y = y;
}

MPPoint.prototype.replace = function(p)
{
	this.x = p.x;
	this.y = p.y;
}

MPPoint.prototype.add = function(p)
{
	this.x += p.x;
	this.y += p.y;
}

MPPoint.prototype.addX = function(a) { this.x += a; }
MPPoint.prototype.addY = function(a) { this.y += a; }

MPPoint.prototype.divide = function(div)
{
	this.x /= div;
	this.y /= div;
}
MPPoint.prototype.divideX = function(a) { this.x /= a; }
MPPoint.prototype.divideY = function(a) { this.y /= a; }

MPPoint.prototype.multiply = function(mult)
{
	this.x *= mult;
	this.y *= mult;
}

MPPoint.prototype.multiplyX = function(a) { this.x *= a; }
MPPoint.prototype.multiplyY = function(a) { this.y *= a; }

MPPoint.prototype.translate = function(x, y)
{
	this.x += x;
	this.y += y;
}

MPPoint.prototype.scale = function(scale)
{
	this.x *= scale;
	this.y *= scale;
}

MPPoint.prototype.mirror = function(line, side)
{
	if(this.lineSide(line) !== side)
	{
		//http://stackoverflow.com/questions/3306838
		var dx = line.to.x - line.from.x;
		var dy = line.to.y - line.from.y;

		if(Math.abs(dx) < 0.001)
		{
			this.x = 2 * line.from.x - this.x;
		}
		else
		{
			var a = dy / dx;
			var c = line.from.y - a * line.from.x;//c = y - ax
			var d = (this.x + ((this.y - c) * a)) / (1 + a * a);
			this.x = 2 * d - this.x;
			this.y = 2 * d * a - this.y + 2 * c;
		}
		return true;
	}
	else return false;
}

/**
 * Find on which side of a line the given point is
 * @param  {Object} point { x: 0, y: 0 }
 * @param  {Object} line  { from: { x: 0, y: 0 }, to: { x: 0, y: 0 } }
 * @return {Integer}      -1: left, 0: on the line, +1: right
 */
MPPoint.prototype.lineSide = function(line)
{
    var s = sign((line.to.x - line.from.x) * (this.y - line.from.y) -
    		(line.to.y - line.from.y) * (this.x - line.from.x));
	return s > 0 ? 1 : s < 0 ? -1 : 0;
}

/**
 * Rotate a this point around a given center using a given angle
 * @param {MPPoint} c Center
 * @param {MPPoint} a Angle
 */
MPPoint.prototype.rotateAroundCenter = function(c, a)
{
	var dx = this.x - c.x;
	var dy = this.y - c.y;
	this.x = dx * Math.cos(-a) - dy * Math.sin(-a) + c.x;
	this.y = dx * Math.sin(-a) + dy * Math.cos(-a) + c.y;
}

/**
 * Calculate angle between the x-asix and the 'to' point where this point
 * is the center point
 * @param {MPPoint} to
 */
MPPoint.prototype.angleTo = function(to)
{
	return Math.atan2(-to.y + this.y, to.x - this.x);//flip y-axis
}

/**
 * Checks if the given point is inside the given circle
 * @param  {MPPoint} center Circle center
 * @param  {Float}   radius Cricle radius
 * @return {Boolean}
 */
MPPoint.prototype.inCircle = function(center, radius)
{
	return (this.x - center.x) * (this.x - center.x) +
		(this.y - center.y) * (this.y - center.y) < radius * radius;
}

/**
 * Calculates if point is NOT inside an R radius from line ab
 * @param  {MPPoint}  a Line vertex a
 * @param  {MPPoint}  b Line vertex b
 * @param  {Float}    r Radius around line
 * @return {Boolean}
 */
MPPoint.prototype.inLineBox = function(a, b, r)
{
	var bl = {}, tr = {};//bottom left, top right
	if(a.x < b.x) { bl.x = a.x, tr.x = b.x; }
	else		  { bl.x = b.x, tr.x = a.x; }
	if(a.y < b.y) { bl.y = a.y, tr.y = b.y; }
	else		  { bl.y = b.y, tr.y = a.y; }

	return !(this.x < bl.x - r || this.x > tr.x + r
		  || this.y < bl.y - r || this.y > tr.y + r);
}

/**
 * Calculates if point is NOT inside an R radius from point a
 * @param  {MPPoint}  a Point a
 * @param  {Float}    r Radius around line
 * @return {Boolean}
 */
MPPoint.prototype.inCircleBox = function(a, r)
{
	return !(this.x < a.x - r || this.x > a.x + r
		  || this.y < a.y - r || this.y > a.y + r);
}

MPPoint.prototype.inRect = function(rect)
{
	//clone to prevent from reference cluttering
	var x = rect.x, y = rect.y, w = rect.width, h = rect.height;
	if(w < 0)
	{
		w = -w;
		x -= w;
	}
	if(h < 0)
	{
		h = -h;
		y -= h;
	}
	return this.x > x && this.x < x + w
		&& this.y > y && this.y < y + h;
}

MPPoint.prototype.inPolygon = function(polygon)
{
	var c = false;
	for(var i = 0, j = polygon.length - 1; i < polygon.length; j = i++)
	{
		if((polygon[i].y > this.y) !== (polygon[j].y > this.y) &&
			this.x < ((polygon[j].x - polygon[i].x) * (this.y - polygon[i].y) / (polygon[j].y - polygon[i].y) + polygon[i].x))
		{
			c = !c;
		}
	}
	return c;
}

/**
 * Calculate shortest distance between a point and a line
 * @param  {MPPoint} a Line vertex a
 * @param  {MPPoint} b Line vertex b
 * @return {Float}
 */
MPPoint.prototype.lineDistance = function(a, b)
{
	var A = this.x - a.x;
	var B = this.y - a.y;
	var C = b.x - a.x;
	var D = b.y - a.y;

	var dot = A * C + B * D;
	var len_sq = C * C + D * D;
	var param = dot / len_sq;

	var xx, yy;

	if(param < 0 || (a.x === b.x && a.y === b.y))
	{
		xx = a.x;
		yy = a.y;
	}
	else if(param > 1)
	{
		xx = b.x;
		yy = b.y;
	}
	else
	{
		xx = a.x + param * C;
		yy = a.y + param * D;
	}

	var dx = this.x - xx;
	var dy = this.y - yy;
	return Math.sqrt(dx * dx + dy * dy);
}

MPPoint.prototype.distanceTo = function(p)
{
	return Math.sqrt((p.x - this.x) * (p.x - this.x) + (p.y - this.y) * (p.y - this.y));
}

MPPoint.prototype.fromPointer = function(e)
{
	var oe = e.originalEvent;
	if(oe.targetTouches && oe.targetTouches.length > 0)
	{
		this.set(oe.targetTouches[0].pageX, oe.targetTouches[0].pageY);
	}
	else
	{
		this.set(oe.pageX, oe.pageY);
	}

	return this;
}

MPPoint.prototype.fromRelativePointer = function(e, mpctx)
{
	this.fromPointer(e);
	
	var offset = mpctx.canvas.getBoundingClientRect();
	this.x = (this.x - offset.left) * mpctx.devicePixelRatio;
	this.y = (this.y - offset.top) * mpctx.devicePixelRatio;
	this.x = (this.x - mpctx.matrix[4]) / mpctx.matrix[0];
	this.y = (this.y - mpctx.matrix[5]) / mpctx.matrix[3];

	return this;
}

MPPoint.prototype.fromMultiTouchCenter = function(e)
{
	var t = e.originalEvent.targetTouches;
	if(t.length > 1)
	{
		this.x = t[0].pageX;
		this.y = t[0].pageY;
		for(var i = 1; i < t.length; i++)
		{
			this.x += t[i].pageX;
			this.y += t[i].pageY;
		}
		this.x /= t.length;
		this.y /= t.length;
	}

	return this;
}
/**
 * This file is part of MolView (http://molview.org)
 * Copyright (c) 2014, 2015 Herman Bergwerf
 *
 * MolView is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MolView is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with MolView.  If not, see <http://www.gnu.org/licenses/>.
 */

function MPLine(obj)
{
    this.from = obj !== undefined ? obj.from.clone() || new MPPoint() : new MPPoint();
    this.to = obj !== undefined ? obj.to.clone() || new MPPoint() : new MPPoint();
}

/* function lineLineIntersection(x1, y1, x2, y2, x3, y3, x4, y4)
{
    var div = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    return {
        x: ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / div,
        y: ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / div
    };
} */

MPLine.prototype.intersection = function(line)
{
    var denominator = ((line.to.y - line.from.y) * (this.to.x - this.from.x))
                    - ((line.to.x - line.from.x) * (this.to.y - this.from.y));

    if(denominator === 0)
    {
        return {
            p: undefined,
            onL1: false,
            onL2: false
        };
    }

    var a = this.from.y - line.from.y;
    var b = this.from.x - line.from.x;
    var numerator1 = ((line.to.x - line.from.x) * a) - ((line.to.y - line.from.y) * b);
    var numerator2 = ((this.to.x - this.from.x) * a) - ((this.to.y - this.from.y) * b);
    a = numerator1 / denominator;
    b = numerator2 / denominator;

    return {
        p: MPPFO({
            x: this.from.x + (a * (this.to.x - this.from.x)),
            y: this.from.y + (a * (this.to.y - this.from.y))
        }),
        //if line2 is a segment and line1 is infinite, they intersect if
        onL1: a > 0 && a < 1,
        //if line2 is a segment and line1 is infinite, they intersect if:
        onL2: b > 0 && b < 1
    };
}

MPLine.prototype.length = function()
{
    return this.from.distanceTo(this.to);
}
/**
 * This file is part of MolView (http://molview.org)
 * Copyright (c) 2014, 2015 Herman Bergwerf
 *
 * MolView is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MolView is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with MolView.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Input fragment data for MolPad
 * 1. you can pass this data as tool.data.frag
 * 2. all fragments use bondLength = 1 as default
 * 3. you have to multiply all coordinates with the real bondLength
 * 4. all fragments are centered on the positive side of the x-axis
 * 5. you can rotate the fragment coordinates around (0, 0)
 * 6. the first atom in each fragment.toAtom is the atom you have to connect to
 *    when adding the fragment to an atom
 * 7. the first and the last atom in each fragment.toBond are the atoms
 *    you have to merge with (first => from, last => to)
 */
var MPFragments = {
	benzene: {},
	cyclopropane: {},
	cyclobutane: {},
	cyclopentane: {},
	cyclohexane: {},
	cycloheptane: {},

	length: 1,
	lengthHydrogen: 34 / 55,//same as MolPad

	init: function()
	{
		//generate all fragments
		this.benzene = this.generateRing(6, true);
		this.cyclopropane = this.generateRing(3, false);
		this.cyclobutane = this.generateRing(4, false);
		this.cyclopentane = this.generateRing(5, false);
		this.cyclohexane = this.generateRing(6, false);
		this.cycloheptane = this.generateRing(7, false);
	},

	generateRing: function(vertices, alternating)
	{
		var as = PI2 / vertices;//angle step
		var r = 0.5 / Math.sin(as / 2) * this.length;

		var ret = {
			full: this.createRing(vertices, alternating ? 2 : 0),
			toAtom: this.translate(this.createRing(vertices, alternating ? 2 : 0), r, 0),//move bond start to (0,0)
			toBond: this.rotate(this.translate(this.createRing(vertices, alternating ? 2 : 0), r, 0),
					{ x: 0, y: 0 }, (Math.PI - as) / 2)//move bond start to (0,0), make first bond horizontal
		};
		return ret;
	},

	/**
	 * Create ring data
	 * @param {Integer} vertices    Number of ring vertices
	 * @param {Integer} alternating Double/single bond alternation:
	 *                              0 = none
	 *                              1 = first double on odd bonds
	 *                              2 = first double on even bonds
	 */
	createRing: function(vertices, alternating)
	{
		var frag = { atoms: [], bonds: [] };
		var as = PI2 / vertices;//angle step
		frag.r = 0.5 / Math.sin(as / 2) * this.length;

		//ring
		for(var i = 0; i < vertices; i++)
		{
			//move a = 0 to left side to apply rule 4
			frag.atoms.push({
				center: new MPPoint(
					frag.r * Math.cos(Math.PI + as * i),//start at the left side
					frag.r * Math.sin(Math.PI + as * i)),
				element: "C"
			});
			frag.bonds.push({
				from: i,
				to: i + 1 < vertices ? i + 1 : 0,
				type: alternating !== 0 ? (i % 2 === (2 - alternating) ? MP_BOND_SINGLE : MP_BOND_DOUBLE) : MP_BOND_SINGLE
			});
		}

		return frag;
	},

	clone: function(frag)
	{
		var copy = { atoms: [], bonds: [], r: frag.r };

		for(var i = 0; i < frag.atoms.length; i++)
		{
			copy.atoms.push({
				center: frag.atoms[i].center.clone(),
				element: frag.atoms[i].element
			});
		}

		for(var i = 0; i < frag.bonds.length; i++)
		{
			copy.bonds.push({
				from: frag.bonds[i].from,
				to: frag.bonds[i].to,
				type: frag.bonds[i].type
			});
		}

		return copy;
	},

	scale: function(frag, scale)
	{
		for(var i = 0; i < frag.atoms.length; i++)
		{
			frag.atoms[i].center.scale(scale);
		}
		return frag;
	},

	rotate: function(frag, center, angle)
	{
		for(var i = 0; i < frag.atoms.length; i++)
		{
			frag.atoms[i].center.rotateAroundCenter(center, angle);
		}
		return frag;
	},

	translate: function(frag, dx, dy)
	{
		for(var i = 0; i < frag.atoms.length; i++)
		{
			frag.atoms[i].center.translate(dx, dy);
		}
		return frag;
	}
};
/**
 * This file is part of MolView (http://molview.org)
 * Copyright (c) 2014, 2015 Herman Bergwerf
 *
 * MolView is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MolView is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with MolView.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Create new MPAtom
 * @param {MolPad} mp
 * @param {Object} obj Configuration
 */
function MPAtom(mp, obj)
{
	this.mp = mp;
	this.index = obj.i;
	this.center = new MPPoint(obj.x || 0, obj.y || 0);
	this.element = obj.element || "C";
	this.charge = obj.charge || 0;
	this.isotope = obj.isotope || 0;
	this.bonds = obj.bonds !== undefined ? obj.bonds.slice() : [];//deep copy
	this.selected = obj.selected || false;
	this.display = "normal";
	this.valid = false;
	this.mp.requestRedraw();
}

MPAtom.prototype.getX = function() { return this.center.x; }
MPAtom.prototype.getY = function() { return this.center.y; }

/**
 * Retruns data which can be used as input by the Ketcher fork
 * @param {Object} mp
 * @return {Object}
 */
MPAtom.prototype.getKetcherData = function()
{
	return new chem.Struct.Atom({
		pp: {
			x: this.center.x / this.mp.s.bond.length,
			y: this.center.y / this.mp.s.bond.length
		},
		label: this.element,
		charge: this.charge,
		isotope: this.isotope
	});
}

/**
 * Retruns config data which can be used to reconstruct this object
 * @return {Object}
 */
MPAtom.prototype.getConfig = function()
{
	return {
		i: this.index,
		x: this.center.x,
		y: this.center.y,
		element: this.element,
		charge: this.charge,
		isotope: this.isotope,
		bonds: this.bonds.slice()
	};
}

/**
 * Retruns MPAtom string which can be compared to other MPAtom strings
 * @return {String}
 */
MPAtom.prototype.toString = function()
{
	var str = this.center.x.toString() + ","
		+ this.center.y.toString() + ","
		+ this.element.toString() + ","
		+ this.charge.toString() + ","
		+ this.isotope.toString();

	for(var i = 0; i < this.bonds.length; i++)
	{
		str += "," + this.mp.mol.bonds[this.bonds[i]].toString();
	}

	return str;
}

/**
 * Generates charge label for this atom
 * @return {String} Charge label as string
 */
MPAtom.prototype.getChargeLabel = function()
{
	return this.charge === 0 ? "" :
		this.charge === -1 ? "\u2212" :
		this.charge ===  1 ? "+" :
			(this.charge > 1 ? "+" : "-") + Math.abs(this.charge);
}

MPAtom.prototype.setIndex = function(index) { this.index = index; }

MPAtom.prototype.setCenter = function(x, y)
{
	this.center.replace(x, y);
	this.centerChanged();
}

MPAtom.prototype.setElement = function(element)
{
	this.element = element === "D" ? "H" : element;
	this.labelChanged();
}

MPAtom.prototype.setCharge = function(charge)
{
	this.charge = charge;
	this.labelChanged();
}

MPAtom.prototype.setIsotope = function(isotope)
{
	this.isotope = isotope;
	this.labelChanged();
}

/**
 * Sets display type
 * @param {String} type
 */
MPAtom.prototype.setDisplay = function(type)
{
	if(type !== this.display)
	{
		this.display = type;
		this.mp.requestRedraw();
	}
}

/**
 * Checks if this MPAtom is equal to another MPAtom
 * @param  {MPAtom} atom
 * @return {Booelan}
 */
MPAtom.prototype.equals = function(atom)
{
	return this.index === atom.index;
}

/**
 * Returns number of selected bonds
 * @return {Integer}
 */
MPAtom.prototype.getSelectedBonds = function()
{
	var ret = 0;
	for(var i = 0; i < this.bonds.length; i++)
	{
		if(this.mp.mol.bonds[this.bonds[i]].isSelected())
		{
			ret++;
		}
	}
	return ret;
}

/**
 * Checks if the given index is a neighbor atom and return connecting bond
 * @param  {Integer} idx
 * @return {Integer} Bond index or -1
 */
MPAtom.prototype.getNeighborBond = function(idx)
{
	for(var i = 0; i < this.bonds.length; i++)
	{
		if(this.mp.mol.bonds[this.bonds[i]].getOppositeAtom(this.index) === idx)
		{
			return this.bonds[i];
		}
	}
	return -1;
}

/**
 * Returns if this atom has any neighbor atoms which are not selected
 */
MPAtom.prototype.hasUnselectedNeighbors = function()
{
	for(var i = 0; i < this.bonds.length; i++)
	{
		if(!this.mp.mol.atoms[this.mp.mol.bonds[this.bonds[i]]
			.getOppositeAtom(this.index)].isSelected())
		{
			return true;
		}
	}
	return false;
}

/**
 * Wrapper for MPAtom.selected (for maintainability)
 */
MPAtom.prototype.isSelected = function()
{
	return this.selected;
}

/**
 * Finds this MPAtom if it is an implicit hydrogen atom
 * All H atoms bonded to a C atom without stereo information are considered implicit
 * @return {Boolean}    Indicates if this atom is implicit
 */
MPAtom.prototype.isImplicit = function()
{
	if(this.element === "H" && this.isotope === 0 &&
			this.charge === 0 && this.bonds.length === 1)
	{
		var bond = this.mp.mol.bonds[this.bonds[0]];
		if(bond.type === MP_BOND_SINGLE && bond.stereo === MP_STEREO_NONE &&
			bond.isPair("C", "H"))
		{
			return true;
		}
	}
	return false;
}

/**
 * Checks is this MPAtom is hidden (not the same as invisible)
 */
MPAtom.prototype.isHidden = function()
{
	return this.display === "hidden";
}

/**
 * Checks if this MPAtom is visible in the drawing based on MolPad display settings
 */
MPAtom.prototype.isVisible = function()
{
	return this.wasVisible === true;
}

/**
 * Selects or deselects this MPAtom
 * @param {Boolean} select
 */
MPAtom.prototype.select = function(select)
{
	if(this.isSelected() !== select)
	{
		this.selected = select;
		this.mp.sel.update();
		this.mp.requestRedraw();
	}
}

/**
 * MPPoint.translate wrapper of atom center point
 */
MPAtom.prototype.translate = function(dx, dy)
{
	if(Math.abs(dx) + Math.abs(dy) > 0)
	{
		this.center.translate(dx, dy);
		this.centerChanged();
	}
}

/**
 * MPPoint.mirror wrapper of atom center point
 */
MPAtom.prototype.mirror = function(line, s)
{
	if(this.center.mirror(line, s))
	{
		this.centerChanged();
	}
}

/**
 * MPPoint.rotateAroundCenter wrapper of atom center point
 */
MPAtom.prototype.rotateAroundCenter = function(c, a)
{
	this.center.rotateAroundCenter(c, a);
	this.centerChanged();
}

/**
 * Returns total bond count
 */
MPAtom.prototype.getBondCount = function()
{
	var ret = 0;
	for(var i = 0; i < this.bonds.length; i++)
	{
		ret += this.mp.mol.bonds[this.bonds[i]].type;
	}
	return ret;
}

/**
 * Add bond index to this atom
 * @param {Integer} bond Bond index
 */
MPAtom.prototype.addBond = function(bond)
{
	if(this.bonds.indexOf(bond) === -1)
	{
		this.bonds.push(bond);
		this.bondsChanged();
	}
}

/**
 * Remove bond index from this atom
 * @param {Integer} bond Bond index
 */
MPAtom.prototype.removeBond = function(bond)
{
	var i = this.bonds.indexOf(bond);
	if(i !== -1)
	{
		this.bonds.splice(i, 1);
		this.bondsChanged();
	}
}

/**
 * Map bond indices using an index map
 * The map should contain the new indexes as follows: map[old] = new
 * If map[old] === undefined, the old index is removed from the bonds list
 *
 * @param {Array}   map
 */
MPAtom.prototype.mapBonds = function(map)
{
	var length = this.bonds.length;
	this.bonds = mapArray(this.bonds, map);

	if(this.bonds.length !== length)
	{
		this.bondsChanged();
	}

	/* CAUTION: this.invalidate should not be triggerd since it might
	hurt the mapping process */
}

/**
 * Replace a given bond index with another bond index
 * @param {Integer} o Old bond index
 * @param {Integer} n New bond index
 */
MPAtom.prototype.replaceBond = function(o, n)
{
	var idx = this.bonds.indexOf(o);
	var nidx = this.bonds.indexOf(n);

	if(idx !== -1)
	{
		if(nidx !== -1) this.bonds.splice(o, 1);
		else this.bonds[idx] = n;
	}

	this.bondsChanged();
}

/**
 * Adds new bond to this atom using the given element and angle
 * Does not redraw the canvas
 * @param  {Object} config { element, a, type, stereo }
 * @return {Object}        Tool data for this bond
 */
MPAtom.prototype.addNewBond = function(config)
{
	var atom = new MPAtom(this.mp, {
		i: this.mp.mol.atoms.length,
		x: this.getX() + (config.length || this.mp.s.bond.length) * Math.cos(config.a),
		y: this.getY() - (config.length || this.mp.s.bond.length) * Math.sin(config.a),//y axis is flipped
		element: config.element || "C"
	});

	var bond = new MPBond(this.mp, {
		i: this.mp.mol.bonds.length,
		type: config.type || MP_BOND_SINGLE,
		stereo: config.stereo || MP_STEREO_NONE,
		from: this.index,
		to: atom.index
	});

	this.mp.mol.atoms.push(atom);
	this.mp.mol.bonds.push(bond);

	atom.addBond(bond.index);
	this.addBond(bond.index);

	return {
		atom: atom.index,
		bond: bond.index,
		startAngle: config.a,
		currentAngle: config.a
	};
}

/**
 * Saturate atom with hydrogens
 * C atoms are saturated using their four binding sites
 */
MPAtom.prototype.addImplicitHydrogen = function()
{
	if(this.element === "C")
	{
		if(this.getBondCount() === 2 && this.bonds.length === 2)
		{
			var af = this.mp.mol.bonds[this.bonds[0]].getAngle(this);
			var at = this.mp.mol.bonds[this.bonds[1]].getAngle(this);
			var da = Math.max(af, at) - Math.min(af, at);

			//do only display 2 Hydrogens on one side if the bonds are not straight
			if(indev(da, Math.PI, this.mp.s.bond.angleDev))
			{
				var a = this.calculateNewBondAngle(2);
				if(a === 0) return;

				this.addNewBond({
					a: a[0],
					length: this.mp.s.bond.lengthHydrogen,
					element: "H"
				});
				this.addNewBond({
					a: a[1],
					length: this.mp.s.bond.lengthHydrogen,
					element: "H"
				});

				return;
			}
		}

		while(this.getBondCount() < 4)
		{
			this.cmap = this.calculateConnectionMap();
			var a = this.calculateNewBondAngle();
			this.addNewBond({
				a: a,
				length: this.mp.s.bond.lengthHydrogen,
				element: "H"
			});
		}
	}
}

/**
 * Invalidate cached render data
 */
MPAtom.prototype.invalidate = function()
{
	this.valid = false;
	this.mp.requestRedraw();
}

/**
 * Invalidation helper called when MPAtom.center has changed
 */
MPAtom.prototype.centerChanged = function()
{
	this.invalidate();
	for(var i = 0; i < this.bonds.length; i++)
	{
		this.mp.mol.bonds[this.bonds[i]].invalidate();
		this.mp.mol.atoms[this.mp.mol.bonds[this.bonds[i]].getOppositeAtom(this.index)].bondsChanged(true);
	}
	this.cmap = this.calculateConnectionMap();
}

/**
 * Invalidation helper called when MPAtom label has changed
 */
MPAtom.prototype.labelChanged = function()
{
	this.invalidate();
	this.line = undefined;
	for(var i = 0; i < this.bonds.length; i++)
	{
		this.mp.mol.bonds[this.bonds[i]].invalidate();
		this.mp.mol.atoms[this.mp.mol.bonds[this.bonds[i]].getOppositeAtom(this.index)].bondsChanged();
	}
}

/**
 * Invalidation helper called when connected bonds are changed
 */
MPAtom.prototype.bondsChanged = function(moved)
{
	this.invalidate();
	if(this.mp.s.skeletalDisplay)
	{
		for(var i = 0; i < this.bonds.length; i++)
		{
			this.mp.mol.bonds[this.bonds[i]].invalidate();
		}
	}
}

/**
 * Validate this MPAtom by updating all its drawing data
 */
MPAtom.prototype.validate = function()
{
	if(this.valid) return;
	this.valid = true;
	this.wasVisible = this.calculateVisibility();
	this.cmap = this.calculateConnectionMap();

	/* IMPORTANT NOTE: you have to invalidate the MPAtom AND make its
	line object undefined in order to recalculate it. This is a trick
	to increase efficiency as the atom label line does not have to be
	recalculated after each invalidation */
	if(this.line === undefined) this.line = this.calculateCenterLine();
}

/**
 * Render methods
 */

/**
 * Draw additional MPAtom background based on MPAtom.display
 */
MPAtom.prototype.drawStateColor = function()
{
	if(this.isHidden() || this.line === undefined) return;

	var incorrect = false;//this.element == "C" && this.getBondCount() > 4;
	/* incorrect is currently not really working since the red is sometimes
	draw between other green selection areas and because the invalidation is not
	working correctly when adding fragments which are not yet collapsed */

	if(this.display === "hover" || this.display === "active" ||
			(this.display === "normal" && this.isSelected()) || incorrect)
	{
		var d = incorrect ? "incorrect" : (this.isSelected() ? "selected" : this.display);

		this.mp.ctx.beginPath();
		if(this.line.area.point)
		{
			this.mp.ctx.arc(this.center.x, this.center.y,
					this.mp.s.atom.selectionRadiusScaled, 0, PI2);
			this.mp.ctx.fillStyle = this.mp.s.atom[d].color;
			this.mp.ctx.fill();
		}
		else
		{
			this.mp.ctx.moveTo(this.center.x + this.line.area.left, this.center.y);
			this.mp.ctx.lineTo(this.center.x + this.line.area.right, this.center.y);
			this.mp.ctx.strokeStyle = this.mp.s.atom[d].color;
			this.mp.ctx.stroke();
		}
	}
}

/**
 * Draw actual atom label
 */
MPAtom.prototype.drawLabel = function()
{
	//TODO: add support for collapsed groups (CH2- to H2C-, OH- to HO-, etc.)

	if(this.isHidden() || this.line === undefined) return;

	if(this.isVisible())
	{
		if(this.mp.s.atom.colored)
		{
			this.mp.ctx.fillStyle = JmolAtomColorsHashHex[this.element] || JmolAtomColorsHashHex["C"];
		}

		if(this.mp.s.atom.miniLabel)
		{
			var s = this.mp.s.atom.miniLabelSize;
			this.mp.ctx.fillRect(this.center.x - s / 2, this.center.y - s / 2, s, s);
		}
		else
		{
			var x = this.center.x + this.line.text.offsetLeft;

			if(this.isotope > 0)
			{
				this.mp.setFont("isotope");
				this.mp.ctx.fillText("" + this.isotope, x, this.center.y +
						this.line.text.offsetTop - this.line.text.isotopeHeight);
				x += this.line.text.isotopeWidth;
			}

			this.mp.setFont("element");
			this.mp.ctx.fillText("" + this.element, x, this.center.y + this.line.text.offsetTop);
			x += this.line.text.labelWidth;

			if(this.charge !== 0)
			{
				this.mp.setFont("charge");
				this.mp.ctx.fillText(this.getChargeLabel(), x, this.center.y +
						this.line.text.offsetTop - this.line.text.chargeHeight);
			}
		}
	}
}
/**
* This file is part of MolView (http://molview.org)
* Copyright (c) 2014, 2015 Herman Bergwerf
*
* MolView is free software: you can redistribute it and/or modify
* it under the terms of the GNU Affero General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* MolView is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Affero General Public License for more details.
*
* You should have received a copy of the GNU Affero General Public License
* along with MolView.  If not, see <http://www.gnu.org/licenses/>.
*/


MPAtom.prototype.calculateConnectionMap = function()
{
	if(this.bonds.length === 0) return 0;

	//create bond map with bond angles
	var bondMap = [];
	for(var i = 0; i < this.bonds.length; i++)
	{
		bondMap.push({
			i: this.bonds[i],
			a: this.mp.mol.bonds[this.bonds[i]].getAngle(this)
		});
	}

	//sort bondMap in ascending bond angle order
	bondMap.sort(function(a, b)
	{
		return a.a - b.a;
	});

	//convert bondMap to sections
	var sections = [];
	for(var i = 0; i < bondMap.length; i++)
	{
		var from = i === 0 ? bondMap.length - 1 : i - 1;
		var to = i;
		sections.push({
			from: from,
			to: to,
			a: angleBetween(bondMap[from].a, bondMap[to].a)
		});
	}

	return {
		bondMap: bondMap,
		sections: sections
	}
}

/**
 * Calculates the closest upper and lower bond for the given bond index
 * @param  {Integer} index
 * @return {Object}
 */
MPAtom.prototype.calculateClosestBonds = function(index)
{
	for(var i = 0; i < this.cmap.bondMap.length; i++)
	{
		if(this.cmap.bondMap[i].i === index)
		{
			var upper = i + 1 < this.cmap.bondMap.length ? i + 1 : 0;
			var lower = i - 1 >= 0 ? i - 1 : this.cmap.bondMap.length - 1;
			return {
				none: false,
				upper: this.cmap.bondMap[upper].i,
				lower: this.cmap.bondMap[lower].i,
				upperBisectAngle: (this.cmap.bondMap[upper].a + this.cmap.bondMap[i].a) / 2,
				lowerBisectAngle: (this.cmap.bondMap[lower].a + this.cmap.bondMap[i].a) / 2,
				upperSectionAngle: angleBetween(this.cmap.bondMap[i].a, this.cmap.bondMap[upper].a),
				lowerSectionAngle: angleBetween(this.cmap.bondMap[lower].a, this.cmap.bondMap[i].a)
			};
		}
	}
	return { none: true };
}

/**
 * Calculated the angle for a new bond from this atom by calculating all
 * segments between existing bonds and dividing the largest segment by two
 *
 * @param  {Integer} n Optional number of new segments the larges segment
 *                     should be divided in
 * @return {Float} (if n === undefined) or {Array}
 */
MPAtom.prototype.calculateNewBondAngle = function(n)
{
	if(this.bonds.length === 0 || this.cmap === undefined) return 0;

	//find larges section
	var largest = 0;//skip i = 0 since it is already used for the first comparison
	for(var i = 1; i < this.cmap.sections.length; i++)
	{
		if(this.cmap.sections[i].a > this.cmap.sections[largest].a)
		{
			largest = i;
		}
	}

	//find new bond angle
	if(n === undefined)
	{
		return this.cmap.bondMap[this.cmap.sections[largest].from].a + this.cmap.sections[largest].a / 2;
	}
	else
	{
		var p = n !== undefined ? n + 1 : 2;
		var a = this.cmap.sections[largest].a / (n + 1);
		var ret = [];
		for(var i = 1; i <= n; i++)
		{
			ret.push(this.cmap.bondMap[this.cmap.sections[largest].from].a + i * a);
		}
		return ret;
	}
}

/**
 * Returns MPAtom area as a line with a surrounding area defined by a radius
 * (area border: d(P, line) = r) and the label drawing box outline
 *
 * @return {Object} Area line or point:
 *                  { from: { x: 0, y: 0 }} or
 *                  { from: { x: 0, y: 0 }, to: { x: 0, y: 0 } }
 *                  Label drawing box:
 *                  { offsetLeft: 0, offsetTop: 0 }
 */
MPAtom.prototype.calculateCenterLine = function()
{
	if(this.mp.s.atom.miniLabel)
	{
		return {
			text: { offsetLeft: 0, offsetTop: 0 },
			area: { point: true }
		};
	}

	var scale = this.mp.s.atom.scale;
	var text = {};

	this.mp.setFont("element");
	text.labelWidth = this.mp.ctx.measureText("" + this.element).width;
	var w = text.labelWidth;

	if(this.isotope > 0)
	{
		this.mp.setFont("isotope");
		text.isotopeHeight = this.mp.s.fonts.isotope.fontSize * scale;
		text.isotopeWidth = this.mp.ctx.measureText("" + this.isotope).width +
				this.mp.s.atom.isotope.padding * scale;//padding before element label
		w += text.isotopeWidth;
	}

	if(this.charge !== 0)
	{
		this.mp.setFont("charge");
		text.chargeHeight = this.mp.s.fonts.charge.fontSize * scale;
		text.chargeWidth = this.mp.ctx.measureText("" + this.getChargeLabel()).width;

		//add padding between element and charge
		text.labelWidth += this.mp.s.atom.charge.padding * scale;

		//add chargeWidth to total width + additional label padding
		w += text.chargeWidth + this.mp.s.atom.charge.padding * scale;
	}

	var h = this.mp.s.fonts.element.fontSize * scale;
	var halfw = w / 2;
	text.offsetLeft = -halfw;
	text.offsetTop = h / 2;

	if(w > this.mp.s.atom.circleClamp)
	{
		var pad = this.mp.s.atom.radius * scale - h / 2;
		return {
			text: text,
			area: {
				half: halfw + pad,
				left: -halfw + pad,
				right: halfw - pad
			}
		};
	}
	else
	{
		return {
			text: text,
			area: { point: true }
		};
	}
}

/**
 * _calculateBondVertices wrapper with origin atom index as argument
 * @param  {Integer} from Origin atom index
 * @param  {Array}   ends
 * @return {Array}        Calculated ends
 */
MPAtom.prototype.calculateBondVertices = function(from, ends)
{
	var begin = this.mp.mol.atoms[from].center;
	return this._calculateBondVertices(begin, ends);
}

/**
 * Calculate bond attach vertices for a bond from $begin to $this.center
 * Note that positive ends will end up at the lower side because of the
 * HTML5 canvas coordinate system
 *
 * @param  {MPPoint} begin Origin point
 * @param  {Array}   ends  Requested end vertices perpendicular to the end of line $begin$this.center
 *                         (values are in counter clockwise direction)
 * @return {Array}         Calculated ends
 */
MPAtom.prototype._calculateBondVertices = function(begin, ends)
{
	//TODO: implement bonding site for collapsed groups (only left or right)

	if(begin.x === this.center.x
			|| this.hidden || this.line === undefined)//provide fallback
	{
		var ret = [];
		var r = this.isVisible() ? this.mp.s.atom.radius : 0;
		var below = begin.y < this.center.y;
		for(var i = 0; i < ends.length; i++)
		{
			ret.push(MPPFO({
				x: this.center.x + (below ? ends[i] : -ends[i]),//counter clockwise
				y: this.center.y + (below ? -r : r)
			}));
		}
		return ret;
	}
	else if(begin.y === this.center.y)
	{
		var ret = [];
		var r = this.isVisible() ? this.line.area.half  || this.mp.s.atom.radius : 0;
		var right = begin.x > this.center.x;
		for(var i = 0; i < ends.length; i++)
		{
			ret.push(MPPFO({
				x: this.center.x + (right ? r : -r),
				y: this.center.y + (right ? ends[i] : -ends[i])//counter clockwise
			}));
		}
		return ret;
	}
	else if(!this.isVisible())
	{
		if(ends.length === 1 && ends[0] === 0)
		{
			return [MPPFO({ x: this.center.x, y: this.center.y })];
		}
		else
		{
			var dx = begin.x - this.center.x;
			var dy = begin.y - this.center.y;
			var d = Math.sqrt(dx * dx + dy * dy);
			var A = dx / d;//dx = a = A * c = d
			var B = dy / d;//dy = b = B * c = d

			var ret = [];
			for(var i = 0; i < ends.length; i++)
			{
				ret.push(MPPFO({
					x: -B * ends[i],
					y: A * ends[i]
				}));
			}

			//translate to real center
			for(var i = 0; i < ret.length; i++)
			{
				ret[i].x += this.center.x;
				ret[i].y += this.center.y;
			}

			return ret;
		}
	}
	else
	{
		var ac = this.center;//aligin center
		var bc = this.center;//bond center
		var tdir = 1;//tangent direction

		if(this.line.area.left && begin.x < this.center.x)
		{
			ac = new MPPoint(this.center.x + this.line.area.left, this.center.y);
		}
		else if(this.line.area.right && begin.x > this.center.x)
		{
			ac = new MPPoint(this.center.x + this.line.area.right, this.center.y);
			tdir = -1;
		}

		var acbc = Math.abs(ac.x - bc.x);//distance between align center and bond center
		var r = this.mp.s.atom.radius;
		var dx = begin.x - bc.x;
		var dy = begin.y - bc.y;
		var d = Math.sqrt(dx * dx + dy * dy);
		var A = dx / d;//dx = a = A * c = d
		var B = dy / d;//dy = b = B * c = d

		//alignCenter tangent crossing with bond line
		var td = (tdir > 0 ? r - A * acbc : r + A * acbc);
		var tx = A * td;
		var ty = B * td;

		var x = bc.x + tx;
		var y = bc.y + ty;

		var ret = [];
		for(var i = 0; i < ends.length; i++)
		{
			ret.push(MPPFO({
				x: x - B * ends[i],
				y: y + A * ends[i]
			}));
		}
		return ret;
	}
}

MPAtom.prototype.calculateVisibility = function()
{
	if(this.isHidden())
	{
		return false;
	}
	else if(this.mp.s.skeletalDisplay)
	{
		if(this.element === "C" && this.charge === 0 && this.isotope === 0)
		{
			if(this.bonds.length === 0)
			{
				return true;
			}
			else
			{
				if(this.bonds.length === 2
				&& this.mp.mol.bonds[this.bonds[0]].type === this.mp.mol.bonds[this.bonds[1]].type
				&& this.mp.mol.bonds[this.bonds[0]].stereo === this.mp.mol.bonds[this.bonds[1]].stereo)
				{
					var af = this.mp.mol.bonds[this.bonds[0]].getAngle(this);
					var at = this.mp.mol.bonds[this.bonds[1]].getAngle(this);
					var da = Math.max(af, at) - Math.min(af, at);

					//display atom anyway if the bonds are straight
					if(indev(da, Math.PI, this.mp.s.bond.angleDev))
					{
						return true;
					}
					else return false;
				}
				else return false;
			}
		}
		return true;
	}
	else return true;
}
/**
 * This file is part of MolView (http://molview.org)
 * Copyright (c) 2014, 2015 Herman Bergwerf
 *
 * MolView is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MolView is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with MolView.  If not, see <http://www.gnu.org/licenses/>.
 */

MPAtom.prototype.getHandler = function()
{
	//TODO: calculateNewBondAngle use lone-pairs and valence

	if(this.mp.tool.type === "atom")
	{
		return {
			scope: this,
			data: {},
			onPointerDown: function(e, mp)
			{
				this.data = {
					atom: -1,
					oldElement: this.scope.element
				};

				this.scope.setElement(mp.tool.data.element);
			},
			onPointerMove: function(e, mp)
			{
				var p = new MPPoint().fromRelativePointer(e, mp);

				//check if pointer is outside no-rotate circle
				if(!p.inCircle(this.scope.center, mp.s.atom.minAddRotateLength))
				{
					//create target atom if no target atom has been created yet
					if(this.data.atom === -1)
					{
						this.scope.setElement(this.data.oldElement);
						this.data.startAngle = this.scope.calculateNewBondAngle();
						this.data = this.scope.addNewBond({
							a: this.data.startAngle,
							type: mp.tool.data.type || MP_BOND_SINGLE,
							stereo: mp.tool.data.stereo || MP_STEREO_NONE,
							element: mp.tool.data.element
						});
					}

					//rotate the target atom around this atom
					this.data.currentAngle = mp.mol.rotateAtoms(
							this.scope.center, p, [this.data.atom],
							this.data.currentAngle,
							this.data.startAngle,
							mp.s.rotateSteps);
				}
			},
			onPointerUp: function(e, mp)
			{
				if(this.data.atom !== -1)
				{
					mp.mol.collapseAtoms([this.data.atom], true);
				}
			}
		};
	}
	else if(this.mp.tool.type === "bond")
	{
		return {
			scope: this,
			data: {},
			onPointerDown: function(e, mp)
			{
				var a = this.scope.calculateNewBondAngle();

				this.data = this.scope.addNewBond({
					a: a,
					type: mp.tool.data.type || MP_BOND_SINGLE,
					stereo: mp.tool.data.stereo || MP_STEREO_NONE,
					element: mp.tool.data.element
				});
			},
			onPointerMove: function(e, mp)
			{
				var p = new MPPoint().fromRelativePointer(e, mp);
				var bond = mp.mol.bonds[this.data.bond];

				//check for hovered secondary atoms
				for(var i = 0; i < mp.mol.atoms.length; i++)
				{
					//this atom and the new atom do not participate
					if(i === this.scope.index || i === this.data.atom) continue;

					//check for hover using active as event type
					if(mp.mol.atoms[i].handle(p, "active"))
					{
						//skip if the hovered atom is already the target atom
						if(bond.to !== i)
						{
							//reset old target atom to normal display
							//(for the almost impossible case MPAtom.handle is not reached yet)
							mp.mol.atoms[bond.to].setDisplay("normal");
							mp.mol.atoms[bond.to].removeBond(bond.index);

							//hide newly created target atom
							mp.mol.atoms[this.data.atom].setDisplay("hidden");

							//set target atom to new atom
							bond.setTo(i);

							//invalidate new atom
							mp.mol.atoms[i].addBond(bond.index);

							//check if new target atom is a neighbor of this atom
							var n = this.scope.getNeighborBond(i);
							if(n !== -1 && n !== this.data.bond)
							{
								//if so, check if we handled this neighbor before
								if(n !== this.data.neighbor)
								{
									//if not, save the neighbor bond index
									this.data.neighbor = n;

									//and hide the neighbor bond
									//(in order to replace it with this bond)
									mp.mol.bonds[n].setDisplay("hidden");
								}
							}
							else
							{
								//check if there is a neighbor bond we handled before
								if(this.data.neighbor !== undefined)
								{
									//if so, show this bond again and remove it from this.data
									mp.mol.bonds[this.data.neighbor].setDisplay("normal");
									this.data.neighbor = undefined;
								}
							}
						}

						//return so the next blocks of code are not reached
						return;
					}
				}

				//no hovered secondary atom so reset bond.to to this.data.atom
				if(bond.to !== this.data.atom)
				{
					//reshow newly created atom, this wil also invalidate the new bond
					mp.mol.atoms[this.data.atom].setDisplay("normal");

					//check if there is a neighbor bond we handled before
					if(this.data.neighbor !== undefined)
					{
						//if so, reshow this bond again and remove it from this.data
						mp.mol.bonds[this.data.neighbor].setDisplay("normal");
						this.data.neighbor = undefined;
					}

					//reset target atom
					mp.mol.atoms[bond.to].removeBond(bond.index);
					mp.mol.atoms[this.data.atom].addBond(bond.index);
					bond.setTo(this.data.atom);
				}

				//check if pointer is outside no-rotate circle
				if(!p.inCircle(this.scope.center, mp.s.atom.minAddRotateLength))
				{
					//if so, rotate the target atom around this atom
					this.data.currentAngle = mp.mol.rotateAtoms(
							this.scope.center, p, [this.data.atom],
							this.data.currentAngle,
							this.data.startAngle,
							mp.s.rotateSteps);
				}
			},
			onPointerUp: function(e, mp)
			{
				//get final target atom
				var to = mp.mol.bonds[this.data.bond].to;

				//check if final target atom is the newly created one
				if(to !== this.data.atom)
				{
					//if not, add the newly created bond to the real target atom
					mp.mol.atoms[to].addBond(this.data.bond);
					mp.mol.atoms.pop();//and pop the last atom (old target)

					//if final target is connected via an old neighbor bond
					if(this.data.neighbor !== undefined)
					{
						//then remove the old neighbor
						mp.mol.bonds.splice(this.data.neighbor, 1);
						mp.mol.updateIndices();
					}
				}
				else//try merging target atom with an existing one
				{
					mp.mol.collapseAtoms([to], true);
				}
			}
		};
	}
	else if(this.mp.tool.type === "fragment")
	{
		return {
			scope: this,
			data: {},
			onPointerDown: function(e, mp)
			{
				//determine if the fragment will be connected using a bond
				var bondConnection = this.scope.getBondCount() > 2 && this.scope.element === "C";

				//clone new fragment and transform it
				this.data = {
					frag: MPFragments.translate(
						MPFragments.scale(
							MPFragments.translate(
								MPFragments.clone(mp.tool.data.frag.toAtom),
								bondConnection ? 1 : 0, 0),
							mp.s.bond.length),
							this.scope.center.x, this.scope.center.y)
				};

				//make sure the selection is cleared
				mp.sel.clear();

				//setup selection parameters
				mp.sel.currentAngle = mp.sel.startAngle =
						this.scope.calculateNewBondAngle();
				mp.sel.center = this.scope.center.clone();

				//rotate new fragment using .sel.centerthe currentAngle
				MPFragments.rotate(this.data.frag,
						this.scope.center, mp.sel.currentAngle);

				//create and select the fragment and store the new fragment data
				var frag = mp.mol.createFragment(this.data.frag, true);

				if(bondConnection)
				{
					var connection = new MPBond(mp, {
						i: mp.mol.bonds.length,
						type: MP_BOND_SINGLE,
						stereo: MP_STEREO_NONE,
						from: this.scope.index,
						to: frag.atoms[0],
						selected: true
					});

					mp.mol.bonds.push(connection);
					mp.mol.atoms[connection.to].addBond(connection.index);
					this.scope.addBond(connection.index);
					this.scope.select(true);
				}
				else
				{
					mp.mol.mergeAtoms(frag.atoms[0], this.scope.index);
				}
			},
			onPointerMove: function(e, mp)
			{
				var p = new MPPoint().fromRelativePointer(e, mp);

				//check if pointer is outside no-rotate circle
				if(!p.inCircle(this.scope.center, mp.s.atom.minAddRotateLength))
				{
					//if so, rotate the selection (fragment) around this atom
					mp.sel.rotate(p);
				}
			},
			onPointerUp: function(e, mp)
			{
				mp.sel.collapse();
				mp.sel.clear();
			}
		};
	}
	else if(this.mp.tool.type === "charge")
	{
		return {
			scope: this,
			onPointerDown: function(e, mp)
			{
				this.scope.setCharge(this.scope.charge + mp.tool.data.charge);
			}
		};
	}
	else if(this.mp.tool.type === "chain")
	{
		return {
			scope: this,
			data: {
				startAngle: 0,
				length: this.mp.s.bond.length * Math.cos(this.mp.s.chain.devAngle),
				chain: [],//chain vertices
				ra: undefined//repel angle
			},
			onDraw: function(mp)
			{
				//draw chain
				mp.ctx.strokeStyle = mp.s.chain.strokeStyle;
				mp.ctx.lineWidth = mp.s.bond.width * mp.s.bond.scale;
				mp.ctx.lineCap = mp.s.chain.lineCap;
				mp.ctx.lineJoin = mp.s.chain.lineJoin;
				mp.ctx.setLineDash([
					2 * mp.s.bond.scale,
					5 * mp.s.bond.scale
				]);

				mp.ctx.beginPath();

				for(var i = 0; i < this.data.chain.length; i++)
				{
					if(i === 0) mp.ctx.moveTo(this.data.chain[i].x, this.data.chain[i].y);
					else mp.ctx.lineTo(this.data.chain[i].x, this.data.chain[i].y);
				}

				mp.ctx.stroke();

				//draw chain size
				if(this.data.chain.length > 0)
				{
					mp.setFont("chainSize");
					mp.ctx.fillStyle = mp.s.chain.color;

					//calculate label dimensions
					var text = "" + this.data.size;
					var w = mp.ctx.measureText(text).width;
					var h = mp.s.atom.scale * mp.s.fonts.chainSize.fontSize;

					//calculate label center
					var lblc = this.data.chain[this.data.chain.length - 1].clone();//label center
					var r = mp.s.atom.scale * mp.s.chain.padding + (w > h ? w : h);//radius from last carbon atom to size label center
					lblc.x += r * Math.cos(this.data.a);
					lblc.y += r * Math.sin(-this.data.a);//flip y-axis
					lblc.x -= w / 2;
					lblc.y += h / 2;

					mp.ctx.fillText(text, lblc.x, lblc.y);
				}
			},
			onPointerDown: function(e, mp)
			{
				//calculate new startAngle
				this.data.startAngle = this.scope.calculateNewBondAngle();

				//calculate starting deviation side
				if(this.scope.bonds.length === 1)
				{
					//rotate angle of bond to the opposite side
					this.data.ra = posRad(mp.mol.bonds[this.scope.bonds[0]].getAngle(this.scope) + Math.PI);
				}
				else if(this.scope.bonds.length === 2)
				{
					//rotate new bond angle to opposite side to achieve reversed effect
					//(the chain will stick to the new bond angle)
					this.data.ra = posRad(this.scope.calculateNewBondAngle() + Math.PI);
				}
				else
				{
					this.data.ra = undefined;
				}
			},
			onPointerMove: function(e, mp)
			{
				var p = new MPPoint().fromRelativePointer(e, mp);

				//calculate new angle
				var a = clampedAngle(this.data.startAngle, this.scope.center, p,
						mp.s.chain.rotateSteps);

				//calculate new size
				var size = Math.floor(this.scope.center.distanceTo(p) /
						this.data.length);

				if(a !== this.data.a || size !== this.data.size)
				{
					this.data.a = a;
					this.data.size = size;

					//calculate deviation side
					var ds = this.data.a > -Math.PI / 2 && this.data.a < Math.PI / 2 ? 1 : -1;
					var da = this.data.a + ds * mp.s.chain.devAngle;
					if(this.data.ra !== undefined)
					{
						//copmare alternative and replace current angle with alternative angle
						var da_alt = this.data.a - ds * mp.s.chain.devAngle;
						if(smallestAngleBetween(da, this.data.ra) <
								smallestAngleBetween(da_alt, this.data.ra))
						{
							da = da_alt;
						}
					}

					//calculate chain vertices
					var ax = this.data.length * Math.cos(this.data.a);
					var ay = this.data.length * Math.sin(-this.data.a);//flipped y-axis
					var bx = mp.s.bond.length * Math.cos(da);
					var by = mp.s.bond.length * Math.sin(-da);

					this.data.chain = [];
					var c = this.scope.center.clone();
					for(var i = 0; i < this.data.size; i++)
					{
						if(i % 2 === 0)
						{
							this.data.chain.push(MPPFO({
								x: c.x + bx,
								y: c.y + by
							}));
						}
						else
						{
							c.x += 2 * ax;
							c.y += 2 * ay;
							this.data.chain.push(c.clone());
						}
					}

					//calculate begin vertex (for drawing purposes)
					if(this.data.chain.length > 0)
					{
						this.data.chain.unshift(this.scope._calculateBondVertices(this.data.chain[0], [0])[0]);
					}

					mp.requestRedraw();
				}
			},
			onPointerUp: function(e, mp)
			{
				//create chain, skip first vertex
				var catom = this.scope;//connect atom
				var chainIndices = [];//store new atom indices to collapse chain
				for(var i = 1; i < this.data.chain.length; i++)
				{
					var atom = new MPAtom(mp, {
						i: mp.mol.atoms.length,
						x: this.data.chain[i].x,
						y: this.data.chain[i].y,
						element: "C"
					});
					mp.mol.atoms.push(atom);
					chainIndices.push(atom.index);

					var bond = new MPBond(mp, {
						i: mp.mol.bonds.length,
						from: catom.index,
						to: atom.index,
						type: MP_BOND_SINGLE
					});
					mp.mol.bonds.push(bond);

					catom.addBond(bond.index);
					atom.addBond(bond.index);
					catom = atom;
				}

				//collapse chain
				mp.mol.collapseAtoms(chainIndices, true);
			}
		};
	}
	else if(this.mp.tool.type === "erase")
	{
		return {
			scope: this,
			onPointerDown: function(e, mp)
			{
				if(this.scope.isSelected()) mp.sel.remove();
				else mp.mol.removeAtom(this.scope.index, true);

				//dismiss all further calls to this handler
				mp.pointer.handler = undefined;
			}
		};
	}
	else//drag, fallback
	{
		return {
			scope: this,
			data: {},
			onPointerDown: function(e, mp)
			{
				var p = new MPPoint().fromRelativePointer(e, mp);
				if(mp.sel.hasCenter())
				{
					mp.sel.startAngle =
							mp.sel.currentAngle =
							mp.sel.center.angleTo(p);
				}
			},
			onPointerMove: function(e, mp)
			{
				mp.setCursor("move");
				var p = new MPPoint().fromRelativePointer(e, mp);
				var dx = p.x - mp.pointer.old.r.x;
				var dy = p.y - mp.pointer.old.r.y;

				if(Math.sqrt(dx * dx + dy * dy) > mp.s.draggingThreshold || this.data.moved)
				{
					this.data.moved = true;

					if(this.scope.isSelected())
					{
						if(!mp.sel.hasCenter() || mp.sel.centerAtom === this.scope.index)
						{
							mp.sel.translate(dx, dy);
						}
						else
						{
							mp.sel.rotate(p);
						}
					}
					else
					{
						this.scope.translate(p.x - mp.pointer.old.r.x, p.y - mp.pointer.old.r.y);
					}

					mp.pointer.old.r = p;
				}
			},
			onPointerUp: function(e, mp)
			{
				if(!this.data.moved && oneOf(mp.tool.type, ["select", "drag"]))
				{
					this.scope.select(!this.scope.isSelected());
					mp.sel.updateRotationCenter();
				}
				else
				{
					if(this.scope.isSelected()) mp.sel.collapse();
					else mp.mol.collapseAtoms([this.scope.index], true);

					/* process possible changes to
					rotation center caused by collapsing */
					mp.sel.updateRotationCenter();
				}
			}
		};
	}
}

/**
 * Handler for mouse events
 * @param  {MPPoint} point Event origin
 * @param  {String}  type  Event type (hover || active)
 * @return {Boolean}       Indicates if event is handled by this MPAtom
 */
MPAtom.prototype.handle = function(point, type)
{
	if(this.line === undefined) return false;

	var r = this.mp.s.atom.selectionRadiusScaled;

	if(this.line.area.point)
	{
		if(point.inCircleBox(this.center, r))
		{
			if(point.inCircle(this.center, r))
			{
				this.setDisplay(type);
				return true;
			}
		}
	}
	else
	{
		var lp = new MPPoint(this.center.x + this.line.area.left, this.center.y);
		var rp = new MPPoint(this.center.x + this.line.area.right, this.center.y);
		if(point.inLineBox(lp, rp, r))
		{
			if(point.lineDistance(lp, rp) <= r)
			{
				this.setDisplay(type);
				return true;
			}
		}
	}

	this.setDisplay("normal");
	return false;
}

MPAtom.prototype.handleRectSelect = function(rect)
{
	this.select(this.center.inRect(rect));
}

MPAtom.prototype.handlePolygonSelect = function(polygon)
{
	this.select(this.center.inPolygon(polygon));
}
/**
 * This file is part of MolView (http://molview.org)
 * Copyright (c) 2014, 2015 Herman Bergwerf
 *
 * MolView is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MolView is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with MolView.  If not, see <http://www.gnu.org/licenses/>.
 */

var MP_BOND_SINGLE = 1;
var MP_BOND_DOUBLE = 2;
var MP_BOND_TRIPLE = 3;
var MP_BOND_WEDGEHASH = 4;
var MP_BOND_CIS = 5;

var MP_STEREO_NONE = 0;
var MP_STEREO_UP = 1;
var MP_STEREO_DOWN = 6;
var MP_STEREO_CIS_TRANS = 3;
var MP_STEREO_EITHER = 4;

/**
 * Create new MPBond
 * @param {MolPad} mp
 * @param {Object} obj Configuration
 */
function MPBond(mp, obj)
{
	this.mp = mp;
	this.index = obj.i;
	this.type = obj.type || 0;
	this.stereo = obj.stereo || MP_STEREO_NONE;
	this.from = obj.from || 0;
	this.to = obj.to || 0;
	this.selected = obj.selected || false;
	this.display = "normal";
	this.hidden = false;//used internally to hide inverted bonds
	this.valid = false;
	this.mp.requestRedraw();
}

/**
 * Retruns data which can be used as input by the Ketcher fork
 * @param {Object} mp
 * @return {Object}
 */
MPBond.prototype.getKetcherData = function()
{
	return new chem.Struct.Bond({
		type: this.type,
		stereo: this.stereo,
		begin: this.from,
		end: this.to
	});
}

/**
 * Retruns config data which can be used to reconstruct this object
 * @return {Object}
 */
MPBond.prototype.getConfig = function()
{
	return {
		i: this.index,
		type: this.type,
		stereo: this.stereo,
		from: this.from,
		to: this.to
	};
}

/**
 * Retruns MPBond string which can be compared to other MPBond strings
 * @return {String}
 */
MPBond.prototype.toString = function()
{
	return this.type.toString()
		+ this.stereo.toString()
		+ this.to - this.from;//store up/down bond direction
}

MPBond.prototype.getLine = function()
{
	return new MPLine({
		from: this.mp.mol.atoms[this.from].center,
		to: this.mp.mol.atoms[this.to].center
	});
}

/**
 * Returns the from.angleTo(to)
 * @param  {Integer} from From atom
 * @return {Float}
 */
MPBond.prototype.getAngle = function(from)
{
	if(this.mp.mol.atoms[this.from].equals(from))
	{
		return this.mp.mol.atoms[this.from].center.angleTo(
			this.mp.mol.atoms[this.to].center);
	}
	else
	{
		return this.mp.mol.atoms[this.to].center.angleTo(
			this.mp.mol.atoms[this.from].center);
	}
}

MPBond.prototype.setIndex = function(index) { this.index = index; }

MPBond.prototype.setType = function(type)
{
	this.type = type;
	this.changed();
}

MPBond.prototype.setStereo = function(stereo)
{
	this.stereo = stereo;
	this.changed();
}

MPBond.prototype.setFrom = function(from)
{
	this.from = from;
	this.changed();
}

MPBond.prototype.setTo = function(to)
{
	this.to = to;
	this.changed();
}

/**
 * Sets display type
 * @param {String} type
 */
MPBond.prototype.setDisplay = function(type)
{
	if(type !== this.display)
	{
		this.display = type;
		this.mp.requestRedraw();
	}
}

/**
 * Replace a given atom with another atom
 * @param {Integer} i Atom index
 * @param {Integer} n New atom index
 */
MPBond.prototype.replaceAtom = function(i, n)
{
	if(this.from === i && this.to !== n) this.from = n;
	else if(this.to === i && this.from !== n) this.to = n;
	this.changed();
}

/**
 * Compares all properties of this bond with a plain MPBond configuration object
 * @param  {Object} config
 * @return {Boolean}
 */
MPBond.prototype.compare = function(config)
{
	return config.i === this.index
		&& config.type === this.type
		&& config.stereo === this.stereo
		&& config.from === this.from
		&& config.to === this.to;
}

/**
 * Checks if this MPBond is equal to another MPBond
 * @param  {MPBond} bond
 * @return {Booelan}
 */
MPBond.prototype.equals = function(bond)
{
	return bond.from === this.from && bond.to === this.to;
}

/**
 * Wrapper for MPBond.selected (for maintainability)
 */
MPBond.prototype.isSelected = function()
{
	return this.selected;
}

/**
 * Checks is this MPBond is hidden (not the same as invisible)
 */
MPBond.prototype.isHidden = function()
{
	return this.display === "hidden" || this.hidden;
}

/**
 * Checks if this bond is a pair of the given elements
 * @param  {String} a
 * @param  {String} b
 * @return {Booelan}
 */
MPBond.prototype.isPair = function(a, b)
{
	var _a = this.mp.mol.atoms[this.from].element;
	var _b = this.mp.mol.atoms[this.to].element;
	return _a === a && _b === b || _a === b && _b === a;
}

/**
 * Checks if this bond is bonded to the given MPAtom.index
 * @param  {Integer} i
 * @return {Booelan}
 */
MPBond.prototype.hasAtom = function(i)
{
	return this.from === i || this.to === i;
}

/**
 * Get the atom index of the atom on the other side of the given MPAtom.index
 * @param  {Integer} i
 * @return {Integer}
 */
MPBond.prototype.getOppositeAtom = function(i)
{
	return this.from === i ? this.to : this.from;
}

/**
 * Selects or deselects this MPBond
 * @param {Boolean} select
 */
MPBond.prototype.select = function(select)
{
	if(this.isSelected() !== select)
	{
		this.selected = select;
		this.mp.sel.update();
		this.mp.requestRedraw();
	}
}

/**
 * Invalidate this bond
 */
MPBond.prototype.invalidate = function()
{
	this.valid = false;
	this.mp.requestRedraw();
}

/**
 * Invalidation helper called when bond is changed
 */
MPBond.prototype.changed = function()
{
	this.invalidate();
	this.mp.mol.atoms[this.from].bondsChanged();
	this.mp.mol.atoms[this.to].bondsChanged();
}

/**
 * Render methods
 */

MPBond.prototype.drawStateColor = function()
{
	if(this.isHidden() || this.line === undefined) return;

	if(this.display === "hover" || this.display === "active" ||
			(this.display === "normal" && this.isSelected()))
	{
		var d = this.isSelected() ? "selected" : this.display;

		this.mp.ctx.beginPath();

		var f = this.line.from;
		var t = this.line.to;

		//stick to 'from' atom center if 'from' atom is selected (multi-select)
		if(this.mp.mol.atoms[this.from].isSelected())
		{
			f = this.mp.mol.atoms[this.from].center;
		}
		//stick to 'to' atom center if 'to' atom is selected (multi-select)
		if(this.mp.mol.atoms[this.to].isSelected())
		{
			t = this.mp.mol.atoms[this.to].center;
		}

		this.mp.ctx.moveTo(f.x, f.y);
		this.mp.ctx.lineTo(t.x, t.y);

		this.mp.ctx.strokeStyle = this.mp.s.bond[d].color;
		this.mp.ctx.stroke();
	}
}

MPBond.prototype.drawBond = function()
{
	if(this.isHidden() || this.line === undefined) return;

	var scale = this.mp.s.bond.scale;
	var ctx = this.mp.ctx;

	if(this.mp.s.bond.colored && !this.mp.s.atom.miniLabel)
	{
		ctx.strokeStyle = this.cache.bondColor;
		if(this.stereo === MP_STEREO_UP) ctx.fillStyle = this.cache.bondColor;
	}

	if(this.mp.getScale() < this.mp.s.bond.singleOnlyScale)
	{
		ctx.beginPath();
		ctx.moveTo(this.line.from.x, this.line.from.y);
		ctx.lineTo(this.line.to.x, this.line.to.y);
		ctx.stroke();
	}
	else if(this.stereo === MP_STEREO_CIS_TRANS && this.type === MP_BOND_DOUBLE)
	{
		ctx.beginPath();
		ctx.moveTo(this.cache.ctd.from[0].x, this.cache.ctd.from[0].y);
		ctx.lineTo(this.cache.ctd.to[0].x, this.cache.ctd.to[0].y);
		ctx.moveTo(this.cache.ctd.from[1].x, this.cache.ctd.from[1].y);
		ctx.lineTo(this.cache.ctd.to[1].x, this.cache.ctd.to[1].y);
		ctx.stroke();
	}
	else if(this.stereo === MP_STEREO_UP)//wedge bond
	{
		ctx.beginPath();
		ctx.moveTo(this.cache.wedge.far[0].x, this.cache.wedge.far[0].y);
		ctx.lineTo(this.cache.wedge.near[0].x, this.cache.wedge.near[0].y);
		ctx.lineTo(this.line.to.x, this.line.to.y);
		ctx.lineTo(this.cache.wedge.near[1].x, this.cache.wedge.near[1].y);
		ctx.closePath();
		ctx.fill();
		ctx.stroke();
	}
	else if(this.stereo === MP_STEREO_DOWN)//hash bond
	{
		ctx.beginPath();
		for(var i = 0; i < this.cache.hashLines.length; i++)
		{
			ctx.moveTo(this.cache.hashLines[i].from.x, this.cache.hashLines[i].from.y);
			ctx.lineTo(this.cache.hashLines[i].to.x, this.cache.hashLines[i].to.y);
		}
		ctx.stroke();
	}
	else if(this.type === MP_BOND_SINGLE)
	{
		ctx.beginPath();
		ctx.moveTo(this.line.from.x, this.line.from.y);
		ctx.lineTo(this.line.to.x, this.line.to.y);
		ctx.stroke();
	}
	else if(this.type === MP_BOND_DOUBLE || this.type === MP_BOND_TRIPLE)
	{
		ctx.beginPath();
		for(var i = 0; i < this.cache.bond.from.length; i++)
		{
			ctx.moveTo(this.cache.bond.from[i].x, this.cache.bond.from[i].y);
			ctx.lineTo(this.cache.bond.to[i].x, this.cache.bond.to[i].y);
		}
		if(this.type === MP_BOND_TRIPLE)
		{
			ctx.moveTo(this.line.from.x, this.line.from.y);
			ctx.lineTo(this.line.to.x, this.line.to.y);
		}
		ctx.stroke();
	}
}
/**
 * This file is part of MolView (http://molview.org)
 * Copyright (c) 2014, 2015 Herman Bergwerf
 *
 * MolView is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MolView is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with MolView.  If not, see <http://www.gnu.org/licenses/>.
 */

MPBond.prototype.validate = function()
{
	if(this.valid) return;
	this.valid = true;

	if(this.mp.mol.atoms[this.from].center.distanceTo(
			this.mp.mol.atoms[this.to].center) <=
			((this.mp.mol.atoms[this.from].isVisible() ? 1 : 0) +
			(this.mp.mol.atoms[this.to].isVisible() ? 1 : 0)) *
			this.mp.s.atom.radius)
	{
		this.hidden = true;
	}
	else
	{
		this.hidden = false;

		var scale = this.mp.s.bond.scale;

		this.cache = {};
		this.line = {
			from: this.mp.mol.atoms[this.from].calculateBondVertices(this.to, [0])[0],
			to: this.mp.mol.atoms[this.to].calculateBondVertices(this.from, [0])[0]
		};
		this.line.center = new MPPFO({
			x: (this.line.from.x + this.line.to.x) / 2,
			y: (this.line.from.y + this.line.to.y) / 2
		});

		if(this.mp.s.bond.colored)
		{
			var f = this.mp.mol.atoms[this.from];
			var t = this.mp.mol.atoms[this.to];

			if(this.stereo === MP_STEREO_UP)
			{
				this.cache.bondColor = JmolAtomColorsHashHex["C"];
			}
			else if(f.element === t.element)
			{
				this.cache.bondColor = JmolAtomColorsHashHex[f.element] || JmolAtomColorsHashHex["C"];
			}
			else
			{
				this.cache.bondColor = this.mp.ctx.createLinearGradient(f.getX(), f.getY(), t.getX(), t.getY());
				this.cache.bondColor.addColorStop(this.mp.s.bond.gradient.from, JmolAtomColorsHashHex[f.element] || JmolAtomColorsHashHex["C"]);
				this.cache.bondColor.addColorStop(this.mp.s.bond.gradient.to, JmolAtomColorsHashHex[t.element] || JmolAtomColorsHashHex["C"]);
			}
		}
		else//fallback, this color is actually not used
		{
			this.cache.bondColor = this.mp.s.bond.color;
		}

		if(this.mp.getScale() >= this.mp.s.bond.singleOnlyScale)
		{
			if(this.stereo === MP_STEREO_CIS_TRANS && this.type === MP_BOND_DOUBLE)
			{
				var ends = transformArrayMult(this.mp.s.bond.delta[MP_BOND_CIS],
						-this.mp.s.bond.deltaScale);//flip ends because of flipped y-axis
				this.cache.ctd = {
					from: this.mp.mol.atoms[this.from].calculateBondVertices(this.to, ends),
					to: this.mp.mol.atoms[this.to].calculateBondVertices(this.from, ends)
				};
			}
			else if(this.stereo === MP_STEREO_UP)//wedge bond
			{
				this.cache.wedge = {
					far: this.mp.mol.atoms[this.from].calculateBondVertices(this.to, [0]),
					near: this.mp.mol.atoms[this.to].calculateBondVertices(this.from,
							transformArrayMult(this.mp.s.bond.delta[MP_BOND_WEDGEHASH],
								-this.mp.s.bond.deltaScale))//flip ends because of flipped y-axis
				};

				if(!this.mp.mol.atoms[this.to].isVisible())
				{
					var bonds = this.mp.mol.atoms[this.to].calculateClosestBonds(this.index);

					if(!bonds.none)
					{
						if(this.mp.mol.bonds[bonds.lower].type == MP_BOND_SINGLE)
						{
							var i1 = this.mp.mol.bonds[bonds.lower].getLine().intersection(
								new MPLine({
									from: this.cache.wedge.far[0],
									to: this.cache.wedge.near[0]
							}));
							if(i1.p !== undefined && this.line.to.distanceTo(i1.p) < this.mp.s.bond.wedgeFitMaxD)
							{
								this.cache.wedge.near[0] = i1.p || this.cache.wedge.near[0];
							}
						}
						if(this.mp.mol.bonds[bonds.upper].type == MP_BOND_SINGLE)
						{
							var i2 = this.mp.mol.bonds[bonds.upper].getLine().intersection(
								new MPLine({
									from: this.cache.wedge.far[0],
									to: this.cache.wedge.near[1]
							}));
							if(i2.p !== undefined && this.line.to.distanceTo(i2.p) < this.mp.s.bond.wedgeFitMaxD)
							{
								this.cache.wedge.near[1] = i2.p || this.cache.wedge.near[1];
							}
						}
					}
				}
			}
			else if(this.stereo === MP_STEREO_DOWN)//hash bond
			{
				var far = this.mp.mol.atoms[this.from].calculateBondVertices(this.to, [0]);
				var near = this.mp.mol.atoms[this.to].calculateBondVertices(this.from,
						transformArrayMult(this.mp.s.bond.delta[MP_BOND_WEDGEHASH],
							-this.mp.s.bond.deltaScale));//flip ends because of flipped y-axis

				var dx1 = near[0].x - far[0].x;
				var dy1 = near[0].y - far[0].y;
				var dx2 = near[1].x - far[0].x;
				var dy2 = near[1].y - far[0].y;
				var d1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
				var w = this.mp.s.bond.width * scale;
				var s = this.mp.s.bond.hashLineSpace * scale;

				this.cache.hashLines = [];
				while(d1 - s - w > 0)
				{
					var mult = (d1 - s - w) / d1;
					d1 *= mult;
					dx1 *= mult; dy1 *= mult;
					dx2 *= mult; dy2 *= mult;

					this.cache.hashLines.push({
						from: { x: far[0].x + dx1, y: far[0].y + dy1 },
						to: { x: far[0].x + dx2, y: far[0].y + dy2 }
					});
				}
			}
			else if(this.type === MP_BOND_DOUBLE || this.type === MP_BOND_TRIPLE)
			{
				var ends = [];
				var doubleSide = 1;
				var fromBonds = this.mp.mol.atoms[this.from].calculateClosestBonds(this.index);
				var toBonds = this.mp.mol.atoms[this.to].calculateClosestBonds(this.index);
				var refineUpperSkeletal = false, refineLowerSkeletal = false;


				//check if this bond will be displayed using all skeletal display rules
				var skeletal = (this.mp.s.skeletalDisplay &&//skeleton display is enabled
						(!this.mp.mol.atoms[this.from].isVisible() || !this.mp.mol.atoms[this.to].isVisible()) &&//and at least one atom is visible
						//and the bond is not a bond which connects:
						!(this.mp.mol.atoms[this.from].bonds.length === 1 &&//an atom with no other bonds
							((this.mp.mol.atoms[this.from].isVisible() &&//which is visible
							this.mp.mol.atoms[this.to].bonds.length > 2) ||//to any atom that is connected to 2+ other atoms
							this.mp.mol.atoms[this.to].bonds.length === 1)) &&//or to another atom with no other bonds
						!(this.mp.mol.atoms[this.to].bonds.length === 1 &&
							((this.mp.mol.atoms[this.to].isVisible() &&
							this.mp.mol.atoms[this.from].bonds.length > 2) ||//to any atom that is connected to 2+ other atoms
							this.mp.mol.atoms[this.from].bonds.length === 1)));

				if(skeletal)
				{
					/*
					Calculate best doubleSide
					=========================
					1. The sum of the deviation of the bisect angle relative to
					the bestBisect angle of the upper and the lower side are
					calculated. The side with the least bestBisect deviation
					is used for the double bond
					2. The approximated double bond length is calcualted
					using a horizontal bond with length this.line distance
					and bond delta = 8. Using this length, the bond refinement
					is skipped or the bond is force flipped to a different side
					*/
					var length = this.line.from.distanceTo(this.line.to);
					var upperLength = length, upperBisectD = 0;

					if(fromBonds.upperSectionAngle < Math.PI)
					{
						if(!this.mp.mol.atoms[this.from].isVisible())
							upperLength -= 8 / Math.tan(fromBonds.upperSectionAngle / 2);
						upperBisectD += Math.abs(this.mp.s.bond.bestBisect - fromBonds.upperSectionAngle / 2);
					}
					else upperBisectD += Math.abs(this.mp.s.bond.bestBisect - Math.PI / 2);

					if(toBonds.lowerSectionAngle < Math.PI)
					{
						if(!this.mp.mol.atoms[this.to].isVisible())
							upperLength -= 8 / Math.tan(toBonds.lowerSectionAngle / 2);
						upperBisectD += Math.abs(this.mp.s.bond.bestBisect - toBonds.lowerSectionAngle / 2);
					}
					else upperBisectD += Math.abs(this.mp.s.bond.bestBisect - Math.PI / 2);

					var lowerLength = length, lowerBisectD = 0;
					if(fromBonds.lowerSectionAngle < Math.PI)
					{
						if(!this.mp.mol.atoms[this.from].isVisible())
							lowerLength -= 8 / Math.tan(fromBonds.lowerSectionAngle / 2);
						lowerBisectD += Math.abs(this.mp.s.bond.bestBisect - fromBonds.lowerSectionAngle / 2);
					}
					else lowerBisectD += Math.abs(this.mp.s.bond.bestBisect - Math.PI / 2);

					if(toBonds.upperSectionAngle < Math.PI)
					{
						if(!this.mp.mol.atoms[this.to].isVisible())
							lowerLength -= 8 / Math.tan(toBonds.upperSectionAngle / 2);
						lowerBisectD += Math.abs(this.mp.s.bond.bestBisect - toBonds.upperSectionAngle / 2);
					}
					else lowerBisectD += Math.abs(this.mp.s.bond.bestBisect - Math.PI / 2);

					//check if the opposite sections are almost the same (like in a chain)
					//if so, a fallback rule is applied (in order to prevent from
					//inconsistent double bond sides in carbon chains)
					if(Math.abs(fromBonds.upperSectionAngle - toBonds.upperSectionAngle) +
					   Math.abs(fromBonds.lowerSectionAngle - toBonds.lowerSectionAngle) < this.mp.s.bond.angleDev)
					{
						//fallback rule: double bond to the visual upper side
						var a = this.mp.mol.atoms[this.from].center.angleTo(this.mp.mol.atoms[this.to].center);
						doubleSide = a > -Math.PI / 2 + this.mp.s.bond.angleDev
								&& a <= Math.PI / 2 + this.mp.s.bond.angleDev ? 1 : -1;
					}
					else if(lowerBisectD < upperBisectD ||//the lower side has a smaller bestBisect deviation
						//or the lower side can apply bond refinement while the upper side cannot
						(upperLength < this.mp.s.atom.radius && lowerLength > this.mp.s.atom.radius))
					{
						doubleSide = -1;
					}

					refineUpperSkeletal = (this.type === MP_BOND_TRIPLE || doubleSide === 1)
							&& upperLength > this.mp.s.atom.radius;
					refineLowerSkeletal = (this.type === MP_BOND_TRIPLE || doubleSide === -1)
							&& lowerLength > this.mp.s.atom.radius;
				}

				if(this.type === MP_BOND_DOUBLE)
				{
					ends = this.mp.s.bond.delta[MP_BOND_DOUBLE];
					if(skeletal) ends = transformArrayAdd(ends, -doubleSide * ends[0]);
				}
				else if(this.type === MP_BOND_TRIPLE)
				{
					ends = this.mp.s.bond.delta[MP_BOND_TRIPLE];
				}

				ends = transformArrayMult(ends, -this.mp.s.bond.deltaScale);//flip ends because of flipped y-axis
				var toEnds = transformArrayMult(ends, -1);//reversed upper/lower side relate to from
				this.cache.bond = {
					from: this.mp.mol.atoms[this.from].calculateBondVertices(this.to, ends),
					to: this.mp.mol.atoms[this.to].calculateBondVertices(this.from, toEnds)
				};

				if(!this.mp.mol.atoms[this.from].isVisible())
				{
					if(!fromBonds.none)
					{
						if((!skeletal || refineLowerSkeletal)
						&& fromBonds.lowerSectionAngle < Math.PI)
						{
							this.cache.bond.from[0] = this.refineBondVetex(
									skeletal, fromBonds.lowerBisectAngle,
									this.line.from, this.cache.bond.from[0], this.cache.bond.to[0],
									this.mp.mol.bonds[fromBonds.lower].getLine());
						}
						if((!skeletal || refineUpperSkeletal)
						&& fromBonds.upperSectionAngle < Math.PI)
						{
							this.cache.bond.from[1] = this.refineBondVetex(
									skeletal, fromBonds.upperBisectAngle,
									this.line.from, this.cache.bond.from[1], this.cache.bond.to[1],
									this.mp.mol.bonds[fromBonds.upper].getLine());
						}
					}
				}

				if(!this.mp.mol.atoms[this.to].isVisible())
				{
					if(!toBonds.none)
					{
						if((!skeletal || refineLowerSkeletal)
						&& toBonds.upperSectionAngle < Math.PI)
						{
							this.cache.bond.to[0] = this.refineBondVetex(skeletal, toBonds.upperBisectAngle,
									this.line.to, this.cache.bond.to[0], this.cache.bond.from[0],
									this.mp.mol.bonds[toBonds.upper].getLine());
						}
						if((!skeletal || refineUpperSkeletal)
						&& toBonds.lowerSectionAngle < Math.PI)
						{
							this.cache.bond.to[1] = this.refineBondVetex(skeletal, toBonds.lowerBisectAngle,
									this.line.to, this.cache.bond.to[1], this.cache.bond.from[1],
									this.mp.mol.bonds[toBonds.lower].getLine());
						}
					}
				}
			}
		}
	}
}


MPBond.prototype.refineBondVetex = function(skeletal, bisectAngle, lineFrom, bondFrom, bondTo, closestBondLine)
{
	var intersection;
	if(skeletal)
	{
		intersection = new MPLine({
			from: lineFrom,
			to: MPPFO({
				x: lineFrom.x + Math.cos(bisectAngle),
				y: lineFrom.y + Math.sin(-bisectAngle)
			})
		}).intersection(
			new MPLine({
				from: bondFrom,
				to: bondTo
		}));
	}
	else
	{
		intersection = closestBondLine.intersection(
			new MPLine({
				from: bondFrom,
				to: bondTo
		}));
		if(!intersection.onL1 || lineFrom.distanceTo(intersection.p) >
				closestBondLine.length() / 2)
		{
			intersection.p = undefined;
		}
	}

	return intersection.p !== undefined ? intersection.p : bondFrom;
}
/**
 * This file is part of MolView (http://molview.org)
 * Copyright (c) 2014, 2015 Herman Bergwerf
 *
 * MolView is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MolView is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with MolView.  If not, see <http://www.gnu.org/licenses/>.
 */

MPBond.prototype.getHandler = function()
{
	if(this.mp.tool.type === "bond")
	{
		return {
			scope: this,
			onPointerDown: function(e, mp)
			{
				if(mp.tool.data.type)
				{
					this.scope.setType(mp.tool.data.type === MP_BOND_TRIPLE ? MP_BOND_TRIPLE :
						(this.scope.type === MP_BOND_TRIPLE || this.scope.stereo !== MP_STEREO_NONE) ? mp.tool.data.type :
							this.scope.type === MP_BOND_SINGLE ? MP_BOND_DOUBLE : MP_BOND_SINGLE);
					this.scope.setStereo(MP_STEREO_NONE);
				}
				else if(mp.tool.data.stereo)
				{
					this.scope.setType(MP_BOND_SINGLE);

					if(this.scope.stereo === mp.tool.data.stereo)
					{
						var f = this.scope.from;
						this.scope.setFrom(this.scope.to);
						this.scope.setTo(f);
					}
					else
					{
						this.scope.setStereo(mp.tool.data.stereo);
					}
				}
			}
		};
	}
	else if(this.mp.tool.type === "fragment" && this.mp.tool.data.frag.toBond !== undefined)
	{
		return {
			scope: this,
			data: {},
			onPointerDown: function(e, mp)
			{
				var p = new MPPoint().fromRelativePointer(e, mp);
				var f = mp.mol.atoms[this.scope.from].center;
				var t = mp.mol.atoms[this.scope.to].center;
				var a = f.angleTo(t);

				//clone new fragment and transform it
				this.data.frag = MPFragments.rotate(
					MPFragments.translate(
						MPFragments.scale(
							MPFragments.clone(mp.tool.data.frag.toBond),
							mp.s.bond.length),
						f.x, f.y), f, a);

				//create and select the fragment and store the new fragment data
				var frag = mp.mol.createFragment(this.data.frag, true);

				//IMPORTANT: do not merge the other way around or the scope will be lost
				frag.atoms = mapArray(frag.atoms, mp.mol.mergeAtoms(frag.atoms[0], this.scope.from).amap);
				frag.atoms = mapArray(frag.atoms, mp.mol.mergeAtoms(frag.atoms[frag.atoms.length - 1], this.scope.to).amap);

				//resolve selection.mirrorSide
				var s = 0;
				for(var i = 0; i < frag.atoms.length; i++)
				{
					s += mp.mol.atoms[frag.atoms[i]].center.lineSide(this.scope.getLine());
				}
				mp.sel.mirrorSide = s > 0 ? 1 : -1;

				//get number collapsing atoms
				var collA = mp.mol.countCollapses(frag.atoms);

				//mirror fragment
				for(var i = 0; i < frag.atoms.length; i++)
				{
					mp.mol.atoms[frag.atoms[i]].center.mirror(
							this.scope.getLine(), -mp.sel.mirrorSide);
				}

				//get new number collapsing atoms
				var collB = mp.mol.countCollapses(frag.atoms);

				//check if new fragment is already added
				if(collA === frag.atoms.length && collB === frag.atoms.length)
				{
					this.data.lock = true;

					//deselect this
					this.scope.select(false);
					mp.mol.atoms[this.scope.from].select(false);
					mp.mol.atoms[this.scope.to].select(false);

					mp.sel.remove();
					return;
				}

				//mirror back if old number of collapsing atoms is lower
				if(collA < collB)
				{
					for(var i = 0; i < frag.atoms.length; i++)
					{
						mp.mol.atoms[frag.atoms[i]].center.mirror(
								this.scope.getLine(), mp.sel.mirrorSide);
					}

					this.data.lock = collB === frag.atoms.length;
				}
				else
				{
					mp.sel.mirrorSide = -mp.sel.mirrorSide;
					this.data.lock = collA === frag.atoms.length;
				}
			},
			onPointerMove: function(e, mp)
			{
				if(this.data.lock) return;//do not mirror fragment if mirror is useless
				var p = new MPPoint().fromRelativePointer(e, mp);
				mp.sel.mirror(this.scope.getLine(), p);
			},
			onPointerUp: function(e, mp)
			{
				mp.sel.collapse();
				mp.sel.clear();
			}
		};
	}
	else if(this.mp.tool.type === "erase")
	{
		return {
			scope: this,
			onPointerDown: function(e, mp)
			{
				if(this.scope.isSelected()) mp.sel.remove();
				else mp.mol.removeBond(this.scope.index);

				//dismiss all further calls to this handler
				mp.pointer.handler = undefined;
			}
		};
	}
	else//drag, fallback
	{
		return {
			scope: this,
			data: {},
			onPointerMove: function(e, mp)
			{
				mp.setCursor("move");
				var p = new MPPoint().fromRelativePointer(e, mp);
				var dx = p.x - mp.pointer.old.r.x;
				var dy = p.y - mp.pointer.old.r.y;

				if(Math.sqrt(dx * dx + dy * dy) > mp.s.draggingThreshold || this.data.moved)
				{
					this.data.moved = true;

					if(this.scope.isSelected() && mp.sel.cache.atoms.length > 0)
					{
						mp.sel.translate(dx, dy);
					}
					else
					{
						mp.mol.atoms[this.scope.from].translate(dx, dy);
						mp.mol.atoms[this.scope.to].translate(dx, dy);
					}

					mp.pointer.old.r = p;
				}
			},
			onPointerUp: function(e, mp)
			{
				if(!this.data.moved && oneOf(mp.tool.type, ["select", "drag"]))
				{
					var s = !this.scope.isSelected();
					this.scope.select(s);

					if(mp.sel.cache.atoms.length === 0)
					{
						mp.mol.atoms[this.scope.from].select(s);
						mp.mol.atoms[this.scope.to].select(s);
					}

					mp.sel.updateRotationCenter();
				}
				else
				{
					if(this.scope.isSelected()) mp.sel.collapse();
					else mp.mol.collapseAtoms([this.scope.from, this.scope.to], true);

					/* process possible changes to
					rotation center caused by collapsing */
					mp.sel.updateRotationCenter();
				}
			}
		};
	}
}

/**
 * Handler for mouse events
 * @param  {MPPoint} point Event origin
 * @param  {String}  type  Event type (hover || active)
 * @return {Boolean}       Indicates if event is handled by this MPBond
 */
MPBond.prototype.handle = function(point, type)
{
	if(this.line === undefined) return false;

	var r = this.mp.s.bond.radiusScaled;

	if(point.inLineBox(this.line.from, this.line.to, r))
	{
		if(point.lineDistance(this.line.from, this.line.to) <= r)
		{
			this.setDisplay(type);
			return true;
		}
	}

	this.setDisplay("normal");
	return false;
}

MPBond.prototype.handleRectSelect = function(rect)
{
	if(this.line === undefined) return;
	this.select(this.line.center.inRect(rect));
}

MPBond.prototype.handlePolygonSelect = function(polygon)
{
	if(this.line === undefined) return;
	this.select(this.line.center.inPolygon(polygon));
}
/**
 * This file is part of MolView (http://molview.org)
 * Copyright (c) 2014, 2015 Herman Bergwerf
 *
 * MolView is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MolView is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with MolView.  If not, see <http://www.gnu.org/licenses/>.
 */

var MP_ZOOM_TO_COG = 0;
var MP_ZOOM_TO_POINTER = 1;

/**
 * Initialize MolPad in the given container
 * TODO: larger touch targets on high DPI screens
 * TODO: add implicit hydrogen as subset of MPAtom
 * TODO: collapse newly added implicit H atoms if !skeletal
 * TODO: always on feature for select tool
 *
 * @param {DOMElement} container
 * @param {Float}      devicePixelRatio
 * @param {Object}     buttons
 */
function MolPad(container, devicePixelRatio, buttons)
{
	this.loadSettings();

	//active tool data
	this.tool = {
		type: "bond",//bond || fragment || chain || charge || erase || drag || select || atom
		data: { type: MP_BOND_SINGLE },
		selection: []//TMP
	};

	this.mol = new MPMolecule(this);
	this.sel = new MPSelection(this);

	this.buttons = buttons;
	this.container = jQuery(container);
	this.devicePixelRatio = devicePixelRatio || 1;

	this.setupEventHandling();
	this.setupGraphics();
}

/**
 * MolPad API
 */

MolPad.prototype.setTool = function(type, data)
{
	this.tool.type = type;
	this.tool.data = data;
}

MolPad.prototype.onChange = function(cb)
{
	this.changeCallback = cb;
}

MolPad.prototype.clear = function(cb)
{
	this.mol.clear();
	this.sel.update();

	//retain old molecule translation in case of an undo
	this.scaleAbsolute(1 / this.matrix[0], this.width() / 2, this.height() / 2);

	this.redraw(true);
	this.mol.updateCopy();
}

MolPad.prototype.changed = function()
{
	jQuery(this.buttons.undo).toggleClass("tool-button-disabled", this.mol.stack.length === 0);
	jQuery(this.buttons.redo).toggleClass("tool-button-disabled", this.mol.reverseStack.length === 0);
	if(this.changeCallback !== undefined) this.changeCallback();
}

MolPad.prototype.undo = function(noRedoPush)
{
	this.dismissHandler();
	if(this.mol.undo(noRedoPush)) this.changed();
}

MolPad.prototype.redo = function()
{
	this.dismissHandler();
	if(this.mol.redo()) this.changed();
}

MolPad.prototype.setSkeletalDisplay = function(on)
{
	if(on === this.s.skeletalDisplay) return;

	this.dismissHandler();
	this.s.skeletalDisplay = on;

	if(on) this.mol.removeImplicitHydrogen();
	else this.mol.addImplicitHydrogen();

	this.mol.invalidateAll();

	this.clearRedrawRequest();
	this.mol.updateCopy();
}

MolPad.prototype.setColored = function(on)
{
	this.s.atom.colored = this.s.bond.colored = on;
	this.s.fonts.isotope.fontStyle = this.s.fonts.element.fontStyle =
			this.s.fonts.charge.fontStyle = on ? "bold" : "normal";
	this.redraw(true);
}

MolPad.prototype.toDataURL = function()
{
	return this.canvas.toDataURL("image/png");
}

/**
 * Load molfile
 * @param {String}  mol
 * @param {Boolean} forceRemoveHydrogen
 */
MolPad.prototype.loadMOL = function(mol, forceRemoveHydrogen)
{
	this.mol.loadMOL(mol);

	if(this.s.skeletalDisplay || forceRemoveHydrogen)
	{
		this.mol.removeImplicitHydrogen();
	}

	this.center();
	this.mol.updateCopy();
}

MolPad.prototype.getMOL = function()
{
	return this.mol.getMOL();
}

MolPad.prototype.getSMILES = function()
{
	return this.mol.getSMILES();
}
/**
 * This file is part of MolView (http://molview.org)
 * Copyright (c) 2014, 2015 Herman Bergwerf
 *
 * MolView is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MolView is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with MolView.  If not, see <http://www.gnu.org/licenses/>.
 */

MolPad.prototype.loadSettings = function()
{
    /**
	 * Settings
	 * @type {Object}
	 */
	this.s = {
		/**
		 * Maximum undo stack size
		 * @type {Integer}
		 */
		maxStackSize: 100,

		/**
		 * Mousewheel zoom type:
		 * - MP_ZOOM_TO_COG: center of gravity
		 * - MP_ZOOM_TO_POINTER: mousepointer
		 * @type {Integer}
		 */
		zoomType: MP_ZOOM_TO_POINTER,

		/**
		 * Mousewheel zoom speed (multiplier)
		 * @type {Float}
		 */
		zoomSpeed: 0.2,

		/**
		 * You cannot zoom below this level
		 * using the mousewheel
		 * @type {Float}
		 */
		minZoom: 0.01,

		/**
		 * Indicates if skeletal display is enabled
		 * @type {Boolean}
		 */
		skeletalDisplay: true,

		/**
		 * This fraction is used to calculate
		 * the padding around a centered molecule
		 * relative to the canas size
		 * @type {Float}
		 */
		relativePadding: 0.15,

		/**
		 * Pointer events are considered as
		 * dragging after moving this number of pixels
		 * (devicePixelRatio does not apply here)
		 * @type {Float}
		 */
		draggingThreshold: 2,

        /**
         * Number of rotation steps for rotating atoms
         * steps of 30deg: 360 / 30 = 12
         * @type {Float}
         */
        rotateSteps: 360 / 30,

		/**
		 * This object contains the configuration
		 * for various fonts used in MolPad
		 * They can be applied using MolPad.setFont()
		 * The fontSize is defined as pt
		 * @type {Object}
		 */
		fonts: {
			element: {
				fontStyle: "bold",
				fontFamily: 'sans-serif',
				fontSize: 12
			},
			charge: {
				fontStyle: "bold",
				fontFamily: 'sans-serif',
				fontSize: 8
			},
			isotope: {
				fontStyle: "bold",
				fontFamily: 'sans-serif',
				fontSize: 8
			},
			chainSize: {
				fontStyle: "normal",
				fontFamily: 'sans-serif',
				fontSize: 12
			},
		},

        /**
         * All settings related to MPAtom
         * @type {Object}
         */
		atom: {

            /**
             * Styles related to different MPAtom states
             */

			hover: {
				color: "#bfb"
			},
			active: {
				color: "#8f8"
			},
			incorrect: {
				color: "#f66"
			},
			selected: {
				color: "#8f8"
			},

            /**
             * Metrics related to different label sections
             * the padding is only applied between the sections (vertically)
             */

			charge: {
				padding: 1
			},
			isotope: {
				padding: 1
			},

            /**
             * MPAtom scale, this scale is recalculated if
             * the molecule is scaled in order to magnify
             * atom labels on very small global scales
             * @type {Float}
             */
			scale: 1,

            /**
             * Minimum atom scale, the s.atom.scale is scaled up
             * using a linear correlation to the global scale if
             * the global scale is below this value.
             * 12 * 1 / 1.5 = 8: 8pt is the smallest element label fontSize
             * @type {RegExp}
             */
			minScale: 1 / 1.5,

			/**
			 * Radius around atom center (line) for bond vertices
			 * @type {Float}
			 */
            radius: 12,

            /**
             * Radius around atom center (line) for selection area
             * (calculate using point-line distance)
             * @type {Float}
             */
			selectionRadius: 15,

            /**
             * Atom default color
             * @type {String}
             */
			color: "#111",

            /**
             * Atom element coloring
             * @type {Boolean}
             */
			colored: true,

            /**
             * Line-cap used to draw the center (line)
             * @type {String}
             */
			lineCap: "round",

            /**
             * The atom label will be surrounded with a (selection) circle
             * instead of a line if the label with <= circleClamp
             * @type {Number}
             */
			circleClamp: 15,

            /**
             * If you change the element of an atom and drag this far, a new
             * bond will be created wich connects to a new atom with the
             * specified element while the atom itself will be restored
             * @type {Number}
             */
			minAddRotateLength: 15,

            /**
             * Below this global scale, a mini-label will be drawn
             * (small square)
             * @type {Float}
             */
			maxMiniLabelScale: 1 / 5.0,

            /**
             * Mini-label square size in relative units
             * @type {Float}
             */
			miniLabelSize: 25,

            /**
             * This switch is updated automatically in MolPad.update()
             * and used in MPAtom.drawLabel()
             * @type {Boolean}
             */
			miniLabel: false
		},

        /**
         * All settings related to MPBond
         * @type {Object}
         */
		bond: {
            /**
             * If element coloring is enabled, a color gradient will
             * be drawed on this part of the bond
             * @type {Object}
             */
			gradient: {
				from: 0.4,
				to: 0.6
			},

            /**
             * Default MPBond color
             * @type {String}
             */
			color: "#111",

            /**
             * Bond gradient coloring switch
             * @type {Boolean}
             */
			colored: true,

            /**
             * MPBond state styles
             * @type {Object}
             */
			hover: {
				color: "#bfb"
			},
			active: {
				color: "#8f8"
			},
			selected: {
				color: "#8f8"
			},

            /**
             * MPBond metrics
             * @type {Array}
             */
			delta: [
				[],//no bond
				[0],//single bond
				[-4,4],//double bond
				[-8,8],//triple bond
				[-6,6],//wedge/hash bond
				[0,8]//cis bond
			],

            /**
             * Default MPBond length. Molfiles from PubChem etc. will be
             * magnfied using this value in order to scale to this bond length.
             * @type {Float}
             */
			length: 55,

            /**
             * Default MPBond length for hydrogen atoms
             * @type {Float}
             */
			lengthHydrogen: 34,

            /**
             * Radius around MPBond center line (selection area)
             * @type {Float}
             */
			radius: 8,

            /**
             * Line-cap used for MPBond selection area
             * @type {String}
             */
			lineCap: "round",

            /**
             * Line-join used for wedge bonds
             * @type {String}
             */
			lineJoin: "round",

			/**
			 * MPBond line-width
			 * @type {Float}
			 */
            width: 1.5,//in relative px

            /**
             * MPBond scale, this scale is recalculated if
             * the molecule is scaled in order to magnify
             * bond lines on very small global scales
             * @type {Float}
             */
			scale: 1,

            /**
             * Smallest bond scale.
             * 1.5 * 1 / 1.5 = 1: 1px is min bond width in px
             * @type {Float}
             */
			minScale: 1 / 1.5,

            /**
             * Smallest scale for magnifying the bond.delta
             * This will make sure the distance does not get smaller as 1px
             * @type {Float}
             */
			minDeltaScale: 1 / 4.0,

            /**
             * Below this scale, only one bond line is drawn
             * (also for wedge bonds etc.)
             * @type {Float}
             */
			singleOnlyScale: 1 / 5.0,

            /**
             * Space between lines in hash bonds in relative units
             * bondWidth = bond.width for hash bond lines too
             * @type {Float}
             */
			hashLineSpace: 2,

			/**
			 * Maximal bond.line.to.distanceTo(wedgeFitPoint)
			 * @type {Float}
			 */
            wedgeFitMaxD: 20,

            /**
             * Most ideal bisect angle for double/triple bonds
             * @type {Float}
             */
			bestBisect: Math.PI / 4,

            /**
             * Angle deviation to determine if different bond angles are
             * visually equal
             * @type {RegExp}
             */
			angleDev: Math.PI / 30
		},
		chain: {
            /**
             * Chain rotation steps
             * steps of 30deg: 360 / 30 = 12
             * @type {RegExp}
             */
			rotateSteps: 360 / 30,

            /**
             * Deviation angle to create a zig-zag carbon chain
             * @type {Float}
             */
			devAngle: Math.PI / 6,

            /**
             * Chain label padding in relative units
             * @type {Float}
             */
			padding: 2,

            /**
             * Chain label color
             * @type {String}
             */
			color: "#f50",

            /**
             * Chain line color
             * @type {String}
             */
			strokeStyle: "#f50",

            /**
             * Chain line-cap
             * @type {String}
             */
			lineCap: "round",

            /**
             * Chain line-join
             * @type {String}
             */
			lineJoin: "round"
		},
		select: {
            /**
             * Selection area fill style
             * @type {String}
             */
			fillStyle: "rgba(255, 85, 0, 0.3)",

            /**
             * Selection area stroke color
             * @type {String}
             */
			strokeStyle: "#f50",

            /**
             * Selection area stroke lineWidth
             * @type {Number}
             */
			lineWidth: 2,

            /**
             * Seletion area stroke lineCap
             * @type {String}
             */
			lineCap: "round",

            /**
             * Seletion area stroke lineJoin
             * @type {String}
             */
			lineJoin: "round"
		}
	};
}
/**
 * This file is part of MolView (http://molview.org)
 * Copyright (c) 2014, 2015 Herman Bergwerf
 *
 * MolView is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MolView is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with MolView.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * MPMolecule validation system
 * ============================
 * The molecule graphics are kept up to date by a validation system
 * MPAtoms and MPBonds both have some cached calculations
 * These calculations can be marked as invalid. If this is the case, they are
 * recalculated the next time they are validated. Validation is done prior to
 * the drawing of the MPAtom or MPBond and in calculations which depend on the
 * cached calculations of is own object.
 *
 * There are some invalidation rules:
 * - MPAtom:
 *   - When the setup scaling has changed
 *   - When the atom center has changed
 *   - When the atom information has changed
 *   - When a neighbor atom has moved and this atom is not visible
 *     or the visibility is toggled
 * - MPBond:
 *   - When the setup scaling has changed
 *   - When the bond information has changed
 *   - when the center of the from/to MPAtom has changed
 *   - When an MPBond which is connected to a from/to MPAtom is invalidated
 *     and the connecting atom is invisible (due to skeletal display) or was
 *     invisible before the MPBond was invalidated
 */

/**
 * Create new molecule data object
 * @param {MolPad} mp
 */
function MPMolecule(mp)
{
	this.atoms = [];
	this.bonds = [];

	this.stack = [];
	this.reverseStack = [];
	this.copy = { atoms: [], bonds: [], fingerprint: "" };

    this.mp = mp;
}

/**
 * Clear all bonds and atoms
 */
MPMolecule.prototype.clear = function()
{
    this.atoms = [];
    this.bonds = [];
}

/**
 * Invalidate all atoms and bonds
 */
MPMolecule.prototype.invalidateAll = function()
{
	for(var i = 0; i < this.atoms.length; i++)
	{
		this.atoms[i].invalidate();
	}
	for(var i = 0; i < this.bonds.length; i++)
	{
		this.bonds[i].invalidate();
	}
}

/**
 * Validate all atoms and bonds
 */
MPMolecule.prototype.validateAll = function()
{
	for(var i = 0; i < this.atoms.length; i++)
	{
		this.atoms[i].validate();
	}
	for(var i = 0; i < this.bonds.length; i++)
	{
		this.bonds[i].validate();
	}
}

/**
 * Execute callback for all bonds and or atoms
 * @param {Function} callback
 * @param {Boolean}  atoms
 * @param {Boolean}  bonds
 */
MPMolecule.prototype.exec = function(callback, atoms, bonds)
{
    if(atoms)
    {
        for(var i = 0; i < this.atoms.length; i++)
        {
            if(callback.call(this.mp, this.atoms[i])) return;
        }
    }
    if(bonds)
    {
        for(var i = 0; i < this.bonds.length; i++)
        {
            if(callback.call(this.mp, this.bonds[i])) return;
        }
    }
}

/**
 * Load molfile into MPMolecule
 * Uses Ketcher chem utils
 * @param {String}  mol
 */
MPMolecule.prototype.loadMOL = function(mol)
{
	this.clear();

	var molecule = chem.Molfile.parseCTFile(mol.split("\n"));

	//convert Ketcher data format into MolPad molecule
	var scope = this;
	molecule.atoms.each(function(i, atomData)
	{
		var atom = new MPAtom(scope.mp, {
			i: i,
			x: atomData.pp.x * scope.mp.s.bond.length,
			y: atomData.pp.y * scope.mp.s.bond.length,
			element: atomData.label,
			charge: atomData.charge,
			isotope: atomData.isotope
		});

		scope.atoms.push(atom);
	});

	molecule.bonds.each(function(i, bondData)
	{
		var bond = new MPBond(scope.mp, {
			i: i,
			type: bondData.type,
			stereo: bondData.stereo,
			from: bondData.begin,
			to: bondData.end
		});

		scope.bonds.push(bond);
		scope.atoms[bondData.begin].bonds.push(bond.index);
		scope.atoms[bondData.end].bonds.push(bond.index);
	});
}

/**
 * @return {String} Molfile string
 */
MPMolecule.prototype.getMOL = function()
{
	return new chem.MolfileSaver().saveMolecule(this.getKetcherData());
}

/**
 * @return {String} SMILES string
 */
MPMolecule.prototype.getSMILES = function()
{
	if(this.atoms.length === 0) throw new Error("No atoms found");
	return new chem.SmilesSaver().saveMolecule(this.getKetcherData());
}

/**
 * Convert molecule into chem.Struct object
 * @return {chem.Struct}
 */
MPMolecule.prototype.getKetcherData = function()
{
	var molecule = new chem.Struct();

	for(var i = 0; i < this.atoms.length; i++)
	{
		molecule.atoms.add(this.atoms[i].getKetcherData());
	}
	for(var i = 0; i < this.bonds.length; i++)
	{
		molecule.bonds.add(this.bonds[i].getKetcherData());
	}

	molecule.initHalfBonds();
	molecule.initNeighbors();
	molecule.markFragments();

	return molecule;
}

/**
 * Convert molecule into plain JSON object
 * @return {Object}
 */
MPMolecule.prototype.getPlainData = function()
{
	var molecule = { atoms: [], bonds: [] };

	for(var i = 0; i < this.atoms.length; i++)
	{
		molecule.atoms.push(this.atoms[i].getConfig());
	}
	for(var i = 0; i < this.bonds.length; i++)
	{
		molecule.bonds.push(this.bonds[i].getConfig());
	}

	return molecule;
}

/**
 * Load plain JSON object
 * @param {Object} data
 */
MPMolecule.prototype.loadPlainData = function(data)
{
	this.clear();

	for(var i = 0; i < data.atoms.length; i++)
	{
		this.atoms.push(new MPAtom(this.mp, data.atoms[i]));
	}
	for(var i = 0; i < data.bonds.length; i++)
	{
		this.bonds.push(new MPBond(this.mp, data.bonds[i]));
	}

	this.mp.redraw(true);
}

/**
 * Generate unique fingerprint for the current molecule
 * @return {String}
 */
MPMolecule.prototype.getFingerprint = function()
{
	var array = [];
	for(var i = 0; i < this.atoms.length; i++)
	{
		array.push(this.atoms[i].toString())
	}

	array.sort();
	return array.join("");
}

/**
 * Check if the current molecule has changed based on its fingerprint
 */
MPMolecule.prototype.isChanged = function()
{
	return this.getFingerprint() !== this.copy.fingerprint;
}

/**
 * Create fragment from fragment data which is created using MPFragment
 * @param  {Object}  fragment Fragment data
 * @param  {Boolean} select   Select all new bonds and atoms [optional]
 * @return {Object}           New fragment data
 */
MPMolecule.prototype.createFragment = function(fragment, select)
{
	var ret = { atoms: [], bonds: [] };

	for(var i = 0; i < fragment.atoms.length; i++)
	{
		var atom = new MPAtom(this.mp, {
			i: this.atoms.length,
			x: fragment.atoms[i].center.x,
			y: fragment.atoms[i].center.y,
			element: fragment.atoms[i].element,
			selected: select
		});

		this.atoms.push(atom);
		ret.atoms.push(atom.index);
	}

	for(var i = 0; i < fragment.bonds.length; i++)
	{
		var bond = new MPBond(this.mp, {
			i: this.bonds.length,
			type: fragment.bonds[i].type,
			stereo: MP_STEREO_NONE,
			from: ret.atoms[fragment.bonds[i].from],
			to: ret.atoms[fragment.bonds[i].to],
			selected: select
		});

		this.bonds.push(bond);
		ret.bonds.push(bond.index);

		this.atoms[bond.from].addBond(bond.index);
		this.atoms[bond.to].addBond(bond.index);
	}

	if(select)
	{
		this.mp.sel.update();
	}

	return ret;
}

/**
 * Rotate array of atoms around a center using the angle between the center
 * and a given point and an optional number of clampSteps
 *
 * @param  {MPPoint} center
 * @param  {MPPoint} point
 * @param  {Array}   atoms        Array of atom indices
 * @param  {Float}   currentAngle Current rotation angle of the selction
 * @param  {Float}   startAngle   Start rotation angle used for angle clamping
 * @param  {Integer} clampSteps   Number of steps the angle should be clamped to
 * @param  {Boolean} forced       Forced update
 * @return {Float}                New currentAngle
 */
MPMolecule.prototype.rotateAtoms = function(center, point, atoms, currentAngle, startAngle, clampSteps, forced)
{
	var a = currentAngle;
	if(clampSteps !== undefined) a = clampedAngle(startAngle, center, point, clampSteps);
	else a = center.angleTo(point);

	if(a !== currentAngle || forced)
	{
		for(var i = 0; i < atoms.length; i++)
		{
			this.atoms[atoms[i]].rotateAroundCenter(center, a - currentAngle);
		}
		return a;
	}
	else return currentAngle;
}

/**
 * Merge atom src into atom dest
 * @param   {Integer} src     Index of srd atom
 * @param   {Integer} dest    Index of dest atom
 * @param   {Boolean} reverse Reverse src and dest but retain old dest atom
 * @return  {Array}           New index mapping
 */
MPMolecule.prototype.mergeAtoms = function(src, dest, reverse)
{
	var _src = this.atoms[src];
	var _dest = this.atoms[dest];

	if(reverse) _dest.center.replace(_src.center);
	_dest.select(_src.isSelected() || _dest.isSelected());

	for(var j = 0; j < _src.bonds.length; j++)//transfer bonds
	{
		/* only transfer bond if bond destination is not
		already included in the current set of bonds */
		var n = _dest.getNeighborBond(this.bonds[_src.bonds[j]]
				.getOppositeAtom(src));
		if(n === -1)
		{
			this.bonds[_src.bonds[j]].replaceAtom(src, dest);
			_dest.addBond(_src.bonds[j]);
		}
		else
		{
			//transfer selected state to replacement bond
			this.bonds[n].select(this.bonds[_src.bonds[j]].isSelected()
					|| this.bonds[n].isSelected())

			//always force single bond over any other bond types
			if(this.bonds[_src.bonds[j]].type === MP_BOND_SINGLE)
			{
				this.bonds[n].setType(MP_BOND_SINGLE);
			}
		}
	}

	//carbon atoms are less important
	if(_dest.element === "C")
	{
		_dest.setElement(_src.element);
	}

	this.atoms.splice(src, 1);//remove old atom
	return this.updateIndices();
}

/**
 * Collapse set of atom indices into the entire molecule
 * @param {Array}   atoms        Atom indices
 * @param {Boolean} reverse      If set, the $atoms centers will not be used
 */
MPMolecule.prototype.collapseAtoms = function(atoms, reverse)
{
	for(var i = 0; i < atoms.length; i++)
	{
		for(var j = 0; j < this.atoms.length; j++)
		{
			if(atoms.indexOf(j) !== -1) continue;//skip input atoms

			var distance = (!this.atoms[atoms[i]].isVisible()
						 && !this.atoms[j].isVisible() ? 1 : 2)
							* this.mp.s.atom.selectionRadiusScaled;

			if(this.atoms[atoms[i]].center.inCircle(
					this.atoms[j].center, distance))
			{
				var map = this.mergeAtoms(j, atoms[i], reverse);
				atoms = mapArray(atoms, map.amap);
				break;//the old atoms[i] has been handled
			}
		}
	}
}

/**
 * Count how much atoms of the input can be collapsed into the molecules
 * @param  {Array} atoms Atom indices
 * @return {Integer}
 */
MPMolecule.prototype.countCollapses = function(atoms)
{
	var ret = 0;
	for(var i = 0; i < atoms.length; i++)
	{
		for(var j = 0; j < this.atoms.length; j++)
		{
			if(atoms.indexOf(j) !== -1) continue;//skip input atoms

			if(this.atoms[atoms[i]].center.inCircle(
					this.atoms[j].center, this.mp.s.atom.radiusScaled))
			{
				ret++;
			}
		}
	}
	return ret;
}

/**
 * Remove an atom with the given index from the current molecule
 * @param  {Integer} index Atom index
 * @param  {Boolean} rdh   Remove disconnected hydrogens
 * @return {Object}        New indices maps
 */
MPMolecule.prototype.removeAtom = function(index, rdh)
{
	var splice = [];
	if(rdh)
	{
		for(var i = 0; i < this.atoms[index].bonds.length; i++)
		{
			var ai = this.bonds[this.atoms[index].bonds[i]].getOppositeAtom(index);
			if(this.atoms[ai].element == "H" && this.atoms[ai].bonds.length == 1)
				splice.push(ai);
		}
	}
	splice.push(index);
	splice.sort(function(a, b){ return a - b; }).reverse();
	for(var i = 0; i < splice.length; i++)
	{
		this.atoms.splice(splice[i], 1);
	}

	return this.updateIndices();
}

/**
 * Remove a bond with the given index from the current molecule
 * @param {Integer} index Bond index
 */
MPMolecule.prototype.removeBond = function(index)
{
	var f = this.bonds[index].from;
	var t = this.bonds[index].to;

	//remove connected atoms if this is the last bond
	if(this.atoms[f].bonds.length === 1)
	{
		this.atoms.splice(f, 1);
		if(t > f) t--;
	}
	if(this.atoms[t].bonds.length === 1)
	{
		this.atoms.splice(t, 1);
	}

	this.bonds.splice(index, 1);
	return this.updateIndices();
}

/**
 * @return {Array} New index mapping
 */
MPMolecule.prototype.updateIndices = function()
{
	/* CAUTION: nobody is allowed to execute any methods during this process.
	Therefore, only manual data modifications should be used */

	var atomIndexMap = {}, bondIndexMap = {};
	for(var i = 0; i < this.atoms.length; i++)
	{
		atomIndexMap[this.atoms[i].index] = i;
		this.atoms[i].index = i;
		this.atoms[i].valid = false;
	}
	for(var i = 0; i < this.bonds.length; i++)
	{
		var bond = this.bonds[i];
		var from = atomIndexMap[bond.from];
		var to = atomIndexMap[bond.to];

		if(from !== undefined && to !== undefined)
		{
			bondIndexMap[bond.index] = i;
			bond.index = i;
			bond.from = from;
			bond.to = to;
			bond.valid = false;//manual invalidate
		}
		else
		{
			this.bonds.splice(i, 1);
			i--;
		}
	}
	for(var i = 0; i < this.atoms.length; i++)
	{
		this.atoms[i].mapBonds(bondIndexMap);
	}

	this.mp.sel.update();

	return {
		amap: atomIndexMap,
		bmap: bondIndexMap
	};
}

MPMolecule.prototype.getBBox = function()
{
	if(this.atoms.length === 0)
	{
		return {
			x: 0,
			y: 0,
			width: 1,
			height: 1
		}
	}

	var bottomLeft = undefined, topRight = undefined;

	for(var i = 0; i < this.atoms.length; i++)
	{
		//calculate center line since molecule might not be updated yet
		var l = this.atoms[i].calculateCenterLine();
		var px1 = this.atoms[i].center.x + (l.area.point ? 0 : l.area.left);
		var px2 = this.atoms[i].center.x + (l.area.point ? 0 : l.area.right);
		var py = this.atoms[i].center.y;

		if(bottomLeft === undefined)
		{
			bottomLeft = { x: px1, y: py };
		}
		else
		{
			if(bottomLeft.x > px1) bottomLeft.x = px1;
			if(bottomLeft.y > py) bottomLeft.y = py;
		}

		if(topRight === undefined)
		{
			topRight = { x: px2, y: py };
		}
		else
		{
			if(topRight.x < px2) topRight.x = px2;
			if(topRight.y < py) topRight.y = py;
		}
	}

	var r = this.mp.s.atom.radius;
	return {
		x: bottomLeft.x - r,
		y: bottomLeft.y - r,
		width: topRight.x - bottomLeft.x + 2 * r,
		height: topRight.y - bottomLeft.y + 2 * r
	};
}

/**
 * Undo/redo
 */

/**
 * Updates the internal molecule plain copy for the undo stack
 */
MPMolecule.prototype.updateCopy = function()
{
    var fingerprint = this.getFingerprint();

    if(fingerprint !== this.copy.fingerprint)
    {
        this.reverseStack = [];
        this.stack.push(this.copy);
        if(this.stack.length > this.mp.s.maxStackSize)
        {
            this.stack.shift();
        }

        this.copy = this.getPlainData();
        this.copy.fingerprint = fingerprint;
        this.mp.changed();
    }
}

MPMolecule.prototype.undo = function(noRedoPush)
{
	if(this.stack.length > 0)
	{
		if(!noRedoPush)
		{
			this.reverseStack.push(this.copy);
		}

		this.copy = this.stack.pop();
		this.loadPlainData(this.copy);

        return true;
	}
    else return false;
}

MPMolecule.prototype.redo = function()
{
	if(this.reverseStack.length > 0)
	{
		this.stack.push(this.copy);
		this.copy = this.reverseStack.pop();
		this.loadPlainData(this.copy);
        return true;
	}
    else return false;
}

/* DEPRECATED */

MPMolecule.prototype.removeImplicitHydrogen = function()
{
	var implicit = [];

	for(var i = 0; i < this.atoms.length; i++)
	{
		if(this.atoms[i].isImplicit())
		{
			implicit.push(i);
		}
	}

	for(var i = 0; i < implicit.length; i++)
	{
		this.atoms.splice(implicit[i] - i, 1);
	}

	this.updateIndices();
}

MPMolecule.prototype.addImplicitHydrogen = function()
{
	for(var i = 0; i < this.atoms.length; i++)
	{
		this.atoms[i].addImplicitHydrogen();
	}
}
/**
 * This file is part of MolView (http://molview.org)
 * Copyright (c) 2014, 2015 Herman Bergwerf
 *
 * MolView is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MolView is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with MolView.  If not, see <http://www.gnu.org/licenses/>.
 */

function MPSelection(mp)
{
	this.cache = { atoms: [], bonds: [] };
	this.mirrorSide = 1;
	this.startAngle = 0;
	this.currentAngle = 0;
	this.mp = mp;
}

MPSelection.prototype.hasCenter = function()
{
	return typeof this.center === "object";
}

/**
 * Updates the cached selection
 */
MPSelection.prototype.update = function()
{
	this.cache.atoms = [];
	this.cache.bonds = [];

	for(var i = 0; i < this.mp.mol.atoms.length; i++)
	{
		if(this.mp.mol.atoms[i].isSelected())
        {
			this.cache.atoms.push(i);
		}
	}
	for(var i = 0; i < this.mp.mol.bonds.length; i++)
	{
		if(this.mp.mol.bonds[i].isSelected())
        {
			this.cache.bonds.push(i);
		}
	}
}

/**
 * Translate selection
 * Only atoms are translated
 * @param {Float} dx Horizontal translation
 * @param {Float} dy Vertical translation
 */
MPSelection.prototype.translate = function(dx, dy)
{
	for(var i = 0; i < this.cache.atoms.length; i++)
	{
		this.mp.mol.atoms[this.cache.atoms[i]].translate(dx, dy);
	}
}

/**
 * Rotate selection using a mouse pointer
 * @param {MPPoint} pointer
 */
MPSelection.prototype.rotate = function(pointer)
{
	this.currentAngle = this.mp.mol.rotateAtoms(
			this.center, pointer, this.cache.atoms,
			this.currentAngle, this.startAngle,
			this.mp.s.rotateSteps);
}

/**
 * Mirror selection using a pointer and a line
 * @param {Object}  line
 * @param {MPPoint} pointer
 */
MPSelection.prototype.mirror = function(line, pointer)
{
    var s = pointer.lineSide(line);

    if(s !== this.mirrorSide && s !== 0)
    {
        this.mirrorSide = s;

        for(var i = 0; i < this.cache.atoms.length; i++)
        {
            this.mp.mol.atoms[this.cache.atoms[i]].mirror(line, s);
        }
    }
}

/**
 * Clear current selection
 */
MPSelection.prototype.clear = function()
{
	this.mp.mol.exec(function(obj) {
		obj.selected = false;
	}, true, true);
	this.center = undefined;
	this.update();
	this.mp.requestRedraw();
}

/**
 * Collapse current selection
 */
MPSelection.prototype.collapse = function()
{
	this.mp.mol.collapseAtoms(this.cache.atoms.slice());
}


/**
 * Remove current selection
 */
MPSelection.prototype.remove = function()
{
    while(this.cache.atoms.length > 0)
    {
        this.mp.mol.removeAtom(this.cache.atoms[0]);
    }
	while(this.cache.bonds.length > 0)
    {
        this.mp.mol.removeBond(this.cache.bonds[0]);
    }
}

/**
 * Updates selection rotationCenter
 */
MPSelection.prototype.updateRotationCenter = function()
{
	var v = [];
	for(var i = 0; i < this.cache.atoms.length; i++)
	{
		if(this.mp.mol.atoms[this.cache.atoms[i]].hasUnselectedNeighbors())
		{
			v.push(this.cache.atoms[i]);
		}
	}

	if(v.length === 1 && this.cache.atoms.length > 1)
	{
		this.center = this.mp.mol.atoms[v[0]].center;
        this.centerAtom = v[0];
	}
	else
	{
		this.center = undefined;//clear previous rotation center
	}
}
/**
 * This file is part of MolView (http://molview.org)
 * Copyright (c) 2014, 2015 Herman Bergwerf
 *
 * MolView is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MolView is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with MolView.  If not, see <http://www.gnu.org/licenses/>.
 */

MolPad.prototype.setupGraphics = function()
{
	//create and setup canvas
	this.canvas = document.createElement("canvas");
	this.canvas.width = this.container.width() * this.devicePixelRatio;
	this.canvas.height = this.container.height() * this.devicePixelRatio;
	this.canvas.style.width = this.container.width() + "px";
	this.canvas.style.height = this.container.height() + "px";
	this.container.append(this.canvas);

	this.redrawRequest = false;
	this.matrix = [ 1, 0, 0, 1, 0, 0 ];
	this.ctx = this.canvas.getContext("2d");
	this.updated = false;//used to update only before a real redraw
	this.pendingFrame = false;//used to prevent requestAnimationFrame stacking
}

/**
 * Resize the current canvas to fit the container
 */
MolPad.prototype.resize = function()
{
	this.canvas.width = this.container.width() * this.devicePixelRatio;
	this.canvas.height = this.container.height() * this.devicePixelRatio;
	this.canvas.style.width = this.container.width() + "px";
	this.canvas.style.height = this.container.height() + "px";
	this.center();
}

/**
 * Mark the current drawing as invalid
 */
MolPad.prototype.requestRedraw = function()
{
	this.redrawRequest = true;
}

/**
 * Validates the current drawing
 * @return {Boolean} Indicates if a redraw will be executed
 */
MolPad.prototype.clearRedrawRequest = function()
{
	if(this.redrawRequest)
	{
		this.redrawRequest = false;
		this.redraw();
		return true;
	}
	else
	{
		return false;
	}
}

/**
 * Updates scaling of the drawing settings
 */
MolPad.prototype.update = function()
{
	var oldAtomScale = this.s.atom.scale;

	this.s.atom.miniLabel = this.getScale() <= this.s.atom.maxMiniLabelScale;
	this.s.atom.scale = this.getScale() < this.s.atom.minScale ?
			this.s.atom.minScale / this.getScale() : 1;
	this.s.bond.deltaScale = this.getScale() < this.s.bond.minDeltaScale ?
			this.s.bond.minDeltaScale / this.getScale() : 1;
	this.s.bond.scale = this.getScale() < this.s.bond.minScale ?
			this.s.bond.minScale / this.getScale() : 1;

	this.s.atom.radiusScaled = this.s.atom.radius * this.s.atom.scale;
	this.s.atom.selectionRadiusScaled = this.s.atom.selectionRadius * this.s.atom.scale;
	this.s.bond.radiusScaled = this.s.bond.radius * this.s.bond.scale;

	//if metrics are changed, atom.scale will always be amongst them
	if(this.s.atom.scale !== oldAtomScale)
	{
		this.mol.invalidateAll();
		this.mol.exec(function(atom)
		{
			atom.line = undefined;
		}, true, false);
	}
}

/**
 * Set the cursor in the container to the provided cursor
 * @param {String} type HTML cursur type
 */
MolPad.prototype.setCursor = function(type)
{
	this.container.css("cursor", type);
}

/**
 * Set font for label rendering
 * @param {String} type Font type (label settings are in MolPad.s.font[type])
 */
MolPad.prototype.setFont = function(type)
{
	//note that all fonts are scaled using the atom scale
	var font = this.s.fonts[type].fontStyle + " " +
			Math.round((this.s.fonts[type].fontSize
				* this.s.atom.scale) * 96 / 72) + "px " +
			this.s.fonts[type].fontFamily;

	if(font !== this.ctx.font)
	{
		this.ctx.font = font;
	}
}

/**
 * Draw the current scene to the canvas
 */
MolPad.prototype.draw = function()
{
	this.pendingFrame = false;

	if(!this.updated)
	{
		this.updated = true;
		this.update();
	}

	//recalculate where necessary
	this.mol.validateAll();

	//clear
	this.ctx.clearRect(0, 0, this.width(), this.height());

	//apply matrix
	this.ctx.save();
	this.ctx.transform(this.matrix[0], this.matrix[1], this.matrix[2],
					   this.matrix[3], this.matrix[4], this.matrix[5]);

	//draw state (hover/active)
	this.ctx.lineWidth = 2 * this.s.bond.radiusScaled;
	this.ctx.lineCap = this.s.bond.lineCap;
	for(var i = 0; i < this.mol.bonds.length; i++)
	{
		this.mol.bonds[i].drawStateColor();
	}

	this.ctx.lineWidth = 2 * this.s.atom.selectionRadiusScaled;
	this.ctx.lineCap = this.s.atom.lineCap;
	for(var i = 0; i < this.mol.atoms.length; i++)
	{
		this.mol.atoms[i].drawStateColor();
	}

	//draw bonds
	this.ctx.fillStyle = this.ctx.strokeStyle = this.s.bond.color;
	this.ctx.lineWidth = this.s.bond.width * this.s.bond.scale;
	this.ctx.lineCap = this.s.bond.lineCap;
	this.ctx.lineJoin = this.s.bond.lineJoin;
	for(var i = 0; i < this.mol.bonds.length; i++)
	{
		this.mol.bonds[i].drawBond();
	}

	//draw atoms
	this.ctx.fillStyle = this.ctx.strokeStyle = this.s.atom.color;
	for(var i = 0; i < this.mol.atoms.length; i++)
	{
		this.mol.atoms[i].drawLabel();
	}

	//run custom handler drawing function
	if(this.pointer.handler && this.pointer.handler.onDraw)
	{
		this.pointer.handler.onDraw(this);
	}

	this.ctx.restore();
}

/**
 * Redraw using requestAnimationFrame
 * requestAnimationFrame polyfill is already present in GLmol
 * @param {Boolean} update Indicates if scaling update should be performed
 */
MolPad.prototype.redraw = function(update)
{
	if(update) this.updated = false;
	if(this.pendingFrame) return;
	this.pendingFrame = true;
	requestAnimationFrame(this.draw.bind(this));
}

/**
 * Center the current scene
 */
MolPad.prototype.center = function()
{
	if(this.mol.atoms.length === 0) return;

	this.resetMatrix();

	var bbox = this.mol.getBBox();
	var sx = this.width() / bbox.width;
	var sy = this.height() / bbox.height;
	if(sx < sy)
	{
		this.scale(sx);
		this.translate(
			-bbox.x * sx,
			-bbox.y * sx + (this.height() - bbox.height * sx) / 2);
	}
	else
	{
		this.scale(sy);
		this.translate(
			-bbox.x * sy + (this.width() - bbox.width * sy) / 2,
			-bbox.y * sy);
	}

	var s = 1 - 2 * this.s.relativePadding;
	this.scaleAbsolute(s, this.width() / 2, this.height() / 2);

	this.redraw(true);
}

/**
 * Get canvas width
 * @return {Float} Canvas width
 */
MolPad.prototype.width = function()
{
	return this.canvas.width;
}

/**
 * Get canvas height
 * @return {Float} Canvas height
 */
MolPad.prototype.height = function()
{
	return this.canvas.height;
}

/**
 * Translate the scene
 * @param {Float} dx Horizontal translation
 * @param {Float} dy Vertical translation
 */
MolPad.prototype.translate = function(dx, dy)
{
	this.matrix[4] += dx;
	this.matrix[5] += dy;
}

/**
 * Scale the scene
 * @param {Float} s Scale factor
 */
MolPad.prototype.scale = function(s)
{
	this.matrix[0] *= s;
	this.matrix[3] *= s;
}

/**
 * Return current x scale
 */
MolPad.prototype.getScale = function()
{
	return this.matrix[0];
}

/**
 * Scale absolute to container using an absolute centerpoint relative to the
 * container top-left corner
 * @param {Float} s  Scale
 * @param {Float} cx Scale origin x
 * @param {Float} cy Scale origin y
 */
MolPad.prototype.scaleAbsolute = function(s, cx, cy)
{
	this.matrix[0] *= s;
	this.matrix[3] *= s;
	this.matrix[4] -= (cx - this.matrix[4]) * (s - 1);
	this.matrix[5] -= (cy - this.matrix[5]) * (s - 1);
}

/**
 * Resets the transformation matrix to its default values
 */
MolPad.prototype.resetMatrix = function()
{
	this.matrix = [ 1, 0, 0, 1, 0, 0 ];
}
/**
 * This file is part of MolView (http://molview.org)
 * Copyright (c) 2014, 2015 Herman Bergwerf
 *
 * MolView is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MolView is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with MolView.  If not, see <http://www.gnu.org/licenses/>.
 */

MolPad.prototype.setupEventHandling = function()
{
	//keydown tracker
	this.keys = {
		ctrl: false
	};

	//event pointer data
	this.pointer = {
		old: {
			p: new MPPoint(),
			r: new MPPoint(),
			c: new MPPoint(),
			d: 0,
		},
		handler: undefined,
		touches: 0,
		touchGrab: false
	};

	var scope = this;

	/**
	 * Mousewheel handler
	 */

	this.container.on('DOMMouseScroll mousewheel', function(e)
	{
		e.preventDefault();

		if(e.originalEvent.detail)
		{
			scope.onScroll(e.originalEvent.detail / 3, e, scope);
		}
		else if(e.originalEvent.wheelDelta)
		{
			scope.onScroll(e.originalEvent.wheelDelta / 120, e, scope);
		}
	});

	/**
	 * Event pointer handlers
	 */

	this.container.on("contextmenu", function(e)
	{
		return false;
	});
	this.container.on("mousedown touchstart", function(e)
	{
		scope.onPointerDown(e);
		scope.clearRedrawRequest();
	});

	// register on container instead of window
	this.container.on("mousemove", function(e)
	{
		scope.onMouseMoveInContainer(e);
		scope.clearRedrawRequest();
	});
	this.container.on("mouseout", function(e)
	{
		scope.onMouseOut(e);
		scope.clearRedrawRequest();
	});
	this.container.on("mousemove touchmove", function(e)
	{
		scope.onPointerMove(e);
		scope.clearRedrawRequest();
	});
	this.container.on("mouseup touchend touchcancel", function(e)
	{
		scope.onPointerUp(e);
		scope.clearRedrawRequest();
	});
	this.container.on("blur", function(e)
	{
		scope.onBlur(e);
	});

	/**
	 * Keyboard handlers
	 */

	if(navigator.platform.toLowerCase().indexOf("mac") >= 0)
	{
		this.container.bind("keydown", "meta+z", function(e)
				{ e.preventDefault(); scope.undo(); });
		this.container.bind("keydown", "meta+y", function(e)
				{ e.preventDefault(); scope.redo(); });
		this.container.bind("keydown", "meta+shift+z", function(e)
				{ e.preventDefault(); scope.redo(); });
	}
	else
	{
		this.container.bind("keydown", "ctrl+z", function(e)
				{ e.preventDefault(); scope.undo(); });
		this.container.bind("keydown", "ctrl+y", function(e)
				{ e.preventDefault(); scope.redo(); });
		this.container.bind("keydown", "ctrl+shift+z", function(e)
				{ e.preventDefault(); scope.redo(); });
	}

	this.container.on("keydown", function(e)
	{
		scope.keys.ctrl = e.ctrlKey;

		if(e.keyCode === 46)//forward backspace
		{
			scope.sel.remove();
			scope.clearRedrawRequest();
		}
	});
	this.container.on("keyup", function(e)
	{
		scope.keys.ctrl = e.ctrlKey;
	});
}

MolPad.prototype.onScroll = function(delta, e, scope)
{
	var s = 1 + this.s.zoomSpeed * delta;
	if(this.matrix[0] * s < this.s.minZoom) s = this.s.minZoom / this.matrix[0];
	var p = new MPPoint().fromPointer(e);

	var offset = scope.canvas.getBoundingClientRect();
	p.x = (p.x - offset.left) * scope.devicePixelRatio;
	p.y = (p.y - offset.top) * scope.devicePixelRatio;

	if(this.s.zoomType === MP_ZOOM_TO_COG)
	{
		/*
		Transform molecule center into absolute point;
		relative pointer transformations
		--------------------------------
		this.x = (this.x - mpctx.offset.left) * mpctx.devicePixelRatio;
		this.y = (this.y - mpctx.offset.top) * mpctx.devicePixelRatio;
		this.x = (this.x - mpctx.matrix[4]) / mpctx.matrix[0];
		this.y = (this.y - mpctx.matrix[5]) / mpctx.matrix[3];
		*/

		var center = new MPPoint();
		for(var i = 0; i < this.mol.atoms.length; i++)
		{
			center.add(this.mol.atoms[i].center);
		}
		center.divide(this.mol.atoms.length);

		/*
		reversed transformation to transform
		relative point into absolute pointer
		*/
		center.multiplyX(this.matrix[0]);
		center.multiplyY(this.matrix[3]);
		center.addX(this.matrix[4]);
		center.addY(this.matrix[5]);
		center.divide(this.devicePixelRatio);

		this.scaleAbsolute(s, center.x, center.y);
	}
	else
	{
		this.scaleAbsolute(s, p.x, p.y);
	}

	this.redraw(true);
}

MolPad.prototype.onPointerDown = function(e)
{
	/* if(e.target !== this.canvas && this.pointer.handler === undefined ||
			(e.type === "touchstart" && this.pointer.handler === undefined && e.originalEvent.targetTouches.length > 1))
	{
		return;
	} */

	e.preventDefault();
	e.stopImmediatePropagation();

	var oe = e.originalEvent;

	/*
	If this is a mouse event and there are no touches registered:
		make sure touch grabbing is disabled
	If touch grabbing is disabled and this is a mouse event:
		Abort handler
	 */
	if(e.type === "mousedown")
	{
		if(this.pointer.touches === 0)
		{
			this.pointer.touchGrab = false;
		}
		else if(this.pointer.touchGrab)
		{
			return;
		}
	}
	else if(e.type === "touchstart")
	{
		this.pointer.touchGrab = true;
		this.pointer.touches = oe.targetTouches.length || 1;
	}

	//retrieve event data
	this.pointer.old.p.fromPointer(e);
	this.pointer.old.r.fromRelativePointer(e, this);
	this.pointer.handler = undefined;

	//clear selection if the current tool is not erase, select or drag
	if(!oneOf(this.tool.type, ["erase", "select", "drag"]))
	{
		this.sel.clear();
	}

	//check if there are multiple touches in this event
	if(oe.targetTouches && oe.targetTouches.length > 1)
	{
		//simulate pointer up for old single pointer handler in order
		//to dismiss the old handler properly
		if(this.pointer.handler && this.pointer.handler.onPointerUp)
		{
			this.pointer.handler.onPointerUp(e, this);
		}
		//undo single pointer changes
		if(this.mol.isChanged())
		{
			//reload the copy: the molecule has been changed but it's copy has
			//not yet been updated (reset event display is not necessary since
			//a clean new molecule is loaded)
			this.mol.loadPlainData(this.mol.copy);
		}
		else
		{
			this.resetEventDisplay();
		}
		//update multitouch event data
		this.pointer.old.c.fromMultiTouchCenter(e);
		this.pointer.old.d = getMultiTouchDelta(e);
		this.pointer.handler = this.multiTouchHandler;
	}
	else if(e.which === 1 || (oe.targetTouches && oe.targetTouches.length === 1))
	{
		//redefine handler and execute onPointerDown
		this.handleEvent(this.pointer.old.r, "active", function(obj)
		{
			this.pointer.handler = obj.getHandler(this);
		});
		if(this.pointer.handler === undefined)
		{
			this.pointer.handler = this.getHandler();
		}
	}
	else if(e.which === 2 || e.which === 3)
	{
		this.pointer.handler = this.mouseDragHandler;
	}

	if(this.pointer.handler && this.pointer.handler.onPointerDown)
	{
		this.pointer.handler.onPointerDown(e, this);
	}
}

MolPad.prototype.onMouseMoveInContainer = function(e)
{
	//dimiss mouse events if touch is active
	if(this.pointer.touchGrab)
	{
		return;
	}
	else if(this.pointer.handler === undefined)
	{
		this.hoverHandler.onPointerMove(e, this);
	}
}

MolPad.prototype.onMouseOut = function(e)
{
	if(this.pointer.handler === undefined)
	{
		this.resetEventDisplay();
		this.setCursor("default");
	}
}

MolPad.prototype.onPointerMove = function(e)
{
	//dimiss mouse events if touch is active
	if(e.type === "mousemove" && this.pointer.touchGrab)
	{
		return;
	}
	else if(this.pointer.handler && this.pointer.handler.onPointerMove)
	{
		e.preventDefault();
		this.pointer.handler.onPointerMove(e, this);
	}
}

MolPad.prototype.onPointerUp = function(e)
{
	//dimiss mouse events if touch is active
	if(e.type === "mouseup" && this.pointer.touchGrab)
	{
		return;
	}

	var oe = e.originalEvent;

	if(this.pointer.handler)
	{
		if(this.pointer.handler.onPointerUp)
		{
			this.pointer.handler.onPointerUp(e, this);
		}

		if(this.pointer.handler.scope)
		{
			this.setCursor("pointer");
			this.resetEventDisplay();
			this.pointer.handler.scope.setDisplay(
					e.type === "mouseup" ? "hover" : "normal");
		}
		else
		{
			this.setCursor("default");
		}
	}
	else
	{
		this.setCursor("default");
	}

	//only one multi-touch pointer left: switch to dragHandler
	if(oe.targetTouches)
	{
		if(oe.targetTouches.length > 1)
		{
			//update multitouch event data
			this.pointer.old.d = getMultiTouchDelta(e);
			this.pointer.old.c = new MPPoint().fromMultiTouchCenter(e);
		}
		else if(oe.targetTouches.length === 1)
		{
			//reset old pointer for smooth multi to single transition
			this.pointer.old.p = new MPPoint().fromPointer(e);
			this.pointer.old.r.fromRelativePointer(e, this);

			if(this.pointer.handler !== undefined)
			{
				this.pointer.handler = this.mouseDragHandler;
			}
		}
		else
		{
			this.pointer.handler = undefined;
			this.mol.updateCopy();
		}
	}
	else
	{
		this.pointer.handler = undefined;
		this.mol.updateCopy();
	}
}

MolPad.prototype.onBlur = function(e)
{
	this.keys.ctrl = false;
	this.dismissHandler();
}

/**
 * Template function for handling simple events
 * @param {MPPoint}  point    Event origin
 * @param {String}   type     Trigger type: hover || active
 * @param {Function} callback Callback for hits
 */
MolPad.prototype.handleEvent = function(point, type, callback)
{
	var completed = false;
	for(var i = 0; i < this.mol.atoms.length; i++)
	{
		if(completed)
		{
			this.mol.atoms[i].setDisplay("normal");
		}
		else if(this.mol.atoms[i].handle(point, type))
		{
			completed = true;
			callback.call(this, this.mol.atoms[i]);
		}
	}
	for(var i = 0; i < this.mol.bonds.length; i++)
	{
		if(completed)
		{
			this.mol.bonds[i].setDisplay("normal");
		}
		else if(this.mol.bonds[i].handle(point, type))
		{
			completed = true;
			callback.call(this, this.mol.bonds[i]);
		}
	}
}

/**
 * Resets the current handler
 * This will terminate the active handler
 * instead of finishing the current action
 */
MolPad.prototype.dismissHandler = function()
{
	this.resetEventDisplay();
	this.sel.clear();
	this.setCursor("default");
	this.pointer.touches = 0;
	this.pointer.handler = undefined;
	this.clearRedrawRequest();
	this.mol.updateCopy();
}

/**
 * Resets display to normal for all atoms and bonds
 */
MolPad.prototype.resetEventDisplay = function()
{
	this.mol.exec(function(obj) {
		obj.setDisplay("normal");
	}, true, true);
}

/**
 * Event handlers
 */

MolPad.prototype.hoverHandler = {
	onPointerMove: function(e, mp)
	{
		mp.setCursor("default");
		var p = new MPPoint().fromRelativePointer(e, mp);

		mp.handleEvent(p, "hover", function(obj)
		{
			mp.setCursor("pointer");
		});
	}
}

MolPad.prototype.mouseDragHandler = {
	data: {},
	onPointerMove: function(e, mp)
	{
		mp.setCursor("move");
		var p = new MPPoint().fromPointer(e);
		this.data.moved = true;

		if(p.equals(mp.pointer.old)) return;
		mp.translate((p.x - mp.pointer.old.p.x) * mp.devicePixelRatio,
					 (p.y - mp.pointer.old.p.y) * mp.devicePixelRatio);

		mp.pointer.old.p = p;
		mp.requestRedraw();
	},
	onPointerUp: function(e, mp)
	{
		if(!this.data.moved)
		{
			mp.sel.clear();
		}

		mp.setCursor("default");
	}
}

MolPad.prototype.multiTouchHandler = {
	onPointerMove: function(e, mp)
	{
		if(e.originalEvent.targetTouches.length <= 1)
		{
			mp.dismissHandler();
			return;
		}

		var c = new MPPoint().fromMultiTouchCenter(e);
		var d = getMultiTouchDelta(e);

		mp.translate((c.x - mp.pointer.old.c.x) * mp.devicePixelRatio,
					 (c.y - mp.pointer.old.c.y) * mp.devicePixelRatio);

		mp.scaleAbsolute(d / mp.pointer.old.d,
			(c.x - mp.offset.left) * mp.devicePixelRatio,
			(c.y - mp.offset.top) * mp.devicePixelRatio);

		//update event data
		mp.pointer.old.c = c;
		mp.pointer.old.d = d;
		mp.pointer.old.p.fromPointer(e);//for smooth transition to mouseDragHandler
		mp.redraw(true);
	}
}

MolPad.prototype.selectionToolHandler = {
	data: {},
	onDraw: function(mp)
	{
		mp.ctx.fillStyle = mp.s.select.fillStyle;
		mp.ctx.strokeStyle = mp.s.select.strokeStyle;
		mp.ctx.lineWidth = mp.s.select.lineWidth / mp.getScale();
		mp.ctx.lineCap = mp.s.select.lineCap;
		mp.ctx.lineJoin = mp.s.select.lineJoin;
		mp.ctx.setLineDash([
			2 / mp.getScale(),
			5 / mp.getScale()
		]);

		mp.ctx.beginPath();

		if(mp.tool.data.type === "rect" && this.data.rect)
		{
			mp.ctx.rect(this.data.rect.x, this.data.rect.y,
						this.data.rect.width, this.data.rect.height);

			mp.ctx.fill();
			mp.ctx.stroke();
		}
		else if(mp.tool.data.type === "lasso" && this.data.points)//lasso
		{
			for(var i = 0; i < this.data.points.length; i++)
			{
				if(i === 0) mp.ctx.moveTo(this.data.points[i].x, this.data.points[i].y);
				else mp.ctx.lineTo(this.data.points[i].x, this.data.points[i].y);
			}

			mp.ctx.mozFillRule = "evenodd";
			mp.ctx.msFillRule = "evenodd";
			mp.ctx.fillRule = "evenodd";
			mp.ctx.fill("evenodd");
			mp.ctx.stroke();
		}
	},
	onPointerDown: function(e, mp)
	{
		mp.setCursor("pointer");
		this.data = {};
		var p = new MPPoint().fromRelativePointer(e, mp);

		if(!mp.keys.ctrl)
		{
			mp.sel.clear();
			this.data.selAdd = { atoms: [], bonds: [] };
		}
		else
		{
			this.data.selAdd = {
				atoms: mp.sel.cache.atoms.slice(),
				bonds: mp.sel.cache.bonds.slice()
			};
		}

		if(mp.tool.data.type === "rect")
		{
			this.data.rect = {
				x: p.x,
				y: p.y,
				width: 0,
				height: 0
			};
		}
		else//lasso
		{
			this.data.points = [p.clone()];
		}
	},
	onPointerMove: function(e, mp)
	{
		mp.setCursor("default");
		var p = new MPPoint().fromRelativePointer(e, mp);

		if(mp.tool.data.type === "rect")
		{
			this.data.rect.width = p.x - this.data.rect.x;
			this.data.rect.height = p.y - this.data.rect.y;

			//refresh selection
			var rect = this.data.rect;
			mp.mol.exec(function(obj) {
				obj.handleRectSelect(rect);
			}, true, true);
		}
		else//lasso
		{
			this.data.points.push(p);

			//refresh selection
			var polygon = this.data.points;
			mp.mol.exec(function(obj) {
				obj.handlePolygonSelect(polygon);
			}, true, true);
		}

		//select additional atoms/bonds
		for(var i = 0; i < this.data.selAdd.atoms.length; i++)
		{
			mp.mol.atoms[this.data.selAdd.atoms[i]].select(true);
		}
		for(var i = 0; i < this.data.selAdd.bonds.length; i++)
		{
			mp.mol.bonds[this.data.selAdd.bonds[i]].select(true);
		}

		mp.requestRedraw();
	},
	onPointerUp: function(e, mp)
	{
		mp.sel.updateRotationCenter();
		mp.requestRedraw();
	}
}

MolPad.prototype.getHandler = function()
{
	if(this.tool.type === "atom")
	{
		return {
			onPointerDown: function(e, mp)
			{
				var p = new MPPoint().fromRelativePointer(e, mp);
				var atom = new MPAtom(mp, {
					i: mp.mol.atoms.length,
					x: p.x,
					y: p.y,
					element: mp.tool.data.element
				});
				mp.mol.atoms.push(atom);
				mp.pointer.handler.scope = atom;
			}
		};
	}
	else if(this.tool.type === "bond")
	{
		return {
			onPointerDown: function(e, mp)
			{
				var p = new MPPoint().fromRelativePointer(e, mp);

				var atom1 = new MPAtom(mp, {
					i: mp.mol.atoms.length,
					x: p.x - mp.s.bond.length / 2,
					y: p.y,
					element: "C",
					selected: true
				});
				mp.mol.atoms.push(atom1);

				var atom2 = new MPAtom(mp, {
					i: mp.mol.atoms.length,
					x: p.x + mp.s.bond.length / 2,
					y: p.y,
					element: "C",
					selected: true
				});
				mp.mol.atoms.push(atom2);

				var bond = new MPBond(mp, {
					i: mp.mol.bonds.length,
					from: atom1.index,
					to: atom2.index,
					type: mp.tool.data.type,
					stereo: mp.tool.data.stereo,
					selected: true
				});
				mp.mol.bonds.push(bond);

				atom1.addBond(bond.index);
				atom2.addBond(bond.index);

				mp.pointer.handler.scope = bond;

				mp.sel.update();
				mp.sel.center = p.clone();
				//this will cause the pointer to sel center line to be
				//perpendicular to the newly created bond
				mp.sel.currentAngle = mp.sel.startAngle = .5 * Math.PI;
			},
			onPointerMove: function(e, mp)
			{
				var p = new MPPoint().fromRelativePointer(e, mp);
				mp.sel.rotate(p);
			},
			onPointerUp: function(e, mp)
			{
				mp.sel.clear();
			}
		};
	}
	else if(this.tool.type === "fragment")
	{
		return {
			onPointerDown: function(e, mp)
			{
				var p = new MPPoint().fromRelativePointer(e, mp);

				var frag = MPFragments.translate(
						MPFragments.scale(MPFragments.clone(mp.tool.data.frag.full),
							mp.s.bond.length),
							p.x, p.y);

				mp.mol.createFragment(frag, true);

				mp.sel.center = p.clone();
				mp.sel.currentAngle = mp.sel.startAngle = 0;
			},
			onPointerMove: function(e, mp)
			{
				var p = new MPPoint().fromRelativePointer(e, mp);
				mp.sel.rotate(p);
			},
			onPointerUp: function(e, mp)
			{
				mp.sel.clear();
			}
		};
	}
	else if(this.tool.type === "chain")
	{
		return {
			onPointerDown: function(e, mp)
			{
				var p = new MPPoint().fromRelativePointer(e, mp);

				var atom = new MPAtom(mp, {
					i: mp.mol.atoms.length,
					x: p.x, y: p.y,
					element: "C"
				});
				mp.mol.atoms.push(atom);
				mp.pointer.handler = atom.getHandler();
			}
		};
	}
	else if(this.tool.type === "select")
	{
		return this.selectionToolHandler;
	}
	else
	{
		return this.mouseDragHandler;
	}
}

MPFragments.init();

// export constants
MolPad.MP_BOND_SINGLE = MP_BOND_SINGLE;
MolPad.MP_BOND_DOUBLE = MP_BOND_DOUBLE;
MolPad.MP_BOND_TRIPLE = MP_BOND_TRIPLE;
MolPad.MP_STEREO_UP = MP_STEREO_UP;
MolPad.MP_STEREO_DOWN = MP_STEREO_DOWN;

MolPad.fragments = MPFragments;

return MolPad;
});

