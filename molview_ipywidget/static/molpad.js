//generated by bundle_molpad.sh

define(function(require) {

var jQuery = require('jquery');
var $ = jQuery;

/**
 * This file is part of MolView (http://molview.org)
 * Copyright (c) 2014, 2015 Herman Bergwerf
 *
 * MolView is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MolView is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with MolView.  If not, see <http://www.gnu.org/licenses/>.
 */
var JmolAtomColorsHashHex = { "D": "#111111", "H": "#888888", "He": "#849b9b", "Li": "#c87efa", "Be": "#82ab00", "B": "#c38a8a", "C": "#000000", "N": "#304ff7", "O": "#ff0d0d", "F": "#6dab3c", "Ne": "#7b9ca8", "Na": "#ab5cf2", "Mg": "#61b400", "Al": "#a79191", "Si": "#b09276", "P": "#ff8000", "S": "#c39517", "Cl": "#1dc51d", "Ar": "#63a2b0", "K": "#8f40d4", "Ca": "#2fc300", "Sc": "#969696", "Ti": "#94969a", "V": "#96969a", "Cr": "#8796c3", "Mn": "#9c7ac7", "Fe": "#e06633", "Co": "#db8293", "Ni": "#45b645", "Cu": "#c78033", "Zn": "#7d80b0", "Ga": "#bd8c8c", "Ge": "#668f8f", "As": "#bd80e3", "Se": "#e28f00", "Br": "#a62929", "Kr": "#53a6bc", "Rb": "#702eb0", "Sr": "#00d000", "Y": "#5fa4a4", "Zr": "#6ba2a2", "Nb": "#61a4a9", "Mo": "#4ea9a9", "Tc": "#3b9e9e", "Ru": "#248f8f", "Rh": "#0a7d8c", "Pd": "#006985", "Ag": "#969696", "Cd": "#ae9462", "In": "#a67573", "Sn": "#668080", "Sb": "#9e63b5", "Te": "#d47a00", "I": "#940094", "Xe": "#429eb0", "Cs": "#57178f", "Ba": "#00c900", "La": "#57a4c5", "Ce": "#989877", "Pr": "#869d7b", "Nd": "#7da07d", "Pm": "#69a581", "Sm": "#5ea883", "Eu": "#43b089", "Gd": "#31b48d", "Tb": "#23b890", "Dy": "#17bb92", "Ho": "#00c578", "Er": "#00c765", "Tm": "#00c94e", "Yb": "#00bf38", "Lu": "#00ab24", "Hf": "#42a8dc", "Ta": "#4ba2f9", "W": "#2194d6", "Re": "#267dab", "Os": "#266696", "Ir": "#175487", "Pt": "#9595a0", "Au": "#b9981a", "Hg": "#9595a9", "Tl": "#a6544d", "Pb": "#575961", "Bi": "#9e4fb5", "Po": "#ab5c00", "At": "#754f45", "Rn": "#428296", "Fr": "#420066", "Ra": "#007d00", "Ac": "#669ce4", "Th": "#00b8fc", "Pa": "#00a1ff", "U": "#008fff", "Np": "#0080ff", "Pu": "#006bff", "Am": "#545cf2", "Cm": "#785ce3", "Bk": "#8a4fe3", "Cf": "#a136d4", "Es": "#b31fd4", "Fm": "#B31FBA", "Md": "#B30DA6", "No": "#BD0D87", "Lr": "#C70066", "Rf": "#CC0059", "Db": "#D1004F", "Sg": "#D90045", "Bh": "#E00038", "Hs": "#E6002E", "Mt": "#EB0026", "Ds": "#9595a0", "Rg": "#b9981a", "Cn": "#9595a9" };
/**
 * This file is part of MolView (http://molview.org)
 * Copyright (c) 2014, 2015 Herman Bergwerf
 *
 * MolView is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MolView is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with MolView.  If not, see <http://www.gnu.org/licenses/>.
 */
var MPZoomToType;
(function (MPZoomToType) {
    MPZoomToType[MPZoomToType["COG"] = 0] = "COG";
    MPZoomToType[MPZoomToType["POINTER"] = 1] = "POINTER";
})(MPZoomToType || (MPZoomToType = {}));
var MolPad = (function () {
    /**
     * Initialize MolPad in the given container
     * TODO: larger touch targets on high DPI screens
     * TODO: add implicit hydrogen as subset of MPAtom
     * TODO: collapse newly added implicit H atoms if !skeletal
     * TODO: always on feature for select tool
     *
     * @param {DOMElement} container
     * @param {Float}      devicePixelRatio
     * @param {Object}     buttons
     */
    function MolPad(container, devicePixelRatio, buttons) {
        /**
         * Event handlers
         */
        this.hoverHandler = {
            onPointerMove: function (e, mp) {
                mp.setCursor("default");
                var p = new MPPoint().fromRelativePointer(e, mp);
                mp.handleEvent(p, "hover", function (obj) {
                    mp.setCursor("pointer");
                });
            }
        };
        this.mouseDragHandler = {
            data: {},
            onPointerMove: function (e, mp) {
                mp.setCursor("move");
                var p = new MPPoint().fromPointer(e);
                this.data.moved = true;
                if (p.equals(mp.pointer.old))
                    return;
                mp.translate((p.x - mp.pointer.old.p.x) * mp.devicePixelRatio, (p.y - mp.pointer.old.p.y) * mp.devicePixelRatio);
                mp.pointer.old.p = p;
                mp.requestRedraw();
            },
            onPointerUp: function (e, mp) {
                if (!this.data.moved) {
                    mp.sel.clear();
                }
                mp.setCursor("default");
            }
        };
        this.multiTouchHandler = {
            onPointerMove: function (e, mp) {
                if (e.originalEvent.targetTouches.length <= 1) {
                    mp.dismissHandler();
                    return;
                }
                var c = new MPPoint().fromMultiTouchCenter(e);
                var d = getMultiTouchDelta(e);
                mp.translate((c.x - mp.pointer.old.c.x) * mp.devicePixelRatio, (c.y - mp.pointer.old.c.y) * mp.devicePixelRatio);
                mp.scaleAbsolute(d / mp.pointer.old.d, (c.x - mp.offset.left) * mp.devicePixelRatio, (c.y - mp.offset.top) * mp.devicePixelRatio);
                //update event data
                mp.pointer.old.c = c;
                mp.pointer.old.d = d;
                mp.pointer.old.p.fromPointer(e); //for smooth transition to mouseDragHandler
                mp.redraw(true);
            }
        };
        this.selectionToolHandler = {
            data: {},
            onDraw: function (mp) {
                mp.ctx.fillStyle = mp.s.select.fillStyle;
                mp.ctx.strokeStyle = mp.s.select.strokeStyle;
                mp.ctx.lineWidth = mp.s.select.lineWidth / mp.getScale();
                mp.ctx.lineCap = mp.s.select.lineCap;
                mp.ctx.lineJoin = mp.s.select.lineJoin;
                mp.ctx.setLineDash([
                    2 / mp.getScale(),
                    5 / mp.getScale()
                ]);
                mp.ctx.beginPath();
                if (mp.tool.data.type === "rect" && this.data.rect) {
                    mp.ctx.rect(this.data.rect.x, this.data.rect.y, this.data.rect.width, this.data.rect.height);
                    mp.ctx.fill();
                    mp.ctx.stroke();
                }
                else if (mp.tool.data.type === "lasso" && this.data.points) {
                    for (var i = 0; i < this.data.points.length; i++) {
                        if (i === 0)
                            mp.ctx.moveTo(this.data.points[i].x, this.data.points[i].y);
                        else
                            mp.ctx.lineTo(this.data.points[i].x, this.data.points[i].y);
                    }
                    mp.ctx.mozFillRule = "evenodd";
                    mp.ctx.msFillRule = "evenodd";
                    mp.ctx.fillRule = "evenodd";
                    mp.ctx.fill("evenodd");
                    mp.ctx.stroke();
                }
            },
            onPointerDown: function (e, mp) {
                mp.setCursor("pointer");
                this.data = {};
                var p = new MPPoint().fromRelativePointer(e, mp);
                if (!mp.keys.ctrl) {
                    mp.sel.clear();
                    this.data.selAdd = { atoms: [], bonds: [] };
                }
                else {
                    this.data.selAdd = {
                        atoms: mp.sel.cache.atoms.slice(),
                        bonds: mp.sel.cache.bonds.slice()
                    };
                }
                if (mp.tool.data.type === "rect") {
                    this.data.rect = {
                        x: p.x,
                        y: p.y,
                        width: 0,
                        height: 0
                    };
                }
                else {
                    this.data.points = [p.clone()];
                }
            },
            onPointerMove: function (e, mp) {
                mp.setCursor("default");
                var p = new MPPoint().fromRelativePointer(e, mp);
                if (mp.tool.data.type === "rect") {
                    this.data.rect.width = p.x - this.data.rect.x;
                    this.data.rect.height = p.y - this.data.rect.y;
                    //refresh selection
                    var rect = this.data.rect;
                    mp.mol.exec(function (obj) {
                        obj.handleRectSelect(rect);
                    }, true, true);
                }
                else {
                    this.data.points.push(p);
                    //refresh selection
                    var polygon = this.data.points;
                    mp.mol.exec(function (obj) {
                        obj.handlePolygonSelect(polygon);
                    }, true, true);
                }
                //select additional atoms/bonds
                for (var i = 0; i < this.data.selAdd.atoms.length; i++) {
                    mp.mol.atoms[this.data.selAdd.atoms[i]].select(true);
                }
                for (var i = 0; i < this.data.selAdd.bonds.length; i++) {
                    mp.mol.bonds[this.data.selAdd.bonds[i]].select(true);
                }
                mp.requestRedraw();
            },
            onPointerUp: function (e, mp) {
                mp.sel.updateRotationCenter();
                mp.requestRedraw();
            }
        };
        this.loadSettings();
        //active tool data
        this.tool = {
            type: "bond",
            data: { type: MPBondType.SINGLE },
            selection: [] //TMP
        };
        this.mol = new MPMolecule(this);
        this.sel = new MPSelection(this);
        this.buttons = buttons;
        this.container = jQuery(container);
        this.devicePixelRatio = devicePixelRatio || 1;
        this.setupEventHandling();
        this.setupGraphics();
    }
    /**
     * MolPad API
     */
    MolPad.prototype.setTool = function (type, data) {
        this.tool.type = type;
        this.tool.data = data;
    };
    MolPad.prototype.onChange = function (cb) {
        this.changeCallback = cb;
    };
    MolPad.prototype.clear = function (cb) {
        this.mol.clear();
        this.sel.update();
        //retain old molecule translation in case of an undo
        this.scaleAbsolute(1 / this.matrix[0], this.width() / 2, this.height() / 2);
        this.redraw(true);
        this.mol.updateCopy();
    };
    MolPad.prototype.changed = function () {
        jQuery(this.buttons.undo).toggleClass("tool-button-disabled", this.mol.stack.length === 0);
        jQuery(this.buttons.redo).toggleClass("tool-button-disabled", this.mol.reverseStack.length === 0);
        if (this.changeCallback !== undefined)
            this.changeCallback();
    };
    MolPad.prototype.undo = function (noRedoPush) {
        if (noRedoPush === void 0) { noRedoPush = false; }
        this.dismissHandler();
        if (this.mol.undo(noRedoPush))
            this.changed();
    };
    MolPad.prototype.redo = function () {
        this.dismissHandler();
        if (this.mol.redo())
            this.changed();
    };
    MolPad.prototype.setSkeletalDisplay = function (on) {
        if (on === this.s.skeletalDisplay)
            return;
        this.dismissHandler();
        this.s.skeletalDisplay = on;
        if (on)
            this.mol.removeImplicitHydrogen();
        else
            this.mol.addImplicitHydrogen();
        this.mol.invalidateAll();
        this.clearRedrawRequest();
        this.mol.updateCopy();
    };
    MolPad.prototype.setColored = function (on) {
        this.s.atom.colored = this.s.bond.colored = on;
        this.s.fonts.isotope.fontStyle = this.s.fonts.element.fontStyle =
            this.s.fonts.charge.fontStyle = on ? "bold" : "normal";
        this.redraw(true);
    };
    MolPad.prototype.toDataURL = function () {
        return this.canvas.toDataURL("image/png");
    };
    /**
     * Load molfile
     * @param {String}  mol
     * @param {Boolean} forceRemoveHydrogen
     */
    MolPad.prototype.loadMOL = function (mol, forceRemoveHydrogen) {
        this.mol.loadMOL(mol);
        if (this.s.skeletalDisplay || forceRemoveHydrogen) {
            this.mol.removeImplicitHydrogen();
        }
        this.center();
        this.mol.updateCopy();
    };
    MolPad.prototype.getMOL = function () {
        return this.mol.getMOL();
    };
    MolPad.prototype.getSMILES = function () {
        return this.mol.getSMILES();
    };
    // EVENTS ======================================================================
    MolPad.prototype.setupEventHandling = function () {
        //keydown tracker
        this.keys = {
            ctrl: false
        };
        //event pointer data
        this.pointer = {
            old: {
                p: new MPPoint(),
                r: new MPPoint(),
                c: new MPPoint(),
                d: 0
            },
            handler: undefined,
            touches: 0,
            touchGrab: false
        };
        var scope = this;
        /**
         * Mousewheel handler
         */
        this.container.on('DOMMouseScroll mousewheel', function (e) {
            e.preventDefault();
            if (e.originalEvent.detail) {
                scope.onScroll(e.originalEvent.detail / 3, e, scope);
            }
            else if (e.originalEvent.wheelDelta) {
                scope.onScroll(e.originalEvent.wheelDelta / 120, e, scope);
            }
        });
        /**
         * Event pointer handlers
         */
        this.container.on("contextmenu", function (e) {
            return false;
        });
        this.container.on("mousedown touchstart", function (e) {
            scope.onPointerDown(e);
            scope.clearRedrawRequest();
        });
        // register on container instead of window
        this.container.on("mousemove", function (e) {
            scope.onMouseMoveInContainer(e);
            scope.clearRedrawRequest();
        });
        this.container.on("mouseout", function (e) {
            scope.onMouseOut(e);
            scope.clearRedrawRequest();
        });
        this.container.on("mousemove touchmove", function (e) {
            scope.onPointerMove(e);
            scope.clearRedrawRequest();
        });
        this.container.on("mouseup touchend touchcancel", function (e) {
            scope.onPointerUp(e);
            scope.clearRedrawRequest();
        });
        this.container.on("blur", function (e) {
            scope.onBlur(e);
        });
        /**
         * Keyboard handlers
         */
        if (navigator.platform.toLowerCase().indexOf("mac") >= 0) {
            this.container.bind("keydown", "meta+z", function (e) { e.preventDefault(); scope.undo(); });
            this.container.bind("keydown", "meta+y", function (e) { e.preventDefault(); scope.redo(); });
            this.container.bind("keydown", "meta+shift+z", function (e) { e.preventDefault(); scope.redo(); });
        }
        else {
            this.container.bind("keydown", "ctrl+z", function (e) { e.preventDefault(); scope.undo(); });
            this.container.bind("keydown", "ctrl+y", function (e) { e.preventDefault(); scope.redo(); });
            this.container.bind("keydown", "ctrl+shift+z", function (e) { e.preventDefault(); scope.redo(); });
        }
        this.container.on("keydown", function (e) {
            scope.keys.ctrl = e.ctrlKey;
            if (e.keyCode === 46) {
                scope.sel.remove();
                scope.clearRedrawRequest();
            }
        });
        this.container.on("keyup", function (e) {
            scope.keys.ctrl = e.ctrlKey;
        });
    };
    MolPad.prototype.onScroll = function (delta, e, scope) {
        var s = 1 + this.s.zoomSpeed * delta;
        if (this.matrix[0] * s < this.s.minZoom)
            s = this.s.minZoom / this.matrix[0];
        var p = new MPPoint().fromPointer(e);
        var offset = scope.canvas.getBoundingClientRect();
        p.x = (p.x - offset.left) * scope.devicePixelRatio;
        p.y = (p.y - offset.top) * scope.devicePixelRatio;
        if (this.s.zoomType === MPZoomToType.COG) {
            /*
            Transform molecule center into absolute point;
            relative pointer transformations
            --------------------------------
            this.x = (this.x - mpctx.offset.left) * mpctx.devicePixelRatio;
            this.y = (this.y - mpctx.offset.top) * mpctx.devicePixelRatio;
            this.x = (this.x - mpctx.matrix[4]) / mpctx.matrix[0];
            this.y = (this.y - mpctx.matrix[5]) / mpctx.matrix[3];
            */
            var center = new MPPoint();
            for (var i = 0; i < this.mol.atoms.length; i++) {
                center.add(this.mol.atoms[i].center);
            }
            center.divide(this.mol.atoms.length);
            /*
            reversed transformation to transform
            relative point into absolute pointer
            */
            center.multiplyX(this.matrix[0]);
            center.multiplyY(this.matrix[3]);
            center.addX(this.matrix[4]);
            center.addY(this.matrix[5]);
            center.divide(this.devicePixelRatio);
            this.scaleAbsolute(s, center.x, center.y);
        }
        else {
            this.scaleAbsolute(s, p.x, p.y);
        }
        this.redraw(true);
    };
    MolPad.prototype.onPointerDown = function (e) {
        /* if(e.target !== this.canvas && this.pointer.handler === undefined ||
                (e.type === "touchstart" && this.pointer.handler === undefined && e.originalEvent.targetTouches.length > 1))
        {
            return;
        } */
        e.preventDefault();
        e.stopImmediatePropagation();
        var oe = e.originalEvent;
        /*
        If this is a mouse event and there are no touches registered:
            make sure touch grabbing is disabled
        If touch grabbing is disabled and this is a mouse event:
            Abort handler
         */
        if (e.type === "mousedown") {
            if (this.pointer.touches === 0) {
                this.pointer.touchGrab = false;
            }
            else if (this.pointer.touchGrab) {
                return;
            }
        }
        else if (e.type === "touchstart") {
            this.pointer.touchGrab = true;
            this.pointer.touches = oe.targetTouches.length || 1;
        }
        //retrieve event data
        this.pointer.old.p.fromPointer(e);
        this.pointer.old.r.fromRelativePointer(e, this);
        this.pointer.handler = undefined;
        //clear selection if the current tool is not erase, select or drag
        if (!oneOf(this.tool.type, ["erase", "select", "drag"])) {
            this.sel.clear();
        }
        //check if there are multiple touches in this event
        if (oe.targetTouches && oe.targetTouches.length > 1) {
            //simulate pointer up for old single pointer handler in order
            //to dismiss the old handler properly
            if (this.pointer.handler && this.pointer.handler.onPointerUp) {
                this.pointer.handler.onPointerUp(e, this);
            }
            //undo single pointer changes
            if (this.mol.isChanged()) {
                //reload the copy: the molecule has been changed but it's copy has
                //not yet been updated (reset event display is not necessary since
                //a clean new molecule is loaded)
                this.mol.loadPlainData(this.mol.copy);
            }
            else {
                this.resetEventDisplay();
            }
            //update multitouch event data
            this.pointer.old.c.fromMultiTouchCenter(e);
            this.pointer.old.d = getMultiTouchDelta(e);
            this.pointer.handler = this.multiTouchHandler;
        }
        else if (e.which === 1 || (oe.targetTouches && oe.targetTouches.length === 1)) {
            //redefine handler and execute onPointerDown
            this.handleEvent(this.pointer.old.r, "active", function (obj) {
                this.pointer.handler = obj.getHandler(this);
            });
            if (this.pointer.handler === undefined) {
                this.pointer.handler = this.getHandler();
            }
        }
        else if (e.which === 2 || e.which === 3) {
            this.pointer.handler = this.mouseDragHandler;
        }
        if (this.pointer.handler && this.pointer.handler.onPointerDown) {
            this.pointer.handler.onPointerDown(e, this);
        }
    };
    MolPad.prototype.onMouseMoveInContainer = function (e) {
        //dimiss mouse events if touch is active
        if (this.pointer.touchGrab) {
            return;
        }
        else if (this.pointer.handler === undefined) {
            this.hoverHandler.onPointerMove(e, this);
        }
    };
    MolPad.prototype.onMouseOut = function (e) {
        if (this.pointer.handler === undefined) {
            this.resetEventDisplay();
            this.setCursor("default");
        }
    };
    MolPad.prototype.onPointerMove = function (e) {
        //dimiss mouse events if touch is active
        if (e.type === "mousemove" && this.pointer.touchGrab) {
            return;
        }
        else if (this.pointer.handler && this.pointer.handler.onPointerMove) {
            e.preventDefault();
            this.pointer.handler.onPointerMove(e, this);
        }
    };
    MolPad.prototype.onPointerUp = function (e) {
        //dimiss mouse events if touch is active
        if (e.type === "mouseup" && this.pointer.touchGrab) {
            return;
        }
        var oe = e.originalEvent;
        if (this.pointer.handler) {
            if (this.pointer.handler.onPointerUp) {
                this.pointer.handler.onPointerUp(e, this);
            }
            if (this.pointer.handler.scope) {
                this.setCursor("pointer");
                this.resetEventDisplay();
                this.pointer.handler.scope.setDisplay(e.type === "mouseup" ? "hover" : "normal");
            }
            else {
                this.setCursor("default");
            }
        }
        else {
            this.setCursor("default");
        }
        //only one multi-touch pointer left: switch to dragHandler
        if (oe.targetTouches) {
            if (oe.targetTouches.length > 1) {
                //update multitouch event data
                this.pointer.old.d = getMultiTouchDelta(e);
                this.pointer.old.c = new MPPoint().fromMultiTouchCenter(e);
            }
            else if (oe.targetTouches.length === 1) {
                //reset old pointer for smooth multi to single transition
                this.pointer.old.p = new MPPoint().fromPointer(e);
                this.pointer.old.r.fromRelativePointer(e, this);
                if (this.pointer.handler !== undefined) {
                    this.pointer.handler = this.mouseDragHandler;
                }
            }
            else {
                this.pointer.handler = undefined;
                this.mol.updateCopy();
            }
        }
        else {
            this.pointer.handler = undefined;
            this.mol.updateCopy();
        }
    };
    MolPad.prototype.onBlur = function (e) {
        this.keys.ctrl = false;
        this.dismissHandler();
    };
    /**
     * Template function for handling simple events
     * @param {MPPoint}  point    Event origin
     * @param {String}   type     Trigger type: hover || active
     * @param {Function} callback Callback for hits
     */
    MolPad.prototype.handleEvent = function (point, type, callback) {
        var completed = false;
        for (var i = 0; i < this.mol.atoms.length; i++) {
            if (completed) {
                this.mol.atoms[i].setDisplay("normal");
            }
            else if (this.mol.atoms[i].handle(point, type)) {
                completed = true;
                callback.call(this, this.mol.atoms[i]);
            }
        }
        for (var i = 0; i < this.mol.bonds.length; i++) {
            if (completed) {
                this.mol.bonds[i].setDisplay("normal");
            }
            else if (this.mol.bonds[i].handle(point, type)) {
                completed = true;
                callback.call(this, this.mol.bonds[i]);
            }
        }
    };
    /**
     * Resets the current handler
     * This will terminate the active handler
     * instead of finishing the current action
     */
    MolPad.prototype.dismissHandler = function () {
        this.resetEventDisplay();
        this.sel.clear();
        this.setCursor("default");
        this.pointer.touches = 0;
        this.pointer.handler = undefined;
        this.clearRedrawRequest();
        this.mol.updateCopy();
    };
    /**
     * Resets display to normal for all atoms and bonds
     */
    MolPad.prototype.resetEventDisplay = function () {
        this.mol.exec(function (obj) {
            obj.setDisplay("normal");
        }, true, true);
    };
    MolPad.prototype.getHandler = function () {
        if (this.tool.type === "atom") {
            return {
                onPointerDown: function (e, mp) {
                    var p = new MPPoint().fromRelativePointer(e, mp);
                    var atom = new MPAtom(mp, {
                        i: mp.mol.atoms.length,
                        x: p.x,
                        y: p.y,
                        element: mp.tool.data.element
                    });
                    mp.mol.atoms.push(atom);
                    mp.pointer.handler.scope = atom;
                }
            };
        }
        else if (this.tool.type === "bond") {
            return {
                onPointerDown: function (e, mp) {
                    var p = new MPPoint().fromRelativePointer(e, mp);
                    var atom1 = new MPAtom(mp, {
                        i: mp.mol.atoms.length,
                        x: p.x - mp.s.bond.length / 2,
                        y: p.y,
                        element: "C",
                        selected: true
                    });
                    mp.mol.atoms.push(atom1);
                    var atom2 = new MPAtom(mp, {
                        i: mp.mol.atoms.length,
                        x: p.x + mp.s.bond.length / 2,
                        y: p.y,
                        element: "C",
                        selected: true
                    });
                    mp.mol.atoms.push(atom2);
                    var bond = new MPBond(mp, {
                        i: mp.mol.bonds.length,
                        from: atom1.index,
                        to: atom2.index,
                        type: mp.tool.data.type,
                        stereo: mp.tool.data.stereo,
                        selected: true
                    });
                    mp.mol.bonds.push(bond);
                    atom1.addBond(bond.index);
                    atom2.addBond(bond.index);
                    mp.pointer.handler.scope = bond;
                    mp.sel.update();
                    mp.sel.center = p.clone();
                    //this will cause the pointer to sel center line to be
                    //perpendicular to the newly created bond
                    mp.sel.currentAngle = mp.sel.startAngle = .5 * Math.PI;
                },
                onPointerMove: function (e, mp) {
                    var p = new MPPoint().fromRelativePointer(e, mp);
                    mp.sel.rotate(p);
                },
                onPointerUp: function (e, mp) {
                    mp.sel.clear();
                }
            };
        }
        else if (this.tool.type === "fragment") {
            return {
                onPointerDown: function (e, mp) {
                    var p = new MPPoint().fromRelativePointer(e, mp);
                    var frag = MPFragments.translate(MPFragments.scale(MPFragments.clone(mp.tool.data.frag.full), mp.s.bond.length), p.x, p.y);
                    mp.mol.createFragment(frag, true);
                    mp.sel.center = p.clone();
                    mp.sel.currentAngle = mp.sel.startAngle = 0;
                },
                onPointerMove: function (e, mp) {
                    var p = new MPPoint().fromRelativePointer(e, mp);
                    mp.sel.rotate(p);
                },
                onPointerUp: function (e, mp) {
                    mp.sel.clear();
                }
            };
        }
        else if (this.tool.type === "chain") {
            return {
                onPointerDown: function (e, mp) {
                    var p = new MPPoint().fromRelativePointer(e, mp);
                    var atom = new MPAtom(mp, {
                        i: mp.mol.atoms.length,
                        x: p.x, y: p.y,
                        element: "C"
                    });
                    mp.mol.atoms.push(atom);
                    mp.pointer.handler = atom.getHandler();
                }
            };
        }
        else if (this.tool.type === "select") {
            return this.selectionToolHandler;
        }
        else {
            return this.mouseDragHandler;
        }
    };
    // GRAPHICS ====================================================================
    /**
     * This file is part of MolView (http://molview.org)
     * Copyright (c) 2014, 2015 Herman Bergwerf
     *
     * MolView is free software: you can redistribute it and/or modify
     * it under the terms of the GNU Affero General Public License as published by
     * the Free Software Foundation, either version 3 of the License, or
     * (at your option) any later version.
     *
     * MolView is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     * GNU Affero General Public License for more details.
     *
     * You should have received a copy of the GNU Affero General Public License
     * along with MolView.  If not, see <http://www.gnu.org/licenses/>.
     */
    MolPad.prototype.setupGraphics = function () {
        //create and setup canvas
        this.canvas = document.createElement("canvas");
        this.canvas.width = this.container.width() * this.devicePixelRatio;
        this.canvas.height = this.container.height() * this.devicePixelRatio;
        this.canvas.style.width = this.container.width() + "px";
        this.canvas.style.height = this.container.height() + "px";
        this.container.append(this.canvas);
        this.redrawRequest = false;
        this.matrix = [1, 0, 0, 1, 0, 0];
        this.ctx = this.canvas.getContext("2d");
        this.updated = false; //used to update only before a real redraw
        this.pendingFrame = false; //used to prevent requestAnimationFrame stacking
    };
    /**
     * Resize the current canvas to fit the container
     */
    MolPad.prototype.resize = function () {
        this.canvas.width = this.container.width() * this.devicePixelRatio;
        this.canvas.height = this.container.height() * this.devicePixelRatio;
        this.canvas.style.width = this.container.width() + "px";
        this.canvas.style.height = this.container.height() + "px";
        this.center();
    };
    /**
     * Mark the current drawing as invalid
     */
    MolPad.prototype.requestRedraw = function () {
        this.redrawRequest = true;
    };
    /**
     * Validates the current drawing
     * @return {Boolean} Indicates if a redraw will be executed
     */
    MolPad.prototype.clearRedrawRequest = function () {
        if (this.redrawRequest) {
            this.redrawRequest = false;
            this.redraw();
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * Updates scaling of the drawing settings
     */
    MolPad.prototype.update = function () {
        var oldAtomScale = this.s.atom.scale;
        this.s.atom.miniLabel = this.getScale() <= this.s.atom.maxMiniLabelScale;
        this.s.atom.scale = this.getScale() < this.s.atom.minScale ?
            this.s.atom.minScale / this.getScale() : 1;
        this.s.bond.deltaScale = this.getScale() < this.s.bond.minDeltaScale ?
            this.s.bond.minDeltaScale / this.getScale() : 1;
        this.s.bond.scale = this.getScale() < this.s.bond.minScale ?
            this.s.bond.minScale / this.getScale() : 1;
        this.s.atom.radiusScaled = this.s.atom.radius * this.s.atom.scale;
        this.s.atom.selectionRadiusScaled = this.s.atom.selectionRadius * this.s.atom.scale;
        this.s.bond.radiusScaled = this.s.bond.radius * this.s.bond.scale;
        //if metrics are changed, atom.scale will always be amongst them
        if (this.s.atom.scale !== oldAtomScale) {
            this.mol.invalidateAll();
            this.mol.exec(function (atom) {
                atom.line = undefined;
            }, true, false);
        }
    };
    /**
     * Set the cursor in the container to the provided cursor
     * @param {String} type HTML cursur type
     */
    MolPad.prototype.setCursor = function (type) {
        this.container.css("cursor", type);
    };
    /**
     * Set font for label rendering
     * @param {String} type Font type (label settings are in MolPad.s.font[type])
     */
    MolPad.prototype.setFont = function (type) {
        //note that all fonts are scaled using the atom scale
        var font = this.s.fonts[type].fontStyle + " " +
            Math.round((this.s.fonts[type].fontSize
                * this.s.atom.scale) * 96 / 72) + "px " +
            this.s.fonts[type].fontFamily;
        if (font !== this.ctx.font) {
            this.ctx.font = font;
        }
    };
    /**
     * Draw the current scene to the canvas
     */
    MolPad.prototype.draw = function () {
        this.pendingFrame = false;
        if (!this.updated) {
            this.updated = true;
            this.update();
        }
        //recalculate where necessary
        this.mol.validateAll();
        //clear
        this.ctx.clearRect(0, 0, this.width(), this.height());
        //apply matrix
        this.ctx.save();
        this.ctx.transform(this.matrix[0], this.matrix[1], this.matrix[2], this.matrix[3], this.matrix[4], this.matrix[5]);
        //draw state (hover/active)
        this.ctx.lineWidth = 2 * this.s.bond.radiusScaled;
        this.ctx.lineCap = this.s.bond.lineCap;
        for (var i = 0; i < this.mol.bonds.length; i++) {
            this.mol.bonds[i].drawStateColor();
        }
        this.ctx.lineWidth = 2 * this.s.atom.selectionRadiusScaled;
        this.ctx.lineCap = this.s.atom.lineCap;
        for (var i = 0; i < this.mol.atoms.length; i++) {
            this.mol.atoms[i].drawStateColor();
        }
        //draw bonds
        this.ctx.fillStyle = this.ctx.strokeStyle = this.s.bond.color;
        this.ctx.lineWidth = this.s.bond.width * this.s.bond.scale;
        this.ctx.lineCap = this.s.bond.lineCap;
        this.ctx.lineJoin = this.s.bond.lineJoin;
        for (var i = 0; i < this.mol.bonds.length; i++) {
            this.mol.bonds[i].drawBond();
        }
        //draw atoms
        this.ctx.fillStyle = this.ctx.strokeStyle = this.s.atom.color;
        for (var i = 0; i < this.mol.atoms.length; i++) {
            this.mol.atoms[i].drawLabel();
        }
        //run custom handler drawing function
        if (this.pointer.handler && this.pointer.handler.onDraw) {
            this.pointer.handler.onDraw(this);
        }
        this.ctx.restore();
    };
    /**
     * Redraw using requestAnimationFrame
     * requestAnimationFrame polyfill is already present in GLmol
     * @param {Boolean} update Indicates if scaling update should be performed
     */
    MolPad.prototype.redraw = function (update) {
        if (update === void 0) { update = false; }
        if (update)
            this.updated = false;
        if (this.pendingFrame)
            return;
        this.pendingFrame = true;
        requestAnimationFrame(this.draw.bind(this));
    };
    /**
     * Center the current scene
     */
    MolPad.prototype.center = function () {
        if (this.mol.atoms.length === 0)
            return;
        this.resetMatrix();
        var bbox = this.mol.getBBox();
        var sx = this.width() / bbox.width;
        var sy = this.height() / bbox.height;
        if (sx < sy) {
            this.scale(sx);
            this.translate(-bbox.x * sx, -bbox.y * sx + (this.height() - bbox.height * sx) / 2);
        }
        else {
            this.scale(sy);
            this.translate(-bbox.x * sy + (this.width() - bbox.width * sy) / 2, -bbox.y * sy);
        }
        var s = 1 - 2 * this.s.relativePadding;
        this.scaleAbsolute(s, this.width() / 2, this.height() / 2);
        this.redraw(true);
    };
    /**
     * Get canvas width
     * @return {Float} Canvas width
     */
    MolPad.prototype.width = function () {
        return this.canvas.width;
    };
    /**
     * Get canvas height
     * @return {Float} Canvas height
     */
    MolPad.prototype.height = function () {
        return this.canvas.height;
    };
    /**
     * Translate the scene
     * @param {Float} dx Horizontal translation
     * @param {Float} dy Vertical translation
     */
    MolPad.prototype.translate = function (dx, dy) {
        this.matrix[4] += dx;
        this.matrix[5] += dy;
    };
    /**
     * Scale the scene
     * @param {Float} s Scale factor
     */
    MolPad.prototype.scale = function (s) {
        this.matrix[0] *= s;
        this.matrix[3] *= s;
    };
    /**
     * Return current x scale
     */
    MolPad.prototype.getScale = function () {
        return this.matrix[0];
    };
    /**
     * Scale absolute to container using an absolute centerpoint relative to the
     * container top-left corner
     * @param {Float} s  Scale
     * @param {Float} cx Scale origin x
     * @param {Float} cy Scale origin y
     */
    MolPad.prototype.scaleAbsolute = function (s, cx, cy) {
        this.matrix[0] *= s;
        this.matrix[3] *= s;
        this.matrix[4] -= (cx - this.matrix[4]) * (s - 1);
        this.matrix[5] -= (cy - this.matrix[5]) * (s - 1);
    };
    /**
     * Resets the transformation matrix to its default values
     */
    MolPad.prototype.resetMatrix = function () {
        this.matrix = [1, 0, 0, 1, 0, 0];
    };
    // SETTINGS ====================================================================
    MolPad.prototype.loadSettings = function () {
        /**
         * Settings
         * @type {Object}
         */
        this.s = {
            /**
             * Maximum undo stack size
             * @type {Integer}
             */
            maxStackSize: 100,
            /**
             * Mousewheel zoom type:
             * - MP_ZOOM_TO_COG: center of gravity
             * - MP_ZOOM_TO_POINTER: mousepointer
             * @type {Integer}
             */
            zoomType: MPZoomToType.POINTER,
            /**
             * Mousewheel zoom speed (multiplier)
             * @type {Float}
             */
            zoomSpeed: 0.2,
            /**
             * You cannot zoom below this level
             * using the mousewheel
             * @type {Float}
             */
            minZoom: 0.01,
            /**
             * Indicates if skeletal display is enabled
             * @type {Boolean}
             */
            skeletalDisplay: true,
            /**
             * This fraction is used to calculate
             * the padding around a centered molecule
             * relative to the canas size
             * @type {Float}
             */
            relativePadding: 0.15,
            /**
             * Pointer events are considered as
             * dragging after moving this number of pixels
             * (devicePixelRatio does not apply here)
             * @type {Float}
             */
            draggingThreshold: 2,
            /**
             * Number of rotation steps for rotating atoms
             * steps of 30deg: 360 / 30 = 12
             * @type {Float}
             */
            rotateSteps: 360 / 30,
            /**
             * This object contains the configuration
             * for various fonts used in MolPad
             * They can be applied using MolPad.setFont()
             * The fontSize is defined as pt
             * @type {Object}
             */
            fonts: {
                element: {
                    fontStyle: "bold",
                    fontFamily: 'sans-serif',
                    fontSize: 12
                },
                charge: {
                    fontStyle: "bold",
                    fontFamily: 'sans-serif',
                    fontSize: 8
                },
                isotope: {
                    fontStyle: "bold",
                    fontFamily: 'sans-serif',
                    fontSize: 8
                },
                chainSize: {
                    fontStyle: "normal",
                    fontFamily: 'sans-serif',
                    fontSize: 12
                }
            },
            /**
             * All settings related to MPAtom
             * @type {Object}
             */
            atom: {
                /**
                 * Styles related to different MPAtom states
                 */
                hover: {
                    color: "#bfb"
                },
                active: {
                    color: "#8f8"
                },
                incorrect: {
                    color: "#f66"
                },
                selected: {
                    color: "#8f8"
                },
                /**
                 * Metrics related to different label sections
                 * the padding is only applied between the sections (vertically)
                 */
                charge: {
                    padding: 1
                },
                isotope: {
                    padding: 1
                },
                /**
                 * MPAtom scale, this scale is recalculated if
                 * the molecule is scaled in order to magnify
                 * atom labels on very small global scales
                 * @type {Float}
                 */
                scale: 1,
                /**
                 * Minimum atom scale, the s.atom.scale is scaled up
                 * using a linear correlation to the global scale if
                 * the global scale is below this value.
                 * 12 * 1 / 1.5 = 8: 8pt is the smallest element label fontSize
                 * @type {RegExp}
                 */
                minScale: 1 / 1.5,
                /**
                 * Radius around atom center (line) for bond vertices
                 * @type {Float}
                 */
                radius: 12,
                /**
                 * Radius around atom center (line) for selection area
                 * (calculate using point-line distance)
                 * @type {Float}
                 */
                selectionRadius: 15,
                /**
                 * Atom default color
                 * @type {String}
                 */
                color: "#111",
                /**
                 * Atom element coloring
                 * @type {Boolean}
                 */
                colored: true,
                /**
                 * Line-cap used to draw the center (line)
                 * @type {String}
                 */
                lineCap: "round",
                /**
                 * The atom label will be surrounded with a (selection) circle
                 * instead of a line if the label with <= circleClamp
                 * @type {Number}
                 */
                circleClamp: 15,
                /**
                 * If you change the element of an atom and drag this far, a new
                 * bond will be created wich connects to a new atom with the
                 * specified element while the atom itself will be restored
                 * @type {Number}
                 */
                minAddRotateLength: 15,
                /**
                 * Below this global scale, a mini-label will be drawn
                 * (small square)
                 * @type {Float}
                 */
                maxMiniLabelScale: 1 / 5.0,
                /**
                 * Mini-label square size in relative units
                 * @type {Float}
                 */
                miniLabelSize: 25,
                /**
                 * This switch is updated automatically in MolPad.update()
                 * and used in MPAtom.drawLabel()
                 * @type {Boolean}
                 */
                miniLabel: false
            },
            /**
             * All settings related to MPBond
             * @type {Object}
             */
            bond: {
                /**
                 * If element coloring is enabled, a color gradient will
                 * be drawed on this part of the bond
                 * @type {Object}
                 */
                gradient: {
                    from: 0.4,
                    to: 0.6
                },
                /**
                 * Default MPBond color
                 * @type {String}
                 */
                color: "#111",
                /**
                 * Bond gradient coloring switch
                 * @type {Boolean}
                 */
                colored: true,
                /**
                 * MPBond state styles
                 * @type {Object}
                 */
                hover: {
                    color: "#bfb"
                },
                active: {
                    color: "#8f8"
                },
                selected: {
                    color: "#8f8"
                },
                /**
                 * MPBond metrics
                 * @type {Array}
                 */
                delta: [
                    [],
                    [0],
                    [-4, 4],
                    [-8, 8],
                    [-6, 6],
                    [0, 8] //cis bond
                ],
                /**
                 * Default MPBond length. Molfiles from PubChem etc. will be
                 * magnfied using this value in order to scale to this bond length.
                 * @type {Float}
                 */
                length: 55,
                /**
                 * Default MPBond length for hydrogen atoms
                 * @type {Float}
                 */
                lengthHydrogen: 34,
                /**
                 * Radius around MPBond center line (selection area)
                 * @type {Float}
                 */
                radius: 8,
                /**
                 * Line-cap used for MPBond selection area
                 * @type {String}
                 */
                lineCap: "round",
                /**
                 * Line-join used for wedge bonds
                 * @type {String}
                 */
                lineJoin: "round",
                /**
                 * MPBond line-width
                 * @type {Float}
                 */
                width: 1.5,
                /**
                 * MPBond scale, this scale is recalculated if
                 * the molecule is scaled in order to magnify
                 * bond lines on very small global scales
                 * @type {Float}
                 */
                scale: 1,
                /**
                 * Smallest bond scale.
                 * 1.5 * 1 / 1.5 = 1: 1px is min bond width in px
                 * @type {Float}
                 */
                minScale: 1 / 1.5,
                /**
                 * Smallest scale for magnifying the bond.delta
                 * This will make sure the distance does not get smaller as 1px
                 * @type {Float}
                 */
                minDeltaScale: 1 / 4.0,
                /**
                 * Below this scale, only one bond line is drawn
                 * (also for wedge bonds etc.)
                 * @type {Float}
                 */
                singleOnlyScale: 1 / 5.0,
                /**
                 * Space between lines in hash bonds in relative units
                 * bondWidth = bond.width for hash bond lines too
                 * @type {Float}
                 */
                hashLineSpace: 2,
                /**
                 * Maximal bond.line.to.distanceTo(wedgeFitPoint)
                 * @type {Float}
                 */
                wedgeFitMaxD: 20,
                /**
                 * Most ideal bisect angle for double/triple bonds
                 * @type {Float}
                 */
                bestBisect: Math.PI / 4,
                /**
                 * Angle deviation to determine if different bond angles are
                 * visually equal
                 * @type {RegExp}
                 */
                angleDev: Math.PI / 30
            },
            chain: {
                /**
                 * Chain rotation steps
                 * steps of 30deg: 360 / 30 = 12
                 * @type {RegExp}
                 */
                rotateSteps: 360 / 30,
                /**
                 * Deviation angle to create a zig-zag carbon chain
                 * @type {Float}
                 */
                devAngle: Math.PI / 6,
                /**
                 * Chain label padding in relative units
                 * @type {Float}
                 */
                padding: 2,
                /**
                 * Chain label color
                 * @type {String}
                 */
                color: "#f50",
                /**
                 * Chain line color
                 * @type {String}
                 */
                strokeStyle: "#f50",
                /**
                 * Chain line-cap
                 * @type {String}
                 */
                lineCap: "round",
                /**
                 * Chain line-join
                 * @type {String}
                 */
                lineJoin: "round"
            },
            select: {
                /**
                 * Selection area fill style
                 * @type {String}
                 */
                fillStyle: "rgba(255, 85, 0, 0.3)",
                /**
                 * Selection area stroke color
                 * @type {String}
                 */
                strokeStyle: "#f50",
                /**
                 * Selection area stroke lineWidth
                 * @type {Number}
                 */
                lineWidth: 2,
                /**
                 * Seletion area stroke lineCap
                 * @type {String}
                 */
                lineCap: "round",
                /**
                 * Seletion area stroke lineJoin
                 * @type {String}
                 */
                lineJoin: "round"
            }
        };
    };
    return MolPad;
}());
/**
 * This file is part of MolView (http://molview.org)
 * Copyright (c) 2014, 2015 Herman Bergwerf
 *
 * MolView is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MolView is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with MolView.  If not, see <http://www.gnu.org/licenses/>.
 */
var MPAtom = (function () {
    /**
     * Create new MPAtom
     * @param {MolPad} mp
     * @param {Object} obj Configuration
     */
    function MPAtom(mp, obj) {
        this.mp = mp;
        this.index = obj.i;
        this.center = new MPPoint(obj.x || 0, obj.y || 0);
        this.element = obj.element || "C";
        this.charge = obj.charge || 0;
        this.isotope = obj.isotope || 0;
        this.bonds = obj.bonds !== undefined ? obj.bonds.slice() : []; //deep copy
        this.selected = obj.selected || false;
        this.display = "normal";
        this.valid = false;
        this.mp.requestRedraw();
    }
    MPAtom.prototype.getX = function () { return this.center.x; };
    MPAtom.prototype.getY = function () { return this.center.y; };
    //TODO
    //    /**
    //     * Retruns data which can be used as input by the Ketcher fork
    //     * @param {Object} mp
    //     * @return {Object}
    //     */
    //    getKetcherData()
    //    {
    //        return new chem.Struct.Atom({
    //            pp: {
    //                x: this.center.x / this.mp.s.bond.length,
    //                y: this.center.y / this.mp.s.bond.length
    //            },
    //            label: this.element,
    //            charge: this.charge,
    //            isotope: this.isotope
    //        });
    //    }
    /**
     * Retruns config data which can be used to reconstruct this object
     * @return {Object}
     */
    MPAtom.prototype.getConfig = function () {
        return {
            i: this.index,
            x: this.center.x,
            y: this.center.y,
            element: this.element,
            charge: this.charge,
            isotope: this.isotope,
            bonds: this.bonds.slice()
        };
    };
    /**
     * Retruns MPAtom string which can be compared to other MPAtom strings
     * @return {String}
     */
    MPAtom.prototype.toString = function () {
        var str = this.center.x.toString() + ","
            + this.center.y.toString() + ","
            + this.element.toString() + ","
            + this.charge.toString() + ","
            + this.isotope.toString();
        for (var i = 0; i < this.bonds.length; i++) {
            str += "," + this.mp.mol.bonds[this.bonds[i]].toString();
        }
        return str;
    };
    /**
     * Generates charge label for this atom
     * @return {String} Charge label as string
     */
    MPAtom.prototype.getChargeLabel = function () {
        return this.charge === 0 ? "" :
            this.charge === -1 ? "\u2212" :
                this.charge === 1 ? "+" :
                    (this.charge > 1 ? "+" : "-") + Math.abs(this.charge);
    };
    MPAtom.prototype.setIndex = function (index) { this.index = index; };
    MPAtom.prototype.setCenter = function (x, y) {
        this.center.set(x, y);
        this.centerChanged();
    };
    MPAtom.prototype.setElement = function (element) {
        this.element = element === "D" ? "H" : element;
        this.labelChanged();
    };
    MPAtom.prototype.setCharge = function (charge) {
        this.charge = charge;
        this.labelChanged();
    };
    MPAtom.prototype.setIsotope = function (isotope) {
        this.isotope = isotope;
        this.labelChanged();
    };
    /**
     * Sets display type
     * @param {String} type
     */
    MPAtom.prototype.setDisplay = function (type) {
        if (type !== this.display) {
            this.display = type;
            this.mp.requestRedraw();
        }
    };
    /**
     * Checks if this MPAtom is equal to another MPAtom
     * @param  {MPAtom} atom
     * @return {Booelan}
     */
    MPAtom.prototype.equals = function (atom) {
        return this.index === atom.index;
    };
    /**
     * Returns number of selected bonds
     * @return {Integer}
     */
    MPAtom.prototype.getSelectedBonds = function () {
        var ret = 0;
        for (var i = 0; i < this.bonds.length; i++) {
            if (this.mp.mol.bonds[this.bonds[i]].isSelected()) {
                ret++;
            }
        }
        return ret;
    };
    /**
     * Checks if the given index is a neighbor atom and return connecting bond
     * @param  {Integer} idx
     * @return {Integer} Bond index or -1
     */
    MPAtom.prototype.getNeighborBond = function (idx) {
        for (var i = 0; i < this.bonds.length; i++) {
            if (this.mp.mol.bonds[this.bonds[i]].getOppositeAtom(this.index) === idx) {
                return this.bonds[i];
            }
        }
        return -1;
    };
    /**
     * Returns if this atom has any neighbor atoms which are not selected
     */
    MPAtom.prototype.hasUnselectedNeighbors = function () {
        for (var i = 0; i < this.bonds.length; i++) {
            if (!this.mp.mol.atoms[this.mp.mol.bonds[this.bonds[i]]
                .getOppositeAtom(this.index)].isSelected()) {
                return true;
            }
        }
        return false;
    };
    /**
     * Wrapper for MPAtom.selected (for maintainability)
     */
    MPAtom.prototype.isSelected = function () {
        return this.selected;
    };
    /**
     * Finds this MPAtom if it is an implicit hydrogen atom
     * All H atoms bonded to a C atom without stereo information are considered implicit
     * @return {Boolean}    Indicates if this atom is implicit
     */
    MPAtom.prototype.isImplicit = function () {
        if (this.element === "H" && this.isotope === 0 &&
            this.charge === 0 && this.bonds.length === 1) {
            var bond = this.mp.mol.bonds[this.bonds[0]];
            if (bond.type === MPBondType.SINGLE && bond.stereo === MPStereoType.NONE &&
                bond.isPair("C", "H")) {
                return true;
            }
        }
        return false;
    };
    /**
     * Checks is this MPAtom is hidden (not the same as invisible)
     */
    MPAtom.prototype.isHidden = function () {
        return this.display === "hidden";
    };
    /**
     * Checks if this MPAtom is visible in the drawing based on MolPad display settings
     */
    MPAtom.prototype.isVisible = function () {
        return this.wasVisible === true;
    };
    /**
     * Selects or deselects this MPAtom
     * @param {Boolean} select
     */
    MPAtom.prototype.select = function (select) {
        if (this.isSelected() !== select) {
            this.selected = select;
            this.mp.sel.update();
            this.mp.requestRedraw();
        }
    };
    /**
     * MPPoint.translate wrapper of atom center point
     */
    MPAtom.prototype.translate = function (dx, dy) {
        if (Math.abs(dx) + Math.abs(dy) > 0) {
            this.center.translate(dx, dy);
            this.centerChanged();
        }
    };
    /**
     * MPPoint.mirror wrapper of atom center point
     */
    MPAtom.prototype.mirror = function (line, s) {
        if (this.center.mirror(line, s)) {
            this.centerChanged();
        }
    };
    /**
     * MPPoint.rotateAroundCenter wrapper of atom center point
     */
    MPAtom.prototype.rotateAroundCenter = function (c, a) {
        this.center.rotateAroundCenter(c, a);
        this.centerChanged();
    };
    /**
     * Returns total bond count
     */
    MPAtom.prototype.getBondCount = function () {
        var ret = 0;
        for (var i = 0; i < this.bonds.length; i++) {
            ret += this.mp.mol.bonds[this.bonds[i]].type;
        }
        return ret;
    };
    /**
     * Add bond index to this atom
     * @param {Integer} bond Bond index
     */
    MPAtom.prototype.addBond = function (bond) {
        if (this.bonds.indexOf(bond) === -1) {
            this.bonds.push(bond);
            this.bondsChanged();
        }
    };
    /**
     * Remove bond index from this atom
     * @param {Integer} bond Bond index
     */
    MPAtom.prototype.removeBond = function (bond) {
        var i = this.bonds.indexOf(bond);
        if (i !== -1) {
            this.bonds.splice(i, 1);
            this.bondsChanged();
        }
    };
    /**
     * Map bond indices using an index map
     * The map should contain the new indexes as follows: map[old] = new
     * If map[old] === undefined, the old index is removed from the bonds list
     *
     * @param {Array}   map
     */
    MPAtom.prototype.mapBonds = function (map) {
        var length = this.bonds.length;
        this.bonds = mapArray(this.bonds, map);
        if (this.bonds.length !== length) {
            this.bondsChanged();
        }
        /* CAUTION: this.invalidate should not be triggerd since it might
        hurt the mapping process */
    };
    /**
     * Replace a given bond index with another bond index
     * @param {Integer} o Old bond index
     * @param {Integer} n New bond index
     */
    MPAtom.prototype.replaceBond = function (o, n) {
        var idx = this.bonds.indexOf(o);
        var nidx = this.bonds.indexOf(n);
        if (idx !== -1) {
            if (nidx !== -1)
                this.bonds.splice(o, 1);
            else
                this.bonds[idx] = n;
        }
        this.bondsChanged();
    };
    /**
     * Adds new bond to this atom using the given element and angle
     * Does not redraw the canvas
     * @param  {Object} config { element, a, type, stereo }
     * @return {Object}        Tool data for this bond
     */
    MPAtom.prototype.addNewBond = function (config) {
        var atom = new MPAtom(this.mp, {
            i: this.mp.mol.atoms.length,
            x: this.getX() + (config.length || this.mp.s.bond.length) * Math.cos(config.a),
            y: this.getY() - (config.length || this.mp.s.bond.length) * Math.sin(config.a),
            element: config.element || "C"
        });
        var bond = new MPBond(this.mp, {
            i: this.mp.mol.bonds.length,
            type: config.type || MPBondType.SINGLE,
            stereo: config.stereo || MPStereoType.NONE,
            from: this.index,
            to: atom.index
        });
        this.mp.mol.atoms.push(atom);
        this.mp.mol.bonds.push(bond);
        atom.addBond(bond.index);
        this.addBond(bond.index);
        return {
            atom: atom.index,
            bond: bond.index,
            startAngle: config.a,
            currentAngle: config.a
        };
    };
    /**
     * Saturate atom with hydrogens
     * C atoms are saturated using their four binding sites
     */
    MPAtom.prototype.addImplicitHydrogen = function () {
        if (this.element === "C") {
            if (this.getBondCount() === 2 && this.bonds.length === 2) {
                var af = this.mp.mol.bonds[this.bonds[0]].getAngle(this);
                var at = this.mp.mol.bonds[this.bonds[1]].getAngle(this);
                var da = Math.max(af, at) - Math.min(af, at);
                //do only display 2 Hydrogens on one side if the bonds are not straight
                if (indev(da, Math.PI, this.mp.s.bond.angleDev)) {
                    var a = this.calculateNewBondAngle(2);
                    if (a === 0)
                        return;
                    this.addNewBond({
                        a: a[0],
                        length: this.mp.s.bond.lengthHydrogen,
                        element: "H"
                    });
                    this.addNewBond({
                        a: a[1],
                        length: this.mp.s.bond.lengthHydrogen,
                        element: "H"
                    });
                    return;
                }
            }
            while (this.getBondCount() < 4) {
                this.cmap = this.calculateConnectionMap();
                var a = this.calculateNewBondAngle();
                this.addNewBond({
                    a: a,
                    length: this.mp.s.bond.lengthHydrogen,
                    element: "H"
                });
            }
        }
    };
    /**
     * Invalidate cached render data
     */
    MPAtom.prototype.invalidate = function () {
        this.valid = false;
        this.mp.requestRedraw();
    };
    /**
     * Invalidation helper called when MPAtom.center has changed
     */
    MPAtom.prototype.centerChanged = function () {
        this.invalidate();
        for (var i = 0; i < this.bonds.length; i++) {
            this.mp.mol.bonds[this.bonds[i]].invalidate();
            this.mp.mol.atoms[this.mp.mol.bonds[this.bonds[i]].getOppositeAtom(this.index)].bondsChanged(true);
        }
        this.cmap = this.calculateConnectionMap();
    };
    /**
     * Invalidation helper called when MPAtom label has changed
     */
    MPAtom.prototype.labelChanged = function () {
        this.invalidate();
        this.line = undefined;
        for (var i = 0; i < this.bonds.length; i++) {
            this.mp.mol.bonds[this.bonds[i]].invalidate();
            this.mp.mol.atoms[this.mp.mol.bonds[this.bonds[i]].getOppositeAtom(this.index)].bondsChanged();
        }
    };
    /**
     * Invalidation helper called when connected bonds are changed
     */
    MPAtom.prototype.bondsChanged = function (moved) {
        if (moved === void 0) { moved = undefined; }
        this.invalidate();
        if (this.mp.s.skeletalDisplay) {
            for (var i = 0; i < this.bonds.length; i++) {
                this.mp.mol.bonds[this.bonds[i]].invalidate();
            }
        }
    };
    /**
     * Validate this MPAtom by updating all its drawing data
     */
    MPAtom.prototype.validate = function () {
        if (this.valid)
            return;
        this.valid = true;
        this.wasVisible = this.calculateVisibility();
        this.cmap = this.calculateConnectionMap();
        /* IMPORTANT NOTE: you have to invalidate the MPAtom AND make its
        line object undefined in order to recalculate it. This is a trick
        to increase efficiency as the atom label line does not have to be
        recalculated after each invalidation */
        if (this.line === undefined)
            this.line = this.calculateCenterLine();
    };
    /**
     * Render methods
     */
    /**
     * Draw additional MPAtom background based on MPAtom.display
     */
    MPAtom.prototype.drawStateColor = function () {
        if (this.isHidden() || this.line === undefined)
            return;
        var incorrect = false; //this.element == "C" && this.getBondCount() > 4;
        /* incorrect is currently not really working since the red is sometimes
        draw between other green selection areas and because the invalidation is not
        working correctly when adding fragments which are not yet collapsed */
        if (this.display === "hover" || this.display === "active" ||
            (this.display === "normal" && this.isSelected()) || incorrect) {
            var d = incorrect ? "incorrect" : (this.isSelected() ? "selected" : this.display);
            this.mp.ctx.beginPath();
            if (this.line.area.point) {
                this.mp.ctx.arc(this.center.x, this.center.y, this.mp.s.atom.selectionRadiusScaled, 0, PI2);
                this.mp.ctx.fillStyle = this.mp.s.atom[d].color;
                this.mp.ctx.fill();
            }
            else {
                this.mp.ctx.moveTo(this.center.x + this.line.area.left, this.center.y);
                this.mp.ctx.lineTo(this.center.x + this.line.area.right, this.center.y);
                this.mp.ctx.strokeStyle = this.mp.s.atom[d].color;
                this.mp.ctx.stroke();
            }
        }
    };
    /**
     * Draw actual atom label
     */
    MPAtom.prototype.drawLabel = function () {
        //TODO: add support for collapsed groups (CH2- to H2C-, OH- to HO-, etc.)
        if (this.isHidden() || this.line === undefined)
            return;
        if (this.isVisible()) {
            if (this.mp.s.atom.colored) {
                this.mp.ctx.fillStyle = JmolAtomColorsHashHex[this.element] || JmolAtomColorsHashHex["C"];
            }
            if (this.mp.s.atom.miniLabel) {
                var s = this.mp.s.atom.miniLabelSize;
                this.mp.ctx.fillRect(this.center.x - s / 2, this.center.y - s / 2, s, s);
            }
            else {
                var x = this.center.x + this.line.text.offsetLeft;
                if (this.isotope > 0) {
                    this.mp.setFont("isotope");
                    this.mp.ctx.fillText("" + this.isotope, x, this.center.y +
                        this.line.text.offsetTop - this.line.text.isotopeHeight);
                    x += this.line.text.isotopeWidth;
                }
                this.mp.setFont("element");
                this.mp.ctx.fillText("" + this.element, x, this.center.y + this.line.text.offsetTop);
                x += this.line.text.labelWidth;
                if (this.charge !== 0) {
                    this.mp.setFont("charge");
                    this.mp.ctx.fillText(this.getChargeLabel(), x, this.center.y +
                        this.line.text.offsetTop - this.line.text.chargeHeight);
                }
            }
        }
    };
    //CALC =====================================================================
    MPAtom.prototype.calculateConnectionMap = function () {
        if (this.bonds.length === 0)
            return 0;
        //create bond map with bond angles
        var bondMap = [];
        for (var i = 0; i < this.bonds.length; i++) {
            bondMap.push({
                i: this.bonds[i],
                a: this.mp.mol.bonds[this.bonds[i]].getAngle(this)
            });
        }
        //sort bondMap in ascending bond angle order
        bondMap.sort(function (a, b) {
            return a.a - b.a;
        });
        //convert bondMap to sections
        var sections = [];
        for (var i = 0; i < bondMap.length; i++) {
            var from = i === 0 ? bondMap.length - 1 : i - 1;
            var to = i;
            sections.push({
                from: from,
                to: to,
                a: angleBetween(bondMap[from].a, bondMap[to].a)
            });
        }
        return {
            bondMap: bondMap,
            sections: sections
        };
    };
    /**
     * Calculates the closest upper and lower bond for the given bond index
     * @param  {Integer} index
     * @return {Object}
     */
    MPAtom.prototype.calculateClosestBonds = function (index) {
        for (var i = 0; i < this.cmap.bondMap.length; i++) {
            if (this.cmap.bondMap[i].i === index) {
                var upper = i + 1 < this.cmap.bondMap.length ? i + 1 : 0;
                var lower = i - 1 >= 0 ? i - 1 : this.cmap.bondMap.length - 1;
                return {
                    none: false,
                    upper: this.cmap.bondMap[upper].i,
                    lower: this.cmap.bondMap[lower].i,
                    upperBisectAngle: (this.cmap.bondMap[upper].a + this.cmap.bondMap[i].a) / 2,
                    lowerBisectAngle: (this.cmap.bondMap[lower].a + this.cmap.bondMap[i].a) / 2,
                    upperSectionAngle: angleBetween(this.cmap.bondMap[i].a, this.cmap.bondMap[upper].a),
                    lowerSectionAngle: angleBetween(this.cmap.bondMap[lower].a, this.cmap.bondMap[i].a)
                };
            }
        }
        return {
            none: true,
            upper: undefined,
            lower: undefined,
            upperBisectAngle: undefined,
            lowerBisectAngle: undefined,
            upperSectionAngle: undefined,
            lowerSectionAngle: undefined
        };
    };
    /**
     * Calculated the angle for a new bond from this atom by calculating all
     * segments between existing bonds and dividing the largest segment by two
     *
     * @param  {Integer} n Optional number of new segments the larges segment
     *                     should be divided in
     * @return {Float} (if n === undefined) or {Array}
     */
    MPAtom.prototype.calculateNewBondAngle = function (n) {
        if (n === void 0) { n = undefined; }
        if (this.bonds.length === 0 || this.cmap === undefined)
            return 0;
        //find larges section
        var largest = 0; //skip i = 0 since it is already used for the first comparison
        for (var i = 1; i < this.cmap.sections.length; i++) {
            if (this.cmap.sections[i].a > this.cmap.sections[largest].a) {
                largest = i;
            }
        }
        //find new bond angle
        if (n === undefined) {
            return this.cmap.bondMap[this.cmap.sections[largest].from].a + this.cmap.sections[largest].a / 2;
        }
        else {
            var p = n !== undefined ? n + 1 : 2;
            var a = this.cmap.sections[largest].a / (n + 1);
            var ret = [];
            for (var i = 1; i <= n; i++) {
                ret.push(this.cmap.bondMap[this.cmap.sections[largest].from].a + i * a);
            }
            return ret;
        }
    };
    /**
     * Returns MPAtom area as a line with a surrounding area defined by a radius
     * (area border: d(P, line) = r) and the label drawing box outline
     *
     * @return {Object} Area line or point:
     *                  { from: { x: 0, y: 0 }} or
     *                  { from: { x: 0, y: 0 }, to: { x: 0, y: 0 } }
     *                  Label drawing box:
     *                  { offsetLeft: 0, offsetTop: 0 }
     */
    MPAtom.prototype.calculateCenterLine = function () {
        if (this.mp.s.atom.miniLabel) {
            return {
                text: { offsetLeft: 0, offsetTop: 0 },
                area: { point: true, left: undefined, right: undefined }
            };
        }
        var scale = this.mp.s.atom.scale;
        var text = {};
        this.mp.setFont("element");
        text.labelWidth = this.mp.ctx.measureText("" + this.element).width;
        var w = text.labelWidth;
        if (this.isotope > 0) {
            this.mp.setFont("isotope");
            text.isotopeHeight = this.mp.s.fonts.isotope.fontSize * scale;
            text.isotopeWidth = this.mp.ctx.measureText("" + this.isotope).width +
                this.mp.s.atom.isotope.padding * scale; //padding before element label
            w += text.isotopeWidth;
        }
        if (this.charge !== 0) {
            this.mp.setFont("charge");
            text.chargeHeight = this.mp.s.fonts.charge.fontSize * scale;
            text.chargeWidth = this.mp.ctx.measureText("" + this.getChargeLabel()).width;
            //add padding between element and charge
            text.labelWidth += this.mp.s.atom.charge.padding * scale;
            //add chargeWidth to total width + additional label padding
            w += text.chargeWidth + this.mp.s.atom.charge.padding * scale;
        }
        var h = this.mp.s.fonts.element.fontSize * scale;
        var halfw = w / 2;
        text.offsetLeft = -halfw;
        text.offsetTop = h / 2;
        if (w > this.mp.s.atom.circleClamp) {
            var pad = this.mp.s.atom.radius * scale - h / 2;
            return {
                text: text,
                area: {
                    point: false,
                    half: halfw + pad,
                    left: -halfw + pad,
                    right: halfw - pad
                }
            };
        }
        else {
            return {
                text: text,
                area: { point: true, left: undefined, right: undefined }
            };
        }
    };
    /**
     * _calculateBondVertices wrapper with origin atom index as argument
     * @param  {Integer} from Origin atom index
     * @param  {Array}   ends
     * @return {Array}        Calculated ends
     */
    MPAtom.prototype.calculateBondVertices = function (from, ends) {
        var begin = this.mp.mol.atoms[from].center;
        return this._calculateBondVertices(begin, ends);
    };
    /**
     * Calculate bond attach vertices for a bond from $begin to $this.center
     * Note that positive ends will end up at the lower side because of the
     * HTML5 canvas coordinate system
     *
     * @param  {MPPoint} begin Origin point
     * @param  {Array}   ends  Requested end vertices perpendicular to the end of line $begin$this.center
     *                         (values are in counter clockwise direction)
     * @return {Array}         Calculated ends
     */
    MPAtom.prototype._calculateBondVertices = function (begin, ends) {
        //TODO: implement bonding site for collapsed groups (only left or right)
        if (begin.x === this.center.x
            || this.hidden || this.line === undefined) {
            var ret = [];
            var r = this.isVisible() ? this.mp.s.atom.radius : 0;
            var below = begin.y < this.center.y;
            for (var i = 0; i < ends.length; i++) {
                ret.push(new MPPoint(this.center.x + (below ? ends[i] : -ends[i]), //counter clockwise
                this.center.y + (below ? -r : r)));
            }
            return ret;
        }
        else if (begin.y === this.center.y) {
            var ret = [];
            var r = this.isVisible() ? this.line.area.half || this.mp.s.atom.radius : 0;
            var right = begin.x > this.center.x;
            for (var i = 0; i < ends.length; i++) {
                ret.push(new MPPoint(this.center.x + (right ? r : -r), this.center.y + (right ? ends[i] : -ends[i]) //counter clockwise
                ));
            }
            return ret;
        }
        else if (!this.isVisible()) {
            if (ends.length === 1 && ends[0] === 0) {
                return [new MPPoint(this.center.x, this.center.y)];
            }
            else {
                var dx = begin.x - this.center.x;
                var dy = begin.y - this.center.y;
                var d = Math.sqrt(dx * dx + dy * dy);
                var A = dx / d; //dx = a = A * c = d
                var B = dy / d; //dy = b = B * c = d
                var ret = [];
                for (var i = 0; i < ends.length; i++) {
                    ret.push(new MPPoint(-B * ends[i], A * ends[i]));
                }
                //translate to real center
                for (var i = 0; i < ret.length; i++) {
                    ret[i].x += this.center.x;
                    ret[i].y += this.center.y;
                }
                return ret;
            }
        }
        else {
            var ac = this.center; //aligin center
            var bc = this.center; //bond center
            var tdir = 1; //tangent direction
            if (this.line.area.left && begin.x < this.center.x) {
                ac = new MPPoint(this.center.x + this.line.area.left, this.center.y);
            }
            else if (this.line.area.right && begin.x > this.center.x) {
                ac = new MPPoint(this.center.x + this.line.area.right, this.center.y);
                tdir = -1;
            }
            var acbc = Math.abs(ac.x - bc.x); //distance between align center and bond center
            var r = this.mp.s.atom.radius;
            var dx = begin.x - bc.x;
            var dy = begin.y - bc.y;
            var d = Math.sqrt(dx * dx + dy * dy);
            var A = dx / d; //dx = a = A * c = d
            var B = dy / d; //dy = b = B * c = d
            //alignCenter tangent crossing with bond line
            var td = (tdir > 0 ? r - A * acbc : r + A * acbc);
            var tx = A * td;
            var ty = B * td;
            var x = bc.x + tx;
            var y = bc.y + ty;
            var ret = [];
            for (var i = 0; i < ends.length; i++) {
                ret.push(new MPPoint(x - B * ends[i], y + A * ends[i]));
            }
            return ret;
        }
    };
    MPAtom.prototype.calculateVisibility = function () {
        if (this.isHidden()) {
            return false;
        }
        else if (this.mp.s.skeletalDisplay) {
            if (this.element === "C" && this.charge === 0 && this.isotope === 0) {
                if (this.bonds.length === 0) {
                    return true;
                }
                else {
                    if (this.bonds.length === 2
                        && this.mp.mol.bonds[this.bonds[0]].type === this.mp.mol.bonds[this.bonds[1]].type
                        && this.mp.mol.bonds[this.bonds[0]].stereo === this.mp.mol.bonds[this.bonds[1]].stereo) {
                        var af = this.mp.mol.bonds[this.bonds[0]].getAngle(this);
                        var at = this.mp.mol.bonds[this.bonds[1]].getAngle(this);
                        var da = Math.max(af, at) - Math.min(af, at);
                        //display atom anyway if the bonds are straight
                        if (indev(da, Math.PI, this.mp.s.bond.angleDev)) {
                            return true;
                        }
                        else
                            return false;
                    }
                    else
                        return false;
                }
            }
            return true;
        }
        else
            return true;
    };
    // HANDLE ======================================================================
    MPAtom.prototype.getHandler = function () {
        //TODO: calculateNewBondAngle use lone-pairs and valence
        if (this.mp.tool.type === "atom") {
            return {
                scope: this,
                data: {},
                onPointerDown: function (e, mp) {
                    this.data = {
                        atom: -1,
                        oldElement: this.scope.element
                    };
                    this.scope.setElement(mp.tool.data.element);
                },
                onPointerMove: function (e, mp) {
                    var p = new MPPoint().fromRelativePointer(e, mp);
                    //check if pointer is outside no-rotate circle
                    if (!p.inCircle(this.scope.center, mp.s.atom.minAddRotateLength)) {
                        //create target atom if no target atom has been created yet
                        if (this.data.atom === -1) {
                            this.scope.setElement(this.data.oldElement);
                            this.data.startAngle = this.scope.calculateNewBondAngle();
                            this.data = this.scope.addNewBond({
                                a: this.data.startAngle,
                                type: mp.tool.data.type || MPBondType.SINGLE,
                                stereo: mp.tool.data.stereo || MPStereoType.NONE,
                                element: mp.tool.data.element
                            });
                        }
                        //rotate the target atom around this atom
                        this.data.currentAngle = mp.mol.rotateAtoms(this.scope.center, p, [this.data.atom], this.data.currentAngle, this.data.startAngle, mp.s.rotateSteps);
                    }
                },
                onPointerUp: function (e, mp) {
                    if (this.data.atom !== -1) {
                        mp.mol.collapseAtoms([this.data.atom], true);
                    }
                }
            };
        }
        else if (this.mp.tool.type === "bond") {
            return {
                scope: this,
                data: {},
                onPointerDown: function (e, mp) {
                    var a = this.scope.calculateNewBondAngle();
                    this.data = this.scope.addNewBond({
                        a: a,
                        type: mp.tool.data.type || MPBondType.SINGLE,
                        stereo: mp.tool.data.stereo || MPStereoType.NONE,
                        element: mp.tool.data.element
                    });
                },
                onPointerMove: function (e, mp) {
                    var p = new MPPoint().fromRelativePointer(e, mp);
                    var bond = mp.mol.bonds[this.data.bond];
                    //check for hovered secondary atoms
                    for (var i = 0; i < mp.mol.atoms.length; i++) {
                        //this atom and the new atom do not participate
                        if (i === this.scope.index || i === this.data.atom)
                            continue;
                        //check for hover using active as event type
                        if (mp.mol.atoms[i].handle(p, "active")) {
                            //skip if the hovered atom is already the target atom
                            if (bond.to !== i) {
                                //reset old target atom to normal display
                                //(for the almost impossible case MPAtom.handle is not reached yet)
                                mp.mol.atoms[bond.to].setDisplay("normal");
                                mp.mol.atoms[bond.to].removeBond(bond.index);
                                //hide newly created target atom
                                mp.mol.atoms[this.data.atom].setDisplay("hidden");
                                //set target atom to new atom
                                bond.setTo(i);
                                //invalidate new atom
                                mp.mol.atoms[i].addBond(bond.index);
                                //check if new target atom is a neighbor of this atom
                                var n = this.scope.getNeighborBond(i);
                                if (n !== -1 && n !== this.data.bond) {
                                    //if so, check if we handled this neighbor before
                                    if (n !== this.data.neighbor) {
                                        //if not, save the neighbor bond index
                                        this.data.neighbor = n;
                                        //and hide the neighbor bond
                                        //(in order to replace it with this bond)
                                        mp.mol.bonds[n].setDisplay("hidden");
                                    }
                                }
                                else {
                                    //check if there is a neighbor bond we handled before
                                    if (this.data.neighbor !== undefined) {
                                        //if so, show this bond again and remove it from this.data
                                        mp.mol.bonds[this.data.neighbor].setDisplay("normal");
                                        this.data.neighbor = undefined;
                                    }
                                }
                            }
                            //return so the next blocks of code are not reached
                            return;
                        }
                    }
                    //no hovered secondary atom so reset bond.to to this.data.atom
                    if (bond.to !== this.data.atom) {
                        //reshow newly created atom, this wil also invalidate the new bond
                        mp.mol.atoms[this.data.atom].setDisplay("normal");
                        //check if there is a neighbor bond we handled before
                        if (this.data.neighbor !== undefined) {
                            //if so, reshow this bond again and remove it from this.data
                            mp.mol.bonds[this.data.neighbor].setDisplay("normal");
                            this.data.neighbor = undefined;
                        }
                        //reset target atom
                        mp.mol.atoms[bond.to].removeBond(bond.index);
                        mp.mol.atoms[this.data.atom].addBond(bond.index);
                        bond.setTo(this.data.atom);
                    }
                    //check if pointer is outside no-rotate circle
                    if (!p.inCircle(this.scope.center, mp.s.atom.minAddRotateLength)) {
                        //if so, rotate the target atom around this atom
                        this.data.currentAngle = mp.mol.rotateAtoms(this.scope.center, p, [this.data.atom], this.data.currentAngle, this.data.startAngle, mp.s.rotateSteps);
                    }
                },
                onPointerUp: function (e, mp) {
                    //get final target atom
                    var to = mp.mol.bonds[this.data.bond].to;
                    //check if final target atom is the newly created one
                    if (to !== this.data.atom) {
                        //if not, add the newly created bond to the real target atom
                        mp.mol.atoms[to].addBond(this.data.bond);
                        mp.mol.atoms.pop(); //and pop the last atom (old target)
                        //if final target is connected via an old neighbor bond
                        if (this.data.neighbor !== undefined) {
                            //then remove the old neighbor
                            mp.mol.bonds.splice(this.data.neighbor, 1);
                            mp.mol.updateIndices();
                        }
                    }
                    else {
                        mp.mol.collapseAtoms([to], true);
                    }
                }
            };
        }
        else if (this.mp.tool.type === "fragment") {
            return {
                scope: this,
                data: {},
                onPointerDown: function (e, mp) {
                    //determine if the fragment will be connected using a bond
                    var bondConnection = this.scope.getBondCount() > 2 && this.scope.element === "C";
                    //clone new fragment and transform it
                    this.data = {
                        frag: MPFragments.translate(MPFragments.scale(MPFragments.translate(MPFragments.clone(mp.tool.data.frag.toAtom), bondConnection ? 1 : 0, 0), mp.s.bond.length), this.scope.center.x, this.scope.center.y)
                    };
                    //make sure the selection is cleared
                    mp.sel.clear();
                    //setup selection parameters
                    mp.sel.currentAngle = mp.sel.startAngle =
                        this.scope.calculateNewBondAngle();
                    mp.sel.center = this.scope.center.clone();
                    //rotate new fragment using .sel.centerthe currentAngle
                    MPFragments.rotate(this.data.frag, this.scope.center, mp.sel.currentAngle);
                    //create and select the fragment and store the new fragment data
                    var frag = mp.mol.createFragment(this.data.frag, true);
                    if (bondConnection) {
                        var connection = new MPBond(mp, {
                            i: mp.mol.bonds.length,
                            type: MPBondType.SINGLE,
                            stereo: MPStereoType.NONE,
                            from: this.scope.index,
                            to: frag.atoms[0],
                            selected: true
                        });
                        mp.mol.bonds.push(connection);
                        mp.mol.atoms[connection.to].addBond(connection.index);
                        this.scope.addBond(connection.index);
                        this.scope.select(true);
                    }
                    else {
                        mp.mol.mergeAtoms(frag.atoms[0], this.scope.index);
                    }
                },
                onPointerMove: function (e, mp) {
                    var p = new MPPoint().fromRelativePointer(e, mp);
                    //check if pointer is outside no-rotate circle
                    if (!p.inCircle(this.scope.center, mp.s.atom.minAddRotateLength)) {
                        //if so, rotate the selection (fragment) around this atom
                        mp.sel.rotate(p);
                    }
                },
                onPointerUp: function (e, mp) {
                    mp.sel.collapse();
                    mp.sel.clear();
                }
            };
        }
        else if (this.mp.tool.type === "charge") {
            return {
                scope: this,
                onPointerDown: function (e, mp) {
                    this.scope.setCharge(this.scope.charge + mp.tool.data.charge);
                }
            };
        }
        else if (this.mp.tool.type === "chain") {
            return {
                scope: this,
                data: {
                    startAngle: 0,
                    length: this.mp.s.bond.length * Math.cos(this.mp.s.chain.devAngle),
                    chain: [],
                    ra: undefined //repel angle
                },
                onDraw: function (mp) {
                    //draw chain
                    mp.ctx.strokeStyle = mp.s.chain.strokeStyle;
                    mp.ctx.lineWidth = mp.s.bond.width * mp.s.bond.scale;
                    mp.ctx.lineCap = mp.s.chain.lineCap;
                    mp.ctx.lineJoin = mp.s.chain.lineJoin;
                    mp.ctx.setLineDash([
                        2 * mp.s.bond.scale,
                        5 * mp.s.bond.scale
                    ]);
                    mp.ctx.beginPath();
                    for (var i = 0; i < this.data.chain.length; i++) {
                        if (i === 0)
                            mp.ctx.moveTo(this.data.chain[i].x, this.data.chain[i].y);
                        else
                            mp.ctx.lineTo(this.data.chain[i].x, this.data.chain[i].y);
                    }
                    mp.ctx.stroke();
                    //draw chain size
                    if (this.data.chain.length > 0) {
                        mp.setFont("chainSize");
                        mp.ctx.fillStyle = mp.s.chain.color;
                        //calculate label dimensions
                        var text = "" + this.data.size;
                        var w = mp.ctx.measureText(text).width;
                        var h = mp.s.atom.scale * mp.s.fonts.chainSize.fontSize;
                        //calculate label center
                        var lblc = this.data.chain[this.data.chain.length - 1].clone(); //label center
                        var r = mp.s.atom.scale * mp.s.chain.padding + (w > h ? w : h); //radius from last carbon atom to size label center
                        lblc.x += r * Math.cos(this.data.a);
                        lblc.y += r * Math.sin(-this.data.a); //flip y-axis
                        lblc.x -= w / 2;
                        lblc.y += h / 2;
                        mp.ctx.fillText(text, lblc.x, lblc.y);
                    }
                },
                onPointerDown: function (e, mp) {
                    //calculate new startAngle
                    this.data.startAngle = this.scope.calculateNewBondAngle();
                    //calculate starting deviation side
                    if (this.scope.bonds.length === 1) {
                        //rotate angle of bond to the opposite side
                        this.data.ra = posRad(mp.mol.bonds[this.scope.bonds[0]].getAngle(this.scope) + Math.PI);
                    }
                    else if (this.scope.bonds.length === 2) {
                        //rotate new bond angle to opposite side to achieve reversed effect
                        //(the chain will stick to the new bond angle)
                        this.data.ra = posRad(this.scope.calculateNewBondAngle() + Math.PI);
                    }
                    else {
                        this.data.ra = undefined;
                    }
                },
                onPointerMove: function (e, mp) {
                    var p = new MPPoint().fromRelativePointer(e, mp);
                    //calculate new angle
                    var a = clampedAngle(this.data.startAngle, this.scope.center, p, mp.s.chain.rotateSteps);
                    //calculate new size
                    var size = Math.floor(this.scope.center.distanceTo(p) /
                        this.data.length);
                    if (a !== this.data.a || size !== this.data.size) {
                        this.data.a = a;
                        this.data.size = size;
                        //calculate deviation side
                        var ds = this.data.a > -Math.PI / 2 && this.data.a < Math.PI / 2 ? 1 : -1;
                        var da = this.data.a + ds * mp.s.chain.devAngle;
                        if (this.data.ra !== undefined) {
                            //copmare alternative and replace current angle with alternative angle
                            var da_alt = this.data.a - ds * mp.s.chain.devAngle;
                            if (smallestAngleBetween(da, this.data.ra) <
                                smallestAngleBetween(da_alt, this.data.ra)) {
                                da = da_alt;
                            }
                        }
                        //calculate chain vertices
                        var ax = this.data.length * Math.cos(this.data.a);
                        var ay = this.data.length * Math.sin(-this.data.a); //flipped y-axis
                        var bx = mp.s.bond.length * Math.cos(da);
                        var by = mp.s.bond.length * Math.sin(-da);
                        this.data.chain = [];
                        var c = this.scope.center.clone();
                        for (var i = 0; i < this.data.size; i++) {
                            if (i % 2 === 0) {
                                this.data.chain.push(new MPPoint(c.x + bx, c.y + by));
                            }
                            else {
                                c.x += 2 * ax;
                                c.y += 2 * ay;
                                this.data.chain.push(c.clone());
                            }
                        }
                        //calculate begin vertex (for drawing purposes)
                        if (this.data.chain.length > 0) {
                            this.data.chain.unshift(this.scope._calculateBondVertices(this.data.chain[0], [0])[0]);
                        }
                        mp.requestRedraw();
                    }
                },
                onPointerUp: function (e, mp) {
                    //create chain, skip first vertex
                    var catom = this.scope; //connect atom
                    var chainIndices = []; //store new atom indices to collapse chain
                    for (var i = 1; i < this.data.chain.length; i++) {
                        var atom = new MPAtom(mp, {
                            i: mp.mol.atoms.length,
                            x: this.data.chain[i].x,
                            y: this.data.chain[i].y,
                            element: "C"
                        });
                        mp.mol.atoms.push(atom);
                        chainIndices.push(atom.index);
                        var bond = new MPBond(mp, {
                            i: mp.mol.bonds.length,
                            from: catom.index,
                            to: atom.index,
                            type: MPBondType.SINGLE
                        });
                        mp.mol.bonds.push(bond);
                        catom.addBond(bond.index);
                        atom.addBond(bond.index);
                        catom = atom;
                    }
                    //collapse chain
                    mp.mol.collapseAtoms(chainIndices, true);
                }
            };
        }
        else if (this.mp.tool.type === "erase") {
            return {
                scope: this,
                onPointerDown: function (e, mp) {
                    if (this.scope.isSelected())
                        mp.sel.remove();
                    else
                        mp.mol.removeAtom(this.scope.index, true);
                    //dismiss all further calls to this handler
                    mp.pointer.handler = undefined;
                }
            };
        }
        else {
            return {
                scope: this,
                data: {},
                onPointerDown: function (e, mp) {
                    var p = new MPPoint().fromRelativePointer(e, mp);
                    if (mp.sel.hasCenter()) {
                        mp.sel.startAngle =
                            mp.sel.currentAngle =
                                mp.sel.center.angleTo(p);
                    }
                },
                onPointerMove: function (e, mp) {
                    mp.setCursor("move");
                    var p = new MPPoint().fromRelativePointer(e, mp);
                    var dx = p.x - mp.pointer.old.r.x;
                    var dy = p.y - mp.pointer.old.r.y;
                    if (Math.sqrt(dx * dx + dy * dy) > mp.s.draggingThreshold || this.data.moved) {
                        this.data.moved = true;
                        if (this.scope.isSelected()) {
                            if (!mp.sel.hasCenter() || mp.sel.centerAtom === this.scope.index) {
                                mp.sel.translate(dx, dy);
                            }
                            else {
                                mp.sel.rotate(p);
                            }
                        }
                        else {
                            this.scope.translate(p.x - mp.pointer.old.r.x, p.y - mp.pointer.old.r.y);
                        }
                        mp.pointer.old.r = p;
                    }
                },
                onPointerUp: function (e, mp) {
                    if (!this.data.moved && oneOf(mp.tool.type, ["select", "drag"])) {
                        this.scope.select(!this.scope.isSelected());
                        mp.sel.updateRotationCenter();
                    }
                    else {
                        if (this.scope.isSelected())
                            mp.sel.collapse();
                        else
                            mp.mol.collapseAtoms([this.scope.index], true);
                        /* process possible changes to
                        rotation center caused by collapsing */
                        mp.sel.updateRotationCenter();
                    }
                }
            };
        }
    };
    /**
     * Handler for mouse events
     * @param  {MPPoint} point Event origin
     * @param  {String}  type  Event type (hover || active)
     * @return {Boolean}       Indicates if event is handled by this MPAtom
     */
    MPAtom.prototype.handle = function (point, type) {
        if (this.line === undefined)
            return false;
        var r = this.mp.s.atom.selectionRadiusScaled;
        if (this.line.area.point) {
            if (point.inCircleBox(this.center, r)) {
                if (point.inCircle(this.center, r)) {
                    this.setDisplay(type);
                    return true;
                }
            }
        }
        else {
            var lp = new MPPoint(this.center.x + this.line.area.left, this.center.y);
            var rp = new MPPoint(this.center.x + this.line.area.right, this.center.y);
            if (point.inLineBox(lp, rp, r)) {
                if (point.lineDistance(lp, rp) <= r) {
                    this.setDisplay(type);
                    return true;
                }
            }
        }
        this.setDisplay("normal");
        return false;
    };
    MPAtom.prototype.handleRectSelect = function (rect) {
        this.select(this.center.inRect(rect));
    };
    MPAtom.prototype.handlePolygonSelect = function (polygon) {
        this.select(this.center.inPolygon(polygon));
    };
    return MPAtom;
}());
/**
 * This file is part of MolView (http://molview.org)
 * Copyright (c) 2014, 2015 Herman Bergwerf
 *
 * MolView is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MolView is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with MolView.  If not, see <http://www.gnu.org/licenses/>.
 */
var MPBondType;
(function (MPBondType) {
    MPBondType[MPBondType["SINGLE"] = 1] = "SINGLE";
    MPBondType[MPBondType["DOUBLE"] = 2] = "DOUBLE";
    MPBondType[MPBondType["TRIPLE"] = 3] = "TRIPLE";
    MPBondType[MPBondType["WEDGEHASH"] = 4] = "WEDGEHASH";
    MPBondType[MPBondType["CIS"] = 5] = "CIS";
})(MPBondType || (MPBondType = {}));
var MPStereoType;
(function (MPStereoType) {
    MPStereoType[MPStereoType["NONE"] = 0] = "NONE";
    MPStereoType[MPStereoType["UP"] = 1] = "UP";
    MPStereoType[MPStereoType["DOWN"] = 6] = "DOWN";
    MPStereoType[MPStereoType["CIS_TRANS"] = 3] = "CIS_TRANS";
    MPStereoType[MPStereoType["EITHER"] = 4] = "EITHER";
})(MPStereoType || (MPStereoType = {}));
var MPBond = (function () {
    /**
     * Create new MPBond
     * @param {MolPad} mp
     * @param {Object} obj Configuration
     */
    function MPBond(mp, obj) {
        this.mp = mp;
        this.index = obj.i;
        this.type = obj.type || 0;
        this.stereo = obj.stereo || MPStereoType.NONE;
        this.from = obj.from || 0;
        this.to = obj.to || 0;
        this.selected = obj.selected || false;
        this.display = "normal";
        this.hidden = false; //used internally to hide inverted bonds
        this.valid = false;
        this.mp.requestRedraw();
    }
    //TODO
    //    /**
    //     * Retruns data which can be used as input by the Ketcher fork
    //     * @param {Object} mp
    //     * @return {Object}
    //     */
    //    getKetcherData()
    //    {
    //        return new chem.Struct.Bond({
    //            type: this.type,
    //            stereo: this.stereo,
    //            begin: this.from,
    //            end: this.to
    //        });
    //    }
    //    
    /**
     * Retruns config data which can be used to reconstruct this object
     * @return {Object}
     */
    MPBond.prototype.getConfig = function () {
        return {
            i: this.index,
            type: this.type,
            stereo: this.stereo,
            from: this.from,
            to: this.to
        };
    };
    /**
     * Retruns MPBond string which can be compared to other MPBond strings
     * @return {String}
     */
    MPBond.prototype.toString = function () {
        throw new Error("Not implemented, TODO");
        //        return this.type.toString()
        //            + this.stereo.toString()
        //            + this.to - this.from;//store up/down bond direction
    };
    MPBond.prototype.getLine = function () {
        return new MPLine({
            from: this.mp.mol.atoms[this.from].center,
            to: this.mp.mol.atoms[this.to].center
        });
    };
    /**
     * Returns the from.angleTo(to)
     * @param  {Integer} from From atom
     * @return {Float}
     */
    MPBond.prototype.getAngle = function (from) {
        if (this.mp.mol.atoms[this.from].equals(from)) {
            return this.mp.mol.atoms[this.from].center.angleTo(this.mp.mol.atoms[this.to].center);
        }
        else {
            return this.mp.mol.atoms[this.to].center.angleTo(this.mp.mol.atoms[this.from].center);
        }
    };
    MPBond.prototype.setIndex = function (index) { this.index = index; };
    MPBond.prototype.setType = function (type) {
        this.type = type;
        this.changed();
    };
    MPBond.prototype.setStereo = function (stereo) {
        this.stereo = stereo;
        this.changed();
    };
    MPBond.prototype.setFrom = function (from) {
        this.from = from;
        this.changed();
    };
    MPBond.prototype.setTo = function (to) {
        this.to = to;
        this.changed();
    };
    /**
     * Sets display type
     * @param {String} type
     */
    MPBond.prototype.setDisplay = function (type) {
        if (type !== this.display) {
            this.display = type;
            this.mp.requestRedraw();
        }
    };
    /**
     * Replace a given atom with another atom
     * @param {Integer} i Atom index
     * @param {Integer} n New atom index
     */
    MPBond.prototype.replaceAtom = function (i, n) {
        if (this.from === i && this.to !== n)
            this.from = n;
        else if (this.to === i && this.from !== n)
            this.to = n;
        this.changed();
    };
    /**
     * Compares all properties of this bond with a plain MPBond configuration object
     * @param  {Object} config
     * @return {Boolean}
     */
    MPBond.prototype.compare = function (config) {
        return config.i === this.index
            && config.type === this.type
            && config.stereo === this.stereo
            && config.from === this.from
            && config.to === this.to;
    };
    /**
     * Checks if this MPBond is equal to another MPBond
     * @param  {MPBond} bond
     * @return {Booelan}
     */
    MPBond.prototype.equals = function (bond) {
        return bond.from === this.from && bond.to === this.to;
    };
    /**
     * Wrapper for MPBond.selected (for maintainability)
     */
    MPBond.prototype.isSelected = function () {
        return this.selected;
    };
    /**
     * Checks is this MPBond is hidden (not the same as invisible)
     */
    MPBond.prototype.isHidden = function () {
        return this.display === "hidden" || this.hidden;
    };
    /**
     * Checks if this bond is a pair of the given elements
     * @param  {String} a
     * @param  {String} b
     * @return {Booelan}
     */
    MPBond.prototype.isPair = function (a, b) {
        var _a = this.mp.mol.atoms[this.from].element;
        var _b = this.mp.mol.atoms[this.to].element;
        return _a === a && _b === b || _a === b && _b === a;
    };
    /**
     * Checks if this bond is bonded to the given MPAtom.index
     * @param  {Integer} i
     * @return {Booelan}
     */
    MPBond.prototype.hasAtom = function (i) {
        return this.from === i || this.to === i;
    };
    /**
     * Get the atom index of the atom on the other side of the given MPAtom.index
     * @param  {Integer} i
     * @return {Integer}
     */
    MPBond.prototype.getOppositeAtom = function (i) {
        return this.from === i ? this.to : this.from;
    };
    /**
     * Selects or deselects this MPBond
     * @param {Boolean} select
     */
    MPBond.prototype.select = function (select) {
        if (this.isSelected() !== select) {
            this.selected = select;
            this.mp.sel.update();
            this.mp.requestRedraw();
        }
    };
    /**
     * Invalidate this bond
     */
    MPBond.prototype.invalidate = function () {
        this.valid = false;
        this.mp.requestRedraw();
    };
    /**
     * Invalidation helper called when bond is changed
     */
    MPBond.prototype.changed = function () {
        this.invalidate();
        this.mp.mol.atoms[this.from].bondsChanged();
        this.mp.mol.atoms[this.to].bondsChanged();
    };
    /**
     * Render methods
     */
    MPBond.prototype.drawStateColor = function () {
        if (this.isHidden() || this.line === undefined)
            return;
        if (this.display === "hover" || this.display === "active" ||
            (this.display === "normal" && this.isSelected())) {
            var d = this.isSelected() ? "selected" : this.display;
            this.mp.ctx.beginPath();
            var f = this.line.from;
            var t = this.line.to;
            //stick to 'from' atom center if 'from' atom is selected (multi-select)
            if (this.mp.mol.atoms[this.from].isSelected()) {
                f = this.mp.mol.atoms[this.from].center;
            }
            //stick to 'to' atom center if 'to' atom is selected (multi-select)
            if (this.mp.mol.atoms[this.to].isSelected()) {
                t = this.mp.mol.atoms[this.to].center;
            }
            this.mp.ctx.moveTo(f.x, f.y);
            this.mp.ctx.lineTo(t.x, t.y);
            this.mp.ctx.strokeStyle = this.mp.s.bond[d].color;
            this.mp.ctx.stroke();
        }
    };
    MPBond.prototype.drawBond = function () {
        if (this.isHidden() || this.line === undefined)
            return;
        var scale = this.mp.s.bond.scale;
        var ctx = this.mp.ctx;
        if (this.mp.s.bond.colored && !this.mp.s.atom.miniLabel) {
            ctx.strokeStyle = this.cache.bondColor;
            if (this.stereo === MPStereoType.UP)
                ctx.fillStyle = this.cache.bondColor;
        }
        if (this.mp.getScale() < this.mp.s.bond.singleOnlyScale) {
            ctx.beginPath();
            ctx.moveTo(this.line.from.x, this.line.from.y);
            ctx.lineTo(this.line.to.x, this.line.to.y);
            ctx.stroke();
        }
        else if (this.stereo === MPStereoType.CIS_TRANS && this.type === MPBondType.DOUBLE) {
            ctx.beginPath();
            ctx.moveTo(this.cache.ctd.from[0].x, this.cache.ctd.from[0].y);
            ctx.lineTo(this.cache.ctd.to[0].x, this.cache.ctd.to[0].y);
            ctx.moveTo(this.cache.ctd.from[1].x, this.cache.ctd.from[1].y);
            ctx.lineTo(this.cache.ctd.to[1].x, this.cache.ctd.to[1].y);
            ctx.stroke();
        }
        else if (this.stereo === MPStereoType.UP) {
            ctx.beginPath();
            ctx.moveTo(this.cache.wedge.far[0].x, this.cache.wedge.far[0].y);
            ctx.lineTo(this.cache.wedge.near[0].x, this.cache.wedge.near[0].y);
            ctx.lineTo(this.line.to.x, this.line.to.y);
            ctx.lineTo(this.cache.wedge.near[1].x, this.cache.wedge.near[1].y);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }
        else if (this.stereo === MPStereoType.DOWN) {
            ctx.beginPath();
            for (var i = 0; i < this.cache.hashLines.length; i++) {
                ctx.moveTo(this.cache.hashLines[i].from.x, this.cache.hashLines[i].from.y);
                ctx.lineTo(this.cache.hashLines[i].to.x, this.cache.hashLines[i].to.y);
            }
            ctx.stroke();
        }
        else if (this.type === MPBondType.SINGLE) {
            ctx.beginPath();
            ctx.moveTo(this.line.from.x, this.line.from.y);
            ctx.lineTo(this.line.to.x, this.line.to.y);
            ctx.stroke();
        }
        else if (this.type === MPBondType.DOUBLE || this.type === MPBondType.TRIPLE) {
            ctx.beginPath();
            for (var i = 0; i < this.cache.bond.from.length; i++) {
                ctx.moveTo(this.cache.bond.from[i].x, this.cache.bond.from[i].y);
                ctx.lineTo(this.cache.bond.to[i].x, this.cache.bond.to[i].y);
            }
            if (this.type === MPBondType.TRIPLE) {
                ctx.moveTo(this.line.from.x, this.line.from.y);
                ctx.lineTo(this.line.to.x, this.line.to.y);
            }
            ctx.stroke();
        }
    };
    // CALC ========================================================================
    MPBond.prototype.validate = function () {
        if (this.valid)
            return;
        this.valid = true;
        if (this.mp.mol.atoms[this.from].center.distanceTo(this.mp.mol.atoms[this.to].center) <=
            ((this.mp.mol.atoms[this.from].isVisible() ? 1 : 0) +
                (this.mp.mol.atoms[this.to].isVisible() ? 1 : 0)) *
                this.mp.s.atom.radius) {
            this.hidden = true;
        }
        else {
            this.hidden = false;
            var scale = this.mp.s.bond.scale;
            this.cache = {};
            this.line = {
                from: this.mp.mol.atoms[this.from].calculateBondVertices(this.to, [0])[0],
                to: this.mp.mol.atoms[this.to].calculateBondVertices(this.from, [0])[0]
            };
            this.line.center = new MPPoint((this.line.from.x + this.line.to.x) / 2, (this.line.from.y + this.line.to.y) / 2);
            if (this.mp.s.bond.colored) {
                var f = this.mp.mol.atoms[this.from];
                var t = this.mp.mol.atoms[this.to];
                if (this.stereo === MPStereoType.UP) {
                    this.cache.bondColor = JmolAtomColorsHashHex["C"];
                }
                else if (f.element === t.element) {
                    this.cache.bondColor = JmolAtomColorsHashHex[f.element] || JmolAtomColorsHashHex["C"];
                }
                else {
                    this.cache.bondColor = this.mp.ctx.createLinearGradient(f.getX(), f.getY(), t.getX(), t.getY());
                    this.cache.bondColor.addColorStop(this.mp.s.bond.gradient.from, JmolAtomColorsHashHex[f.element] || JmolAtomColorsHashHex["C"]);
                    this.cache.bondColor.addColorStop(this.mp.s.bond.gradient.to, JmolAtomColorsHashHex[t.element] || JmolAtomColorsHashHex["C"]);
                }
            }
            else {
                this.cache.bondColor = this.mp.s.bond.color;
            }
            if (this.mp.getScale() >= this.mp.s.bond.singleOnlyScale) {
                if (this.stereo === MPStereoType.CIS_TRANS && this.type === MPBondType.DOUBLE) {
                    var ends = transformArrayMult(this.mp.s.bond.delta[MPBondType.CIS], -this.mp.s.bond.deltaScale); //flip ends because of flipped y-axis
                    this.cache.ctd = {
                        from: this.mp.mol.atoms[this.from].calculateBondVertices(this.to, ends),
                        to: this.mp.mol.atoms[this.to].calculateBondVertices(this.from, ends)
                    };
                }
                else if (this.stereo === MPStereoType.UP) {
                    this.cache.wedge = {
                        far: this.mp.mol.atoms[this.from].calculateBondVertices(this.to, [0]),
                        near: this.mp.mol.atoms[this.to].calculateBondVertices(this.from, transformArrayMult(this.mp.s.bond.delta[MPBondType.WEDGEHASH], -this.mp.s.bond.deltaScale)) //flip ends because of flipped y-axis
                    };
                    if (!this.mp.mol.atoms[this.to].isVisible()) {
                        var bonds = this.mp.mol.atoms[this.to].calculateClosestBonds(this.index);
                        if (!bonds.none) {
                            if (this.mp.mol.bonds[bonds.lower].type == MPBondType.SINGLE) {
                                var i1 = this.mp.mol.bonds[bonds.lower].getLine().intersection(new MPLine({
                                    from: this.cache.wedge.far[0],
                                    to: this.cache.wedge.near[0]
                                }));
                                if (i1.p !== undefined && this.line.to.distanceTo(i1.p) < this.mp.s.bond.wedgeFitMaxD) {
                                    this.cache.wedge.near[0] = i1.p || this.cache.wedge.near[0];
                                }
                            }
                            if (this.mp.mol.bonds[bonds.upper].type == MPBondType.SINGLE) {
                                var i2 = this.mp.mol.bonds[bonds.upper].getLine().intersection(new MPLine({
                                    from: this.cache.wedge.far[0],
                                    to: this.cache.wedge.near[1]
                                }));
                                if (i2.p !== undefined && this.line.to.distanceTo(i2.p) < this.mp.s.bond.wedgeFitMaxD) {
                                    this.cache.wedge.near[1] = i2.p || this.cache.wedge.near[1];
                                }
                            }
                        }
                    }
                }
                else if (this.stereo === MPStereoType.DOWN) {
                    var far = this.mp.mol.atoms[this.from].calculateBondVertices(this.to, [0]);
                    var near = this.mp.mol.atoms[this.to].calculateBondVertices(this.from, transformArrayMult(this.mp.s.bond.delta[MPBondType.WEDGEHASH], -this.mp.s.bond.deltaScale)); //flip ends because of flipped y-axis
                    var dx1 = near[0].x - far[0].x;
                    var dy1 = near[0].y - far[0].y;
                    var dx2 = near[1].x - far[0].x;
                    var dy2 = near[1].y - far[0].y;
                    var d1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
                    var w = this.mp.s.bond.width * scale;
                    var s = this.mp.s.bond.hashLineSpace * scale;
                    this.cache.hashLines = [];
                    while (d1 - s - w > 0) {
                        var mult = (d1 - s - w) / d1;
                        d1 *= mult;
                        dx1 *= mult;
                        dy1 *= mult;
                        dx2 *= mult;
                        dy2 *= mult;
                        this.cache.hashLines.push({
                            from: { x: far[0].x + dx1, y: far[0].y + dy1 },
                            to: { x: far[0].x + dx2, y: far[0].y + dy2 }
                        });
                    }
                }
                else if (this.type === MPBondType.DOUBLE || this.type === MPBondType.TRIPLE) {
                    var ends = [];
                    var doubleSide = 1;
                    var fromBonds = this.mp.mol.atoms[this.from].calculateClosestBonds(this.index);
                    var toBonds = this.mp.mol.atoms[this.to].calculateClosestBonds(this.index);
                    var refineUpperSkeletal = false, refineLowerSkeletal = false;
                    //check if this bond will be displayed using all skeletal display rules
                    var skeletal = (this.mp.s.skeletalDisplay &&
                        (!this.mp.mol.atoms[this.from].isVisible() || !this.mp.mol.atoms[this.to].isVisible()) &&
                        //and the bond is not a bond which connects:
                        !(this.mp.mol.atoms[this.from].bonds.length === 1 &&
                            ((this.mp.mol.atoms[this.from].isVisible() &&
                                this.mp.mol.atoms[this.to].bonds.length > 2) ||
                                this.mp.mol.atoms[this.to].bonds.length === 1)) &&
                        !(this.mp.mol.atoms[this.to].bonds.length === 1 &&
                            ((this.mp.mol.atoms[this.to].isVisible() &&
                                this.mp.mol.atoms[this.from].bonds.length > 2) ||
                                this.mp.mol.atoms[this.from].bonds.length === 1)));
                    if (skeletal) {
                        /*
                        Calculate best doubleSide
                        =========================
                        1. The sum of the deviation of the bisect angle relative to
                        the bestBisect angle of the upper and the lower side are
                        calculated. The side with the least bestBisect deviation
                        is used for the double bond
                        2. The approximated double bond length is calcualted
                        using a horizontal bond with length this.line distance
                        and bond delta = 8. Using this length, the bond refinement
                        is skipped or the bond is force flipped to a different side
                        */
                        var length = this.line.from.distanceTo(this.line.to);
                        var upperLength = length, upperBisectD = 0;
                        if (fromBonds.upperSectionAngle < Math.PI) {
                            if (!this.mp.mol.atoms[this.from].isVisible())
                                upperLength -= 8 / Math.tan(fromBonds.upperSectionAngle / 2);
                            upperBisectD += Math.abs(this.mp.s.bond.bestBisect - fromBonds.upperSectionAngle / 2);
                        }
                        else
                            upperBisectD += Math.abs(this.mp.s.bond.bestBisect - Math.PI / 2);
                        if (toBonds.lowerSectionAngle < Math.PI) {
                            if (!this.mp.mol.atoms[this.to].isVisible())
                                upperLength -= 8 / Math.tan(toBonds.lowerSectionAngle / 2);
                            upperBisectD += Math.abs(this.mp.s.bond.bestBisect - toBonds.lowerSectionAngle / 2);
                        }
                        else
                            upperBisectD += Math.abs(this.mp.s.bond.bestBisect - Math.PI / 2);
                        var lowerLength = length, lowerBisectD = 0;
                        if (fromBonds.lowerSectionAngle < Math.PI) {
                            if (!this.mp.mol.atoms[this.from].isVisible())
                                lowerLength -= 8 / Math.tan(fromBonds.lowerSectionAngle / 2);
                            lowerBisectD += Math.abs(this.mp.s.bond.bestBisect - fromBonds.lowerSectionAngle / 2);
                        }
                        else
                            lowerBisectD += Math.abs(this.mp.s.bond.bestBisect - Math.PI / 2);
                        if (toBonds.upperSectionAngle < Math.PI) {
                            if (!this.mp.mol.atoms[this.to].isVisible())
                                lowerLength -= 8 / Math.tan(toBonds.upperSectionAngle / 2);
                            lowerBisectD += Math.abs(this.mp.s.bond.bestBisect - toBonds.upperSectionAngle / 2);
                        }
                        else
                            lowerBisectD += Math.abs(this.mp.s.bond.bestBisect - Math.PI / 2);
                        //check if the opposite sections are almost the same (like in a chain)
                        //if so, a fallback rule is applied (in order to prevent from
                        //inconsistent double bond sides in carbon chains)
                        if (Math.abs(fromBonds.upperSectionAngle - toBonds.upperSectionAngle) +
                            Math.abs(fromBonds.lowerSectionAngle - toBonds.lowerSectionAngle) < this.mp.s.bond.angleDev) {
                            //fallback rule: double bond to the visual upper side
                            var a = this.mp.mol.atoms[this.from].center.angleTo(this.mp.mol.atoms[this.to].center);
                            doubleSide = a > -Math.PI / 2 + this.mp.s.bond.angleDev
                                && a <= Math.PI / 2 + this.mp.s.bond.angleDev ? 1 : -1;
                        }
                        else if (lowerBisectD < upperBisectD ||
                            //or the lower side can apply bond refinement while the upper side cannot
                            (upperLength < this.mp.s.atom.radius && lowerLength > this.mp.s.atom.radius)) {
                            doubleSide = -1;
                        }
                        refineUpperSkeletal = (this.type === MPBondType.TRIPLE || doubleSide === 1)
                            && upperLength > this.mp.s.atom.radius;
                        refineLowerSkeletal = (this.type === MPBondType.TRIPLE || doubleSide === -1)
                            && lowerLength > this.mp.s.atom.radius;
                    }
                    if (this.type === MPBondType.DOUBLE) {
                        ends = this.mp.s.bond.delta[MPBondType.DOUBLE];
                        if (skeletal)
                            ends = transformArrayAdd(ends, -doubleSide * ends[0]);
                    }
                    else if (this.type === MPBondType.TRIPLE) {
                        ends = this.mp.s.bond.delta[MPBondType.TRIPLE];
                    }
                    ends = transformArrayMult(ends, -this.mp.s.bond.deltaScale); //flip ends because of flipped y-axis
                    var toEnds = transformArrayMult(ends, -1); //reversed upper/lower side relate to from
                    this.cache.bond = {
                        from: this.mp.mol.atoms[this.from].calculateBondVertices(this.to, ends),
                        to: this.mp.mol.atoms[this.to].calculateBondVertices(this.from, toEnds)
                    };
                    if (!this.mp.mol.atoms[this.from].isVisible()) {
                        if (!fromBonds.none) {
                            if ((!skeletal || refineLowerSkeletal)
                                && fromBonds.lowerSectionAngle < Math.PI) {
                                this.cache.bond.from[0] = this.refineBondVetex(skeletal, fromBonds.lowerBisectAngle, this.line.from, this.cache.bond.from[0], this.cache.bond.to[0], this.mp.mol.bonds[fromBonds.lower].getLine());
                            }
                            if ((!skeletal || refineUpperSkeletal)
                                && fromBonds.upperSectionAngle < Math.PI) {
                                this.cache.bond.from[1] = this.refineBondVetex(skeletal, fromBonds.upperBisectAngle, this.line.from, this.cache.bond.from[1], this.cache.bond.to[1], this.mp.mol.bonds[fromBonds.upper].getLine());
                            }
                        }
                    }
                    if (!this.mp.mol.atoms[this.to].isVisible()) {
                        if (!toBonds.none) {
                            if ((!skeletal || refineLowerSkeletal)
                                && toBonds.upperSectionAngle < Math.PI) {
                                this.cache.bond.to[0] = this.refineBondVetex(skeletal, toBonds.upperBisectAngle, this.line.to, this.cache.bond.to[0], this.cache.bond.from[0], this.mp.mol.bonds[toBonds.upper].getLine());
                            }
                            if ((!skeletal || refineUpperSkeletal)
                                && toBonds.lowerSectionAngle < Math.PI) {
                                this.cache.bond.to[1] = this.refineBondVetex(skeletal, toBonds.lowerBisectAngle, this.line.to, this.cache.bond.to[1], this.cache.bond.from[1], this.mp.mol.bonds[toBonds.lower].getLine());
                            }
                        }
                    }
                }
            }
        }
    };
    MPBond.prototype.refineBondVetex = function (skeletal, bisectAngle, lineFrom, bondFrom, bondTo, closestBondLine) {
        var intersection;
        if (skeletal) {
            intersection = new MPLine({
                from: lineFrom,
                to: new MPPoint(lineFrom.x + Math.cos(bisectAngle), lineFrom.y + Math.sin(-bisectAngle))
            }).intersection(new MPLine({
                from: bondFrom,
                to: bondTo
            }));
        }
        else {
            intersection = closestBondLine.intersection(new MPLine({
                from: bondFrom,
                to: bondTo
            }));
            if (!intersection.onL1 || lineFrom.distanceTo(intersection.p) >
                closestBondLine.length() / 2) {
                intersection.p = undefined;
            }
        }
        return intersection.p !== undefined ? intersection.p : bondFrom;
    };
    // HANDLE ======================================================================
    MPBond.prototype.getHandler = function () {
        if (this.mp.tool.type === "bond") {
            return {
                scope: this,
                onPointerDown: function (e, mp) {
                    if (mp.tool.data.type) {
                        this.scope.setType(mp.tool.data.type === MPBondType.TRIPLE ? MPBondType.TRIPLE :
                            (this.scope.type === MPBondType.TRIPLE || this.scope.stereo !== MPStereoType.NONE) ? mp.tool.data.type :
                                this.scope.type === MPBondType.SINGLE ? MPBondType.DOUBLE : MPBondType.SINGLE);
                        this.scope.setStereo(MPStereoType.NONE);
                    }
                    else if (mp.tool.data.stereo) {
                        this.scope.setType(MPBondType.SINGLE);
                        if (this.scope.stereo === mp.tool.data.stereo) {
                            var f = this.scope.from;
                            this.scope.setFrom(this.scope.to);
                            this.scope.setTo(f);
                        }
                        else {
                            this.scope.setStereo(mp.tool.data.stereo);
                        }
                    }
                }
            };
        }
        else if (this.mp.tool.type === "fragment" && this.mp.tool.data.frag.toBond !== undefined) {
            return {
                scope: this,
                data: {},
                onPointerDown: function (e, mp) {
                    var p = new MPPoint().fromRelativePointer(e, mp);
                    var f = mp.mol.atoms[this.scope.from].center;
                    var t = mp.mol.atoms[this.scope.to].center;
                    var a = f.angleTo(t);
                    //clone new fragment and transform it
                    this.data.frag = MPFragments.rotate(MPFragments.translate(MPFragments.scale(MPFragments.clone(mp.tool.data.frag.toBond), mp.s.bond.length), f.x, f.y), f, a);
                    //create and select the fragment and store the new fragment data
                    var frag = mp.mol.createFragment(this.data.frag, true);
                    //IMPORTANT: do not merge the other way around or the scope will be lost
                    frag.atoms = mapArray(frag.atoms, mp.mol.mergeAtoms(frag.atoms[0], this.scope.from).amap);
                    frag.atoms = mapArray(frag.atoms, mp.mol.mergeAtoms(frag.atoms[frag.atoms.length - 1], this.scope.to).amap);
                    //resolve selection.mirrorSide
                    var s = 0;
                    for (var i = 0; i < frag.atoms.length; i++) {
                        s += mp.mol.atoms[frag.atoms[i]].center.lineSide(this.scope.getLine());
                    }
                    mp.sel.mirrorSide = s > 0 ? 1 : -1;
                    //get number collapsing atoms
                    var collA = mp.mol.countCollapses(frag.atoms);
                    //mirror fragment
                    for (var i = 0; i < frag.atoms.length; i++) {
                        mp.mol.atoms[frag.atoms[i]].center.mirror(this.scope.getLine(), -mp.sel.mirrorSide);
                    }
                    //get new number collapsing atoms
                    var collB = mp.mol.countCollapses(frag.atoms);
                    //check if new fragment is already added
                    if (collA === frag.atoms.length && collB === frag.atoms.length) {
                        this.data.lock = true;
                        //deselect this
                        this.scope.select(false);
                        mp.mol.atoms[this.scope.from].select(false);
                        mp.mol.atoms[this.scope.to].select(false);
                        mp.sel.remove();
                        return;
                    }
                    //mirror back if old number of collapsing atoms is lower
                    if (collA < collB) {
                        for (var i = 0; i < frag.atoms.length; i++) {
                            mp.mol.atoms[frag.atoms[i]].center.mirror(this.scope.getLine(), mp.sel.mirrorSide);
                        }
                        this.data.lock = collB === frag.atoms.length;
                    }
                    else {
                        mp.sel.mirrorSide = -mp.sel.mirrorSide;
                        this.data.lock = collA === frag.atoms.length;
                    }
                },
                onPointerMove: function (e, mp) {
                    if (this.data.lock)
                        return; //do not mirror fragment if mirror is useless
                    var p = new MPPoint().fromRelativePointer(e, mp);
                    mp.sel.mirror(this.scope.getLine(), p);
                },
                onPointerUp: function (e, mp) {
                    mp.sel.collapse();
                    mp.sel.clear();
                }
            };
        }
        else if (this.mp.tool.type === "erase") {
            return {
                scope: this,
                onPointerDown: function (e, mp) {
                    if (this.scope.isSelected())
                        mp.sel.remove();
                    else
                        mp.mol.removeBond(this.scope.index);
                    //dismiss all further calls to this handler
                    mp.pointer.handler = undefined;
                }
            };
        }
        else {
            return {
                scope: this,
                data: {},
                onPointerMove: function (e, mp) {
                    mp.setCursor("move");
                    var p = new MPPoint().fromRelativePointer(e, mp);
                    var dx = p.x - mp.pointer.old.r.x;
                    var dy = p.y - mp.pointer.old.r.y;
                    if (Math.sqrt(dx * dx + dy * dy) > mp.s.draggingThreshold || this.data.moved) {
                        this.data.moved = true;
                        if (this.scope.isSelected() && mp.sel.cache.atoms.length > 0) {
                            mp.sel.translate(dx, dy);
                        }
                        else {
                            mp.mol.atoms[this.scope.from].translate(dx, dy);
                            mp.mol.atoms[this.scope.to].translate(dx, dy);
                        }
                        mp.pointer.old.r = p;
                    }
                },
                onPointerUp: function (e, mp) {
                    if (!this.data.moved && oneOf(mp.tool.type, ["select", "drag"])) {
                        var s = !this.scope.isSelected();
                        this.scope.select(s);
                        if (mp.sel.cache.atoms.length === 0) {
                            mp.mol.atoms[this.scope.from].select(s);
                            mp.mol.atoms[this.scope.to].select(s);
                        }
                        mp.sel.updateRotationCenter();
                    }
                    else {
                        if (this.scope.isSelected())
                            mp.sel.collapse();
                        else
                            mp.mol.collapseAtoms([this.scope.from, this.scope.to], true);
                        /* process possible changes to
                        rotation center caused by collapsing */
                        mp.sel.updateRotationCenter();
                    }
                }
            };
        }
    };
    /**
     * Handler for mouse events
     * @param  {MPPoint} point Event origin
     * @param  {String}  type  Event type (hover || active)
     * @return {Boolean}       Indicates if event is handled by this MPBond
     */
    MPBond.prototype.handle = function (point, type) {
        if (this.line === undefined)
            return false;
        var r = this.mp.s.bond.radiusScaled;
        if (point.inLineBox(this.line.from, this.line.to, r)) {
            if (point.lineDistance(this.line.from, this.line.to) <= r) {
                this.setDisplay(type);
                return true;
            }
        }
        this.setDisplay("normal");
        return false;
    };
    MPBond.prototype.handleRectSelect = function (rect) {
        if (this.line === undefined)
            return;
        this.select(this.line.center.inRect(rect));
    };
    MPBond.prototype.handlePolygonSelect = function (polygon) {
        if (this.line === undefined)
            return;
        this.select(this.line.center.inPolygon(polygon));
    };
    return MPBond;
}());
/**
 * This file is part of MolView (http://molview.org)
 * Copyright (c) 2014, 2015 Herman Bergwerf
 *
 * MolView is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MolView is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with MolView.  If not, see <http://www.gnu.org/licenses/>.
 */
/**
 * Input fragment data for MolPad
 * 1. you can pass this data as tool.data.frag
 * 2. all fragments use bondLength = 1 as default
 * 3. you have to multiply all coordinates with the real bondLength
 * 4. all fragments are centered on the positive side of the x-axis
 * 5. you can rotate the fragment coordinates around (0, 0)
 * 6. the first atom in each fragment.toAtom is the atom you have to connect to
 *    when adding the fragment to an atom
 * 7. the first and the last atom in each fragment.toBond are the atoms
 *    you have to merge with (first => from, last => to)
 */
var MPFragments = (function () {
    function MPFragments() {
    }
    //length: 1,
    //lengthHydrogen: 34 / 55,//same as MolPad
    MPFragments.init = function () {
        //generate all fragments
        MPFragments.benzene = MPFragments.generateRing(6, true);
        MPFragments.cyclopropane = MPFragments.generateRing(3, false);
        MPFragments.cyclobutane = MPFragments.generateRing(4, false);
        MPFragments.cyclopentane = MPFragments.generateRing(5, false);
        MPFragments.cyclohexane = MPFragments.generateRing(6, false);
        MPFragments.cycloheptane = MPFragments.generateRing(7, false);
    };
    MPFragments.generateRing = function (vertices, alternating) {
        var as = PI2 / vertices; //angle step
        var r = 0.5 / Math.sin(as / 2) * this.length;
        var ret = {
            full: this.createRing(vertices, alternating ? 2 : 0),
            toAtom: this.translate(this.createRing(vertices, alternating ? 2 : 0), r, 0),
            toBond: this.rotate(this.translate(this.createRing(vertices, alternating ? 2 : 0), r, 0), { x: 0, y: 0 }, (Math.PI - as) / 2) //move bond start to (0,0), make first bond horizontal
        };
        return ret;
    };
    /**
     * Create ring data
     * @param {Integer} vertices    Number of ring vertices
     * @param {Integer} alternating Double/single bond alternation:
     *                              0 = none
     *                              1 = first double on odd bonds
     *                              2 = first double on even bonds
     */
    MPFragments.createRing = function (vertices, alternating) {
        var frag = { atoms: [], bonds: [] };
        var as = PI2 / vertices; //angle step
        frag.r = 0.5 / Math.sin(as / 2) * this.length;
        //ring
        for (var i = 0; i < vertices; i++) {
            //move a = 0 to left side to apply rule 4
            frag.atoms.push({
                center: new MPPoint(frag.r * Math.cos(Math.PI + as * i), //start at the left side
                frag.r * Math.sin(Math.PI + as * i)),
                element: "C"
            });
            frag.bonds.push({
                from: i,
                to: i + 1 < vertices ? i + 1 : 0,
                type: alternating !== 0 ? (i % 2 === (2 - alternating) ? MPBondType.SINGLE : MPBondType.DOUBLE) : MPBondType.SINGLE
            });
        }
        return frag;
    };
    MPFragments.clone = function (frag) {
        var copy = { atoms: [], bonds: [], r: frag.r };
        for (var i = 0; i < frag.atoms.length; i++) {
            copy.atoms.push({
                center: frag.atoms[i].center.clone(),
                element: frag.atoms[i].element
            });
        }
        for (var i = 0; i < frag.bonds.length; i++) {
            copy.bonds.push({
                from: frag.bonds[i].from,
                to: frag.bonds[i].to,
                type: frag.bonds[i].type
            });
        }
        return copy;
    };
    MPFragments.scale = function (frag, scale) {
        for (var i = 0; i < frag.atoms.length; i++) {
            frag.atoms[i].center.scale(scale);
        }
        return frag;
    };
    MPFragments.rotate = function (frag, center, angle) {
        for (var i = 0; i < frag.atoms.length; i++) {
            frag.atoms[i].center.rotateAroundCenter(center, angle);
        }
        return frag;
    };
    MPFragments.translate = function (frag, dx, dy) {
        for (var i = 0; i < frag.atoms.length; i++) {
            frag.atoms[i].center.translate(dx, dy);
        }
        return frag;
    };
    MPFragments.benzene = {};
    MPFragments.cyclopropane = {};
    MPFragments.cyclobutane = {};
    MPFragments.cyclopentane = {};
    MPFragments.cyclohexane = {};
    MPFragments.cycloheptane = {};
    return MPFragments;
}());
/**
 * This file is part of MolView (http://molview.org)
 * Copyright (c) 2014, 2015 Herman Bergwerf
 *
 * MolView is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MolView is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with MolView.  If not, see <http://www.gnu.org/licenses/>.
 */
var MPLine = (function () {
    function MPLine(obj) {
        this.from = obj !== undefined ? obj.from.clone() || new MPPoint() : new MPPoint();
        this.to = obj !== undefined ? obj.to.clone() || new MPPoint() : new MPPoint();
    }
    /* function lineLineIntersection(x1, y1, x2, y2, x3, y3, x4, y4)
    {
        var div = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
        return {
            x: ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / div,
            y: ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / div
        };
    } */
    MPLine.prototype.intersection = function (line) {
        var denominator = ((line.to.y - line.from.y) * (this.to.x - this.from.x))
            - ((line.to.x - line.from.x) * (this.to.y - this.from.y));
        if (denominator === 0) {
            return {
                p: undefined,
                onL1: false,
                onL2: false
            };
        }
        var a = this.from.y - line.from.y;
        var b = this.from.x - line.from.x;
        var numerator1 = ((line.to.x - line.from.x) * a) - ((line.to.y - line.from.y) * b);
        var numerator2 = ((this.to.x - this.from.x) * a) - ((this.to.y - this.from.y) * b);
        a = numerator1 / denominator;
        b = numerator2 / denominator;
        return {
            p: new MPPoint(this.from.x + (a * (this.to.x - this.from.x)), this.from.y + (a * (this.to.y - this.from.y))),
            //if line2 is a segment and line1 is infinite, they intersect if
            onL1: a > 0 && a < 1,
            //if line2 is a segment and line1 is infinite, they intersect if:
            onL2: b > 0 && b < 1
        };
    };
    MPLine.prototype.length = function () {
        return this.from.distanceTo(this.to);
    };
    return MPLine;
}());
/**
 * This file is part of MolView (http://molview.org)
 * Copyright (c) 2014, 2015 Herman Bergwerf
 *
 * MolView is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MolView is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with MolView.  If not, see <http://www.gnu.org/licenses/>.
 */
/**
 * MPMolecule validation system
 * ============================
 * The molecule graphics are kept up to date by a validation system
 * MPAtoms and MPBonds both have some cached calculations
 * These calculations can be marked as invalid. If this is the case, they are
 * recalculated the next time they are validated. Validation is done prior to
 * the drawing of the MPAtom or MPBond and in calculations which depend on the
 * cached calculations of is own object.
 *
 * There are some invalidation rules:
 * - MPAtom:
 *   - When the setup scaling has changed
 *   - When the atom center has changed
 *   - When the atom information has changed
 *   - When a neighbor atom has moved and this atom is not visible
 *     or the visibility is toggled
 * - MPBond:
 *   - When the setup scaling has changed
 *   - When the bond information has changed
 *   - when the center of the from/to MPAtom has changed
 *   - When an MPBond which is connected to a from/to MPAtom is invalidated
 *     and the connecting atom is invisible (due to skeletal display) or was
 *     invisible before the MPBond was invalidated
 */
var MPMolecule = (function () {
    /**
     * Create new molecule data object
     * @param {MolPad} mp
     */
    function MPMolecule(mp) {
        this.atoms = [];
        this.bonds = [];
        this.stack = [];
        this.reverseStack = [];
        this.copy = { atoms: [], bonds: [], fingerprint: "" };
        this.mp = mp;
    }
    /**
     * Clear all bonds and atoms
     */
    MPMolecule.prototype.clear = function () {
        this.atoms = [];
        this.bonds = [];
    };
    /**
     * Invalidate all atoms and bonds
     */
    MPMolecule.prototype.invalidateAll = function () {
        for (var i = 0; i < this.atoms.length; i++) {
            this.atoms[i].invalidate();
        }
        for (var i = 0; i < this.bonds.length; i++) {
            this.bonds[i].invalidate();
        }
    };
    /**
     * Validate all atoms and bonds
     */
    MPMolecule.prototype.validateAll = function () {
        for (var i = 0; i < this.atoms.length; i++) {
            this.atoms[i].validate();
        }
        for (var i = 0; i < this.bonds.length; i++) {
            this.bonds[i].validate();
        }
    };
    /**
     * Execute callback for all bonds and or atoms
     * @param {Function} callback
     * @param {Boolean}  atoms
     * @param {Boolean}  bonds
     */
    MPMolecule.prototype.exec = function (callback, atoms, bonds) {
        if (atoms) {
            for (var i = 0; i < this.atoms.length; i++) {
                if (callback.call(this.mp, this.atoms[i]))
                    return;
            }
        }
        if (bonds) {
            for (var i = 0; i < this.bonds.length; i++) {
                if (callback.call(this.mp, this.bonds[i]))
                    return;
            }
        }
    };
    MPMolecule.prototype.loadMOL = function (mol) { throw new Error("Not Implemented, TODO"); };
    MPMolecule.prototype.getMOL = function () { throw new Error("Not Implemented, TODO"); };
    MPMolecule.prototype.getSMILES = function () { throw new Error("Not Implemented, TODO"); };
    //TODO
    //    /**
    //     * Load molfile into MPMolecule
    //     * Uses Ketcher chem utils
    //     * @param {String}  mol
    //     */
    //    loadMOL(mol)
    //    {
    //        this.clear();
    //    
    //        var molecule = chem.Molfile.parseCTFile(mol.split("\n"));
    //    
    //        //convert Ketcher data format into MolPad molecule
    //        var scope = this;
    //        molecule.atoms.each(function(i, atomData)
    //        {
    //            var atom = new MPAtom(scope.mp, {
    //                i: i,
    //                x: atomData.pp.x * scope.mp.s.bond.length,
    //                y: atomData.pp.y * scope.mp.s.bond.length,
    //                element: atomData.label,
    //                charge: atomData.charge,
    //                isotope: atomData.isotope
    //            });
    //    
    //            scope.atoms.push(atom);
    //        });
    //    
    //        molecule.bonds.each(function(i, bondData)
    //        {
    //            var bond = new MPBond(scope.mp, {
    //                i: i,
    //                type: bondData.type,
    //                stereo: bondData.stereo,
    //                from: bondData.begin,
    //                to: bondData.end
    //            });
    //    
    //            scope.bonds.push(bond);
    //            scope.atoms[bondData.begin].bonds.push(bond.index);
    //            scope.atoms[bondData.end].bonds.push(bond.index);
    //        });
    //    }
    //    
    //    /**
    //     * @return {String} Molfile string
    //     */
    //    getMOL()
    //    {
    //        return new chem.MolfileSaver().saveMolecule(this.getKetcherData());
    //    }
    //    
    //    /**
    //     * @return {String} SMILES string
    //     */
    //    getSMILES()
    //    {
    //        if(this.atoms.length === 0) throw new Error("No atoms found");
    //        return new chem.SmilesSaver().saveMolecule(this.getKetcherData());
    //    }
    //    
    //    /**
    //     * Convert molecule into chem.Struct object
    //     * @return {chem.Struct}
    //     */
    //    getKetcherData()
    //    {
    //        var molecule = new chem.Struct();
    //    
    //        for(var i = 0; i < this.atoms.length; i++)
    //        {
    //            molecule.atoms.add(this.atoms[i].getKetcherData());
    //        }
    //        for(var i = 0; i < this.bonds.length; i++)
    //        {
    //            molecule.bonds.add(this.bonds[i].getKetcherData());
    //        }
    //    
    //        molecule.initHalfBonds();
    //        molecule.initNeighbors();
    //        molecule.markFragments();
    //    
    //        return molecule;
    //    }
    //
    /**
     * Convert molecule into plain JSON object
     * @return {Object}
     */
    MPMolecule.prototype.getPlainData = function () {
        var molecule = { atoms: [], bonds: [] };
        for (var i = 0; i < this.atoms.length; i++) {
            molecule.atoms.push(this.atoms[i].getConfig());
        }
        for (var i = 0; i < this.bonds.length; i++) {
            molecule.bonds.push(this.bonds[i].getConfig());
        }
        return molecule;
    };
    /**
     * Load plain JSON object
     * @param {Object} data
     */
    MPMolecule.prototype.loadPlainData = function (data) {
        this.clear();
        for (var i = 0; i < data.atoms.length; i++) {
            this.atoms.push(new MPAtom(this.mp, data.atoms[i]));
        }
        for (var i = 0; i < data.bonds.length; i++) {
            this.bonds.push(new MPBond(this.mp, data.bonds[i]));
        }
        this.mp.redraw(true);
    };
    /**
     * Generate unique fingerprint for the current molecule
     * @return {String}
     */
    MPMolecule.prototype.getFingerprint = function () {
        var array = [];
        for (var i = 0; i < this.atoms.length; i++) {
            array.push(this.atoms[i].toString());
        }
        array.sort();
        return array.join("");
    };
    /**
     * Check if the current molecule has changed based on its fingerprint
     */
    MPMolecule.prototype.isChanged = function () {
        return this.getFingerprint() !== this.copy.fingerprint;
    };
    /**
     * Create fragment from fragment data which is created using MPFragment
     * @param  {Object}  fragment Fragment data
     * @param  {Boolean} select   Select all new bonds and atoms [optional]
     * @return {Object}           New fragment data
     */
    MPMolecule.prototype.createFragment = function (fragment, select) {
        var ret = { atoms: [], bonds: [] };
        for (var i = 0; i < fragment.atoms.length; i++) {
            var atom = new MPAtom(this.mp, {
                i: this.atoms.length,
                x: fragment.atoms[i].center.x,
                y: fragment.atoms[i].center.y,
                element: fragment.atoms[i].element,
                selected: select
            });
            this.atoms.push(atom);
            ret.atoms.push(atom.index);
        }
        for (var i = 0; i < fragment.bonds.length; i++) {
            var bond = new MPBond(this.mp, {
                i: this.bonds.length,
                type: fragment.bonds[i].type,
                stereo: MPStereoType.NONE,
                from: ret.atoms[fragment.bonds[i].from],
                to: ret.atoms[fragment.bonds[i].to],
                selected: select
            });
            this.bonds.push(bond);
            ret.bonds.push(bond.index);
            this.atoms[bond.from].addBond(bond.index);
            this.atoms[bond.to].addBond(bond.index);
        }
        if (select) {
            this.mp.sel.update();
        }
        return ret;
    };
    /**
     * Rotate array of atoms around a center using the angle between the center
     * and a given point and an optional number of clampSteps
     *
     * @param  {MPPoint} center
     * @param  {MPPoint} point
     * @param  {Array}   atoms        Array of atom indices
     * @param  {Float}   currentAngle Current rotation angle of the selction
     * @param  {Float}   startAngle   Start rotation angle used for angle clamping
     * @param  {Integer} clampSteps   Number of steps the angle should be clamped to
     * @param  {Boolean} forced       Forced update
     * @return {Float}                New currentAngle
     */
    MPMolecule.prototype.rotateAtoms = function (center, point, atoms, currentAngle, startAngle, clampSteps, forced) {
        var a = currentAngle;
        if (clampSteps !== undefined)
            a = clampedAngle(startAngle, center, point, clampSteps);
        else
            a = center.angleTo(point);
        if (a !== currentAngle || forced) {
            for (var i = 0; i < atoms.length; i++) {
                this.atoms[atoms[i]].rotateAroundCenter(center, a - currentAngle);
            }
            return a;
        }
        else
            return currentAngle;
    };
    /**
     * Merge atom src into atom dest
     * @param   {Integer} src     Index of srd atom
     * @param   {Integer} dest    Index of dest atom
     * @param   {Boolean} reverse Reverse src and dest but retain old dest atom
     * @return  {Array}           New index mapping
     */
    MPMolecule.prototype.mergeAtoms = function (src, dest, reverse) {
        var _src = this.atoms[src];
        var _dest = this.atoms[dest];
        if (reverse)
            _dest.center.replace(_src.center);
        _dest.select(_src.isSelected() || _dest.isSelected());
        for (var j = 0; j < _src.bonds.length; j++) {
            /* only transfer bond if bond destination is not
            already included in the current set of bonds */
            var n = _dest.getNeighborBond(this.bonds[_src.bonds[j]]
                .getOppositeAtom(src));
            if (n === -1) {
                this.bonds[_src.bonds[j]].replaceAtom(src, dest);
                _dest.addBond(_src.bonds[j]);
            }
            else {
                //transfer selected state to replacement bond
                this.bonds[n].select(this.bonds[_src.bonds[j]].isSelected()
                    || this.bonds[n].isSelected());
                //always force single bond over any other bond types
                if (this.bonds[_src.bonds[j]].type === MPBondType.SINGLE) {
                    this.bonds[n].setType(MPBondType.SINGLE);
                }
            }
        }
        //carbon atoms are less important
        if (_dest.element === "C") {
            _dest.setElement(_src.element);
        }
        this.atoms.splice(src, 1); //remove old atom
        return this.updateIndices();
    };
    /**
     * Collapse set of atom indices into the entire molecule
     * @param {Array}   atoms        Atom indices
     * @param {Boolean} reverse      If set, the $atoms centers will not be used
     */
    MPMolecule.prototype.collapseAtoms = function (atoms, reverse) {
        for (var i = 0; i < atoms.length; i++) {
            for (var j = 0; j < this.atoms.length; j++) {
                if (atoms.indexOf(j) !== -1)
                    continue; //skip input atoms
                var distance = (!this.atoms[atoms[i]].isVisible()
                    && !this.atoms[j].isVisible() ? 1 : 2)
                    * this.mp.s.atom.selectionRadiusScaled;
                if (this.atoms[atoms[i]].center.inCircle(this.atoms[j].center, distance)) {
                    var map = this.mergeAtoms(j, atoms[i], reverse);
                    atoms = mapArray(atoms, map.amap);
                    break; //the old atoms[i] has been handled
                }
            }
        }
    };
    /**
     * Count how much atoms of the input can be collapsed into the molecules
     * @param  {Array} atoms Atom indices
     * @return {Integer}
     */
    MPMolecule.prototype.countCollapses = function (atoms) {
        var ret = 0;
        for (var i = 0; i < atoms.length; i++) {
            for (var j = 0; j < this.atoms.length; j++) {
                if (atoms.indexOf(j) !== -1)
                    continue; //skip input atoms
                if (this.atoms[atoms[i]].center.inCircle(this.atoms[j].center, this.mp.s.atom.radiusScaled)) {
                    ret++;
                }
            }
        }
        return ret;
    };
    /**
     * Remove an atom with the given index from the current molecule
     * @param  {Integer} index Atom index
     * @param  {Boolean} rdh   Remove disconnected hydrogens
     * @return {Object}        New indices maps
     */
    MPMolecule.prototype.removeAtom = function (index, rdh) {
        var splice = [];
        if (rdh) {
            for (var i = 0; i < this.atoms[index].bonds.length; i++) {
                var ai = this.bonds[this.atoms[index].bonds[i]].getOppositeAtom(index);
                if (this.atoms[ai].element == "H" && this.atoms[ai].bonds.length == 1)
                    splice.push(ai);
            }
        }
        splice.push(index);
        splice.sort(function (a, b) { return a - b; }).reverse();
        for (var i = 0; i < splice.length; i++) {
            this.atoms.splice(splice[i], 1);
        }
        return this.updateIndices();
    };
    /**
     * Remove a bond with the given index from the current molecule
     * @param {Integer} index Bond index
     */
    MPMolecule.prototype.removeBond = function (index) {
        var f = this.bonds[index].from;
        var t = this.bonds[index].to;
        //remove connected atoms if this is the last bond
        if (this.atoms[f].bonds.length === 1) {
            this.atoms.splice(f, 1);
            if (t > f)
                t--;
        }
        if (this.atoms[t].bonds.length === 1) {
            this.atoms.splice(t, 1);
        }
        this.bonds.splice(index, 1);
        return this.updateIndices();
    };
    /**
     * @return {Array} New index mapping
     */
    MPMolecule.prototype.updateIndices = function () {
        /* CAUTION: nobody is allowed to execute any methods during this process.
        Therefore, only manual data modifications should be used */
        var atomIndexMap = {}, bondIndexMap = {};
        for (var i = 0; i < this.atoms.length; i++) {
            atomIndexMap[this.atoms[i].index] = i;
            this.atoms[i].index = i;
            this.atoms[i].valid = false;
        }
        for (var i = 0; i < this.bonds.length; i++) {
            var bond = this.bonds[i];
            var from = atomIndexMap[bond.from];
            var to = atomIndexMap[bond.to];
            if (from !== undefined && to !== undefined) {
                bondIndexMap[bond.index] = i;
                bond.index = i;
                bond.from = from;
                bond.to = to;
                bond.valid = false; //manual invalidate
            }
            else {
                this.bonds.splice(i, 1);
                i--;
            }
        }
        for (var i = 0; i < this.atoms.length; i++) {
            this.atoms[i].mapBonds(bondIndexMap);
        }
        this.mp.sel.update();
        return {
            amap: atomIndexMap,
            bmap: bondIndexMap
        };
    };
    MPMolecule.prototype.getBBox = function () {
        if (this.atoms.length === 0) {
            return {
                x: 0,
                y: 0,
                width: 1,
                height: 1
            };
        }
        var bottomLeft = undefined, topRight = undefined;
        for (var i = 0; i < this.atoms.length; i++) {
            //calculate center line since molecule might not be updated yet
            var l = this.atoms[i].calculateCenterLine();
            var px1 = this.atoms[i].center.x + (l.area.point ? 0 : l.area.left);
            var px2 = this.atoms[i].center.x + (l.area.point ? 0 : l.area.right);
            var py = this.atoms[i].center.y;
            if (bottomLeft === undefined) {
                bottomLeft = { x: px1, y: py };
            }
            else {
                if (bottomLeft.x > px1)
                    bottomLeft.x = px1;
                if (bottomLeft.y > py)
                    bottomLeft.y = py;
            }
            if (topRight === undefined) {
                topRight = { x: px2, y: py };
            }
            else {
                if (topRight.x < px2)
                    topRight.x = px2;
                if (topRight.y < py)
                    topRight.y = py;
            }
        }
        var r = this.mp.s.atom.radius;
        return {
            x: bottomLeft.x - r,
            y: bottomLeft.y - r,
            width: topRight.x - bottomLeft.x + 2 * r,
            height: topRight.y - bottomLeft.y + 2 * r
        };
    };
    /**
     * Undo/redo
     */
    /**
     * Updates the internal molecule plain copy for the undo stack
     */
    MPMolecule.prototype.updateCopy = function () {
        var fingerprint = this.getFingerprint();
        if (fingerprint !== this.copy.fingerprint) {
            this.reverseStack = [];
            this.stack.push(this.copy);
            if (this.stack.length > this.mp.s.maxStackSize) {
                this.stack.shift();
            }
            this.copy = this.getPlainData();
            this.copy.fingerprint = fingerprint;
            this.mp.changed();
        }
    };
    MPMolecule.prototype.undo = function (noRedoPush) {
        if (this.stack.length > 0) {
            if (!noRedoPush) {
                this.reverseStack.push(this.copy);
            }
            this.copy = this.stack.pop();
            this.loadPlainData(this.copy);
            return true;
        }
        else
            return false;
    };
    MPMolecule.prototype.redo = function () {
        if (this.reverseStack.length > 0) {
            this.stack.push(this.copy);
            this.copy = this.reverseStack.pop();
            this.loadPlainData(this.copy);
            return true;
        }
        else
            return false;
    };
    /* DEPRECATED */
    MPMolecule.prototype.removeImplicitHydrogen = function () {
        var implicit = [];
        for (var i = 0; i < this.atoms.length; i++) {
            if (this.atoms[i].isImplicit()) {
                implicit.push(i);
            }
        }
        for (var i = 0; i < implicit.length; i++) {
            this.atoms.splice(implicit[i] - i, 1);
        }
        this.updateIndices();
    };
    MPMolecule.prototype.addImplicitHydrogen = function () {
        for (var i = 0; i < this.atoms.length; i++) {
            this.atoms[i].addImplicitHydrogen();
        }
    };
    return MPMolecule;
}());
/**
 * This file is part of MolView (http://molview.org)
 * Copyright (c) 2014, 2015 Herman Bergwerf
 *
 * MolView is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MolView is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with MolView.  If not, see <http://www.gnu.org/licenses/>.
 */
var MPPoint = (function () {
    function MPPoint(x, y) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        this.x = x || 0;
        this.y = y || 0;
    }
    //constructor(obj: {x: number, y:number})
    //{
    //    this.x = obj.x;
    //    this.y = obj.y;
    //}
    //TODO
    ///**
    // * MPPoint From Object
    // * @param {Object} obj
    // */
    //function MPPFO(obj)
    //{
    //    return new MPPoint(obj.x, obj.y);
    //}
    MPPoint.prototype.clone = function () {
        return new MPPoint(this.x, this.y);
    };
    MPPoint.prototype.equals = function (point) {
        return this.x === point.x && this.y === point.y;
    };
    MPPoint.prototype.set = function (x, y) {
        this.x = x;
        this.y = y;
    };
    MPPoint.prototype.replace = function (p) {
        this.x = p.x;
        this.y = p.y;
    };
    MPPoint.prototype.add = function (p) {
        this.x += p.x;
        this.y += p.y;
    };
    MPPoint.prototype.addX = function (a) { this.x += a; };
    MPPoint.prototype.addY = function (a) { this.y += a; };
    MPPoint.prototype.divide = function (div) {
        this.x /= div;
        this.y /= div;
    };
    MPPoint.prototype.divideX = function (a) { this.x /= a; };
    MPPoint.prototype.divideY = function (a) { this.y /= a; };
    MPPoint.prototype.multiply = function (mult) {
        this.x *= mult;
        this.y *= mult;
    };
    MPPoint.prototype.multiplyX = function (a) { this.x *= a; };
    MPPoint.prototype.multiplyY = function (a) { this.y *= a; };
    MPPoint.prototype.translate = function (x, y) {
        this.x += x;
        this.y += y;
    };
    MPPoint.prototype.scale = function (scale) {
        this.x *= scale;
        this.y *= scale;
    };
    MPPoint.prototype.mirror = function (line, side) {
        if (this.lineSide(line) !== side) {
            //http://stackoverflow.com/questions/3306838
            var dx = line.to.x - line.from.x;
            var dy = line.to.y - line.from.y;
            if (Math.abs(dx) < 0.001) {
                this.x = 2 * line.from.x - this.x;
            }
            else {
                var a = dy / dx;
                var c = line.from.y - a * line.from.x; //c = y - ax
                var d = (this.x + ((this.y - c) * a)) / (1 + a * a);
                this.x = 2 * d - this.x;
                this.y = 2 * d * a - this.y + 2 * c;
            }
            return true;
        }
        else
            return false;
    };
    /**
     * Find on which side of a line the given point is
     * @param  {Object} point { x: 0, y: 0 }
     * @param  {Object} line  { from: { x: 0, y: 0 }, to: { x: 0, y: 0 } }
     * @return {Integer}      -1: left, 0: on the line, +1: right
     */
    MPPoint.prototype.lineSide = function (line) {
        var s = sign((line.to.x - line.from.x) * (this.y - line.from.y) -
            (line.to.y - line.from.y) * (this.x - line.from.x));
        return s > 0 ? 1 : s < 0 ? -1 : 0;
    };
    /**
     * Rotate a this point around a given center using a given angle
     * @param {MPPoint} c Center
     * @param {MPPoint} a Angle
     */
    MPPoint.prototype.rotateAroundCenter = function (c, a) {
        var dx = this.x - c.x;
        var dy = this.y - c.y;
        this.x = dx * Math.cos(-a) - dy * Math.sin(-a) + c.x;
        this.y = dx * Math.sin(-a) + dy * Math.cos(-a) + c.y;
    };
    /**
     * Calculate angle between the x-asix and the 'to' point where this point
     * is the center point
     * @param {MPPoint} to
     */
    MPPoint.prototype.angleTo = function (to) {
        return Math.atan2(-to.y + this.y, to.x - this.x); //flip y-axis
    };
    /**
     * Checks if the given point is inside the given circle
     * @param  {MPPoint} center Circle center
     * @param  {Float}   radius Cricle radius
     * @return {Boolean}
     */
    MPPoint.prototype.inCircle = function (center, radius) {
        return (this.x - center.x) * (this.x - center.x) +
            (this.y - center.y) * (this.y - center.y) < radius * radius;
    };
    /**
     * Calculates if point is NOT inside an R radius from line ab
     * @param  {MPPoint}  a Line vertex a
     * @param  {MPPoint}  b Line vertex b
     * @param  {Float}    r Radius around line
     * @return {Boolean}
     */
    MPPoint.prototype.inLineBox = function (a, b, r) {
        var bl = new MPPoint(); // bottom left
        var tr = new MPPoint(); // top right
        if (a.x < b.x) {
            bl.x = a.x, tr.x = b.x;
        }
        else {
            bl.x = b.x, tr.x = a.x;
        }
        if (a.y < b.y) {
            bl.y = a.y, tr.y = b.y;
        }
        else {
            bl.y = b.y, tr.y = a.y;
        }
        return !(this.x < bl.x - r || this.x > tr.x + r
            || this.y < bl.y - r || this.y > tr.y + r);
    };
    /**
     * Calculates if point is NOT inside an R radius from point a
     * @param  {MPPoint}  a Point a
     * @param  {Float}    r Radius around line
     * @return {Boolean}
     */
    MPPoint.prototype.inCircleBox = function (a, r) {
        return !(this.x < a.x - r || this.x > a.x + r
            || this.y < a.y - r || this.y > a.y + r);
    };
    MPPoint.prototype.inRect = function (rect) {
        //clone to prevent from reference cluttering
        var x = rect.x, y = rect.y, w = rect.width, h = rect.height;
        if (w < 0) {
            w = -w;
            x -= w;
        }
        if (h < 0) {
            h = -h;
            y -= h;
        }
        return this.x > x && this.x < x + w
            && this.y > y && this.y < y + h;
    };
    MPPoint.prototype.inPolygon = function (polygon) {
        var c = false;
        for (var i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
            if ((polygon[i].y > this.y) !== (polygon[j].y > this.y) &&
                this.x < ((polygon[j].x - polygon[i].x) * (this.y - polygon[i].y) / (polygon[j].y - polygon[i].y) + polygon[i].x)) {
                c = !c;
            }
        }
        return c;
    };
    /**
     * Calculate shortest distance between a point and a line
     * @param  {MPPoint} a Line vertex a
     * @param  {MPPoint} b Line vertex b
     * @return {Float}
     */
    MPPoint.prototype.lineDistance = function (a, b) {
        var A = this.x - a.x;
        var B = this.y - a.y;
        var C = b.x - a.x;
        var D = b.y - a.y;
        var dot = A * C + B * D;
        var len_sq = C * C + D * D;
        var param = dot / len_sq;
        var xx, yy;
        if (param < 0 || (a.x === b.x && a.y === b.y)) {
            xx = a.x;
            yy = a.y;
        }
        else if (param > 1) {
            xx = b.x;
            yy = b.y;
        }
        else {
            xx = a.x + param * C;
            yy = a.y + param * D;
        }
        var dx = this.x - xx;
        var dy = this.y - yy;
        return Math.sqrt(dx * dx + dy * dy);
    };
    MPPoint.prototype.distanceTo = function (p) {
        return Math.sqrt((p.x - this.x) * (p.x - this.x) + (p.y - this.y) * (p.y - this.y));
    };
    MPPoint.prototype.fromPointer = function (e) {
        var oe = e.originalEvent;
        if (oe.targetTouches && oe.targetTouches.length > 0) {
            this.set(oe.targetTouches[0].pageX, oe.targetTouches[0].pageY);
        }
        else {
            this.set(oe.pageX, oe.pageY);
        }
        return this;
    };
    MPPoint.prototype.fromRelativePointer = function (e, mpctx) {
        this.fromPointer(e);
        var offset = mpctx.canvas.getBoundingClientRect();
        this.x = (this.x - offset.left) * mpctx.devicePixelRatio;
        this.y = (this.y - offset.top) * mpctx.devicePixelRatio;
        this.x = (this.x - mpctx.matrix[4]) / mpctx.matrix[0];
        this.y = (this.y - mpctx.matrix[5]) / mpctx.matrix[3];
        return this;
    };
    MPPoint.prototype.fromMultiTouchCenter = function (e) {
        var t = e.originalEvent.targetTouches;
        if (t.length > 1) {
            this.x = t[0].pageX;
            this.y = t[0].pageY;
            for (var i = 1; i < t.length; i++) {
                this.x += t[i].pageX;
                this.y += t[i].pageY;
            }
            this.x /= t.length;
            this.y /= t.length;
        }
        return this;
    };
    return MPPoint;
}());
/**
 * This file is part of MolView (http://molview.org)
 * Copyright (c) 2014, 2015 Herman Bergwerf
 *
 * MolView is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MolView is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with MolView.  If not, see <http://www.gnu.org/licenses/>.
 */
var MPSelection = (function () {
    function MPSelection(mp) {
        this.cache = { atoms: [], bonds: [] };
        this.mirrorSide = 1;
        this.startAngle = 0;
        this.currentAngle = 0;
        this.mp = mp;
    }
    MPSelection.prototype.hasCenter = function () {
        return typeof this.center === "object";
    };
    /**
     * Updates the cached selection
     */
    MPSelection.prototype.update = function () {
        this.cache.atoms = [];
        this.cache.bonds = [];
        for (var i = 0; i < this.mp.mol.atoms.length; i++) {
            if (this.mp.mol.atoms[i].isSelected()) {
                this.cache.atoms.push(i);
            }
        }
        for (var i = 0; i < this.mp.mol.bonds.length; i++) {
            if (this.mp.mol.bonds[i].isSelected()) {
                this.cache.bonds.push(i);
            }
        }
    };
    /**
     * Translate selection
     * Only atoms are translated
     * @param {Float} dx Horizontal translation
     * @param {Float} dy Vertical translation
     */
    MPSelection.prototype.translate = function (dx, dy) {
        for (var i = 0; i < this.cache.atoms.length; i++) {
            this.mp.mol.atoms[this.cache.atoms[i]].translate(dx, dy);
        }
    };
    /**
     * Rotate selection using a mouse pointer
     * @param {MPPoint} pointer
     */
    MPSelection.prototype.rotate = function (pointer) {
        this.currentAngle = this.mp.mol.rotateAtoms(this.center, pointer, this.cache.atoms, this.currentAngle, this.startAngle, this.mp.s.rotateSteps);
    };
    /**
     * Mirror selection using a pointer and a line
     * @param {Object}  line
     * @param {MPPoint} pointer
     */
    MPSelection.prototype.mirror = function (line, pointer) {
        var s = pointer.lineSide(line);
        if (s !== this.mirrorSide && s !== 0) {
            this.mirrorSide = s;
            for (var i = 0; i < this.cache.atoms.length; i++) {
                this.mp.mol.atoms[this.cache.atoms[i]].mirror(line, s);
            }
        }
    };
    /**
     * Clear current selection
     */
    MPSelection.prototype.clear = function () {
        this.mp.mol.exec(function (obj) {
            obj.selected = false;
        }, true, true);
        this.center = undefined;
        this.update();
        this.mp.requestRedraw();
    };
    /**
     * Collapse current selection
     */
    MPSelection.prototype.collapse = function () {
        this.mp.mol.collapseAtoms(this.cache.atoms.slice());
    };
    /**
     * Remove current selection
     */
    MPSelection.prototype.remove = function () {
        while (this.cache.atoms.length > 0) {
            this.mp.mol.removeAtom(this.cache.atoms[0]);
        }
        while (this.cache.bonds.length > 0) {
            this.mp.mol.removeBond(this.cache.bonds[0]);
        }
    };
    /**
     * Updates selection rotationCenter
     */
    MPSelection.prototype.updateRotationCenter = function () {
        var v = [];
        for (var i = 0; i < this.cache.atoms.length; i++) {
            if (this.mp.mol.atoms[this.cache.atoms[i]].hasUnselectedNeighbors()) {
                v.push(this.cache.atoms[i]);
            }
        }
        if (v.length === 1 && this.cache.atoms.length > 1) {
            this.center = this.mp.mol.atoms[v[0]].center;
            this.centerAtom = v[0];
        }
        else {
            this.center = undefined; //clear previous rotation center
        }
    };
    return MPSelection;
}());
/**
 * This file is part of MolView (http://molview.org)
 * Copyright (c) 2014, 2015 Herman Bergwerf
 *
 * MolView is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MolView is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with MolView.  If not, see <http://www.gnu.org/licenses/>.
 */
var PI2 = 2 * Math.PI;
/**
 * Calculate if value is inside deviation relative to a number
 * @param  {Float} val Input value
 * @param  {Float} num Deviation base
 * @param  {Float} dev Deviation value
 * @return {Boolean}
 */
function indev(val, num, dev) {
    return val > num - dev && val < num + dev;
}
/**
 * Calculate on which side b is relative to a in counter clockwise direction
 * @param {Float} a
 * @param {Float} b
 */
function radSide(a, b) {
    return angleBetween(a, b) < Math.PI ? 1 : -1;
}
/**
 * Normalize angle to value between 0 and 2PI
 * @param {Float} a
 */
function posRad(a) {
    while (a < 0)
        a += PI2;
    while (a > PI2)
        a -= PI2;
    return a;
}
/**
 * Calcualte smallest angle between two angles
 * @param {Float} a
 * @param {Float} b
 */
function smallestAngleBetween(a, b) {
    var d = Math.abs(posRad(a) - posRad(b));
    return d < PI2 - d ? d : PI2 - d;
}
/**
 * Calculate angle between two angles where from is the first encountered angle
 * in counter clockwise direction
 * @param {Float} from
 * @param {Float} to
 */
function angleBetween(from, to) {
    from = posRad(from);
    to = posRad(to);
    if (to <= from) {
        return to - from + PI2;
    }
    else {
        return to - from;
    }
}
/**
 * Calculate the given clamped angle between a point and a center
 * @param  {Float}   start  Angle offset
 * @param  {MPPoint} center Center of rotation
 * @param  {MPPoint} point  Target point
 * @param  {Float}   steps  Number of rotation steps in one circle
 * @return {Float}
 */
function clampedAngle(start, center, point, steps) {
    var a = center.angleTo(point);
    var clampFactor = steps / PI2;
    return posRad(Math.round((a - start) * clampFactor) / clampFactor
        + start); //clamp to x steps, normalize to startAngle
}
/**
 * Maps an array using a given map, removes all elements which are not
 * in the map
 * @param  {Array}  array
 * @param  {Object} map
 * @return {Array}
 */
function mapArray(array, map) {
    for (var i = 0; i < array.length; i++) {
        if (map[array[i]] !== undefined) {
            array[i] = map[array[i]];
        }
        else {
            array.splice(i, 1);
            i--;
        }
    }
    return array;
}
/**
 * Multiply all values in an array with a given multiplier into new array
 * @param  {Array} array
 * @param  {Float} mult
 * @return {Array}
 */
function transformArrayMult(array, mult) {
    var ret = [];
    for (var i = 0; i < array.length; i++)
        ret.push(array[i] * mult);
    return ret;
}
/**
 * Copy array into new array and add value
 * @param  {Array} array
 * @param  {Float} val
 * @return {Array}
 */
function transformArrayAdd(array, val) {
    var ret = [];
    for (var i = 0; i < array.length; i++)
        ret.push(array[i] + val);
    return ret;
}
/**
 * Also defined in main MolView Utility but this makes MolPad standalone
 * @param {String} nail
 * @param {Array}  haystack
 */
function oneOf(nail, haystack) {
    return haystack.indexOf(nail) !== -1;
}
function getMultiTouchDelta(e) {
    var t = e.originalEvent.targetTouches;
    if (t.length <= 1)
        return 0;
    else {
        var dx = Math.abs(t[0].pageX - t[1].pageX);
        var dy = Math.abs(t[0].pageY - t[1].pageY);
        return Math.sqrt(dx * dx + dy * dy);
    }
}
function sign(x) {
    //polyfill from Mozilla
    x = +x; // convert to a number
    if (x === 0 || isNaN(x))
        return x;
    return x > 0 ? 1 : -1;
}

MPFragments.init();

// export constants
//MolPad.MP_BOND_SINGLE = MP_BOND_SINGLE;
//MolPad.MP_BOND_DOUBLE = MP_BOND_DOUBLE;
//MolPad.MP_BOND_TRIPLE = MP_BOND_TRIPLE;
//MolPad.MP_STEREO_UP = MP_STEREO_UP;
//MolPad.MP_STEREO_DOWN = MP_STEREO_DOWN;
//
//MolPad.fragments = MPFragments;

return MolPad;
});

